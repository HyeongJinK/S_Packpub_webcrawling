<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec48"></a>Building the chainIsValid method</h2></div></div><hr /></div><p>Let's start building the consensus <span>algorithm</span><a id="id325268059" class="indexterm"></a> by creating a new method called <code class="literal">chainIsValid</code>. This method will validate whether or not a chain is legitimate. Let's get started with building this method:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>In the <code class="literal">blockchain.js</code> file, after the <code class="literal">proofOfWork</code> method, let's define the method as follows:</li></ol></div><pre class="programlisting">Blockchain.prototype.chainIsValid = function() {

}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Now, this method will take in a <code class="literal">blockchain</code> as an argument, and will return to us whether the <code class="literal">blockchain</code> is valid or not: </li></ol></div><pre class="programlisting">Blockchain.prototype.chainIsValid = function(<span class="strong"><strong>blockchain</strong></span>) {

}</pre><p> </p><p> </p><p> </p><p> </p><p>We're going to use this <code class="literal">chainIsValid</code> method to validate the other chains inside of the network when we are comparing them to the chain that is hosted on the current node. In order to validate that the blockchain is legitimate, we're simply going to iterate through every block inside of the blockchain and verify whether or not all of the hashes align correctly.</p><p>You might recall from <a class="link" href="#" linkend="ch02">Chapter 2</a>, <span class="emphasis"><em>Building a Blockchain</em></span>  that when the <code class="literal">createNewBlock</code> method was defined, that method consisted of the <code class="literal">previousBlockHash</code> and <code class="literal">hash</code> property. This <code class="literal">hash</code> property is the hash of the current block . To build the <code class="literal">chainIsValid</code> method, let's iterate through every block inside of the blockchain and make sure that the <code class="literal">previousBlockHash</code> property of a given block is exactly the same as the hash property in the previous block. Let's define this condition inside of the method as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>In order to iterate through every block inside of the blockchain, we'll use a <code class="literal">for</code> loop: </li></ol></div><pre class="programlisting">Blockchain.prototype.chainIsValid = function(blockchain) {

<span class="strong"><strong>  for (var i = 1; i &lt; blockchain.length; i++) {</strong></span>
<span class="strong"><strong></strong></span>
<span class="strong"><strong>       };  </strong></span>

};</pre><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>Inside of this <code class="literal">for</code> loop, let's compare the current block to the previous block:</li></ol></div><pre class="programlisting">Blockchain.prototype.chainIsValid = function(blockchain) {

       for (var i = 1; i &lt; blockchain.length; i++) {
<span class="strong"><strong>const currentBlock = blockchain[i];</strong></span>
<span class="strong"><strong>                const prevBlock = blockchain[i - 1];
</strong></span>
       };  

};</pre><p>As we iterate through the entire <span>chain</span><a id="id326365338" class="indexterm"></a> on every iteration, the <code class="literal">currentBlock</code> will be the value of <code class="literal">i</code>, and the <code class="literal">prevBlock</code> will be the value of <code class="literal">i - 1</code>.</p><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>Next, all we want to do is compare the <code class="literal">previousBlockHash</code> property on the <code class="literal">currentBlock</code> with the hash property on the previous block. In order to do this, define the following condition in the method: </li></ol></div><pre class="programlisting">Blockchain.prototype.chainIsValid = function(blockchain) {

       for (var i = 1; i &lt; blockchain.length; i++) {
                const currentBlock = blockchain[i];
                const prevBlock = blockchain[i - 1];
<span class="strong"><strong>if (currentBlock['previousBlockHash'] !== prevBlock['hash']) // chain is not valid...
</strong></span>
       };  

};</pre><p>When it comes to the preceding condition that we mentioned, if it is not satisfied, then we know that the chain is not valid, because the hashes are not lining up correctly.</p><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>To satisfy the verification condition, the <code class="literal">previousBlockHash</code> on the current block should be equal to the hash of the previous block. We're going to signify the aforementioned condition with the help of a flag inside of the method, as follows:</li></ol></div><pre class="programlisting">Blockchain.prototype.chainIsValid = function(blockchain) {
<span class="strong"><strong>let validChain = true;</strong></span>
       for (var i = 1; i &lt; blockchain.length; i++) {
                const currentBlock = blockchain[i];
                const prevBlock = blockchain[i - 1];
                if (currentBlock['previousBlockHash'] !== prevBlock['hash']) // chain is not valid...<span class="strong"><strong>
</strong></span>
       };  

};</pre><p>Initially, we have the <code class="literal">validChain</code> variable reading equal to <code class="literal">true</code>. As we go through the blockchain and see that the hashes don't align properly, then we would want to set the<code class="literal">validChain</code>variable to <code class="literal">false</code> to signify that the chain is not valid.</p><div class="orderedlist"><ol class="orderedlist arabic" start="7" type="1"><li>Now let's get back to the <code class="literal">if</code>statement. Add the aforementioned condition to it: </li></ol></div><pre class="programlisting">Blockchain.prototype.chainIsValid = function(blockchain) {
       let validChain = true; 
       for (var i = 1; i &lt; blockchain.length; i++) {
                const currentBlock = blockchain[i];
                const prevBlock = blockchain[i - 1];
                if (currentBlock['previousBlockHash'] !== prevBlock['hash']) <span class="strong"><strong>validChain = false;</strong></span><span class="strong"><strong>
</strong></span>
       };  

};</pre><p> </p><p> </p><p> </p><p> </p><div class="orderedlist"><ol class="orderedlist arabic" start="8" type="1"><li>At the end of the loop, we can simply return a <code class="literal">validChain</code> variable and we'll get the value returned as <code class="literal">true</code> if the chain is valid, and <code class="literal">false</code> if it is not:</li></ol></div><pre class="programlisting">Blockchain.prototype.chainIsValid = function(blockchain) {
       let validChain = true; 
       for (var i = 1; i &lt; blockchain.length; i++) {
                const currentBlock = blockchain[i];
                const prevBlock = blockchain[i - 1];
                if (currentBlock['previousBlockHash'] !==
                prevBlock['hash']) validChain = false;<span class="strong"><strong>
</strong></span>
       };  
<span class="strong"><strong>return validChain;</strong></span>
};</pre><div class="orderedlist"><ol class="orderedlist arabic" start="9" type="1"><li>There is one more thing that we want to do, and that is to validate that every single block inside of the chain has the correct data. We can do this by rehashing the <code class="literal">currentBlock</code> by using the <code class="literal">hashBlock</code> method. If the generated hash starts with four zeros as we saw in <a class="link" href="#" linkend="ch02">Chapter 2</a>, <span class="emphasis"><em>Building a Blockchain</em></span>, then we know that all of the data is valid. However, if it does not <span>start</span><a id="id326441370" class="indexterm"></a> with the four zeros then we know the data inside of the block is definitely not valid.
All we're going to do is iterate through every block in the chain is to rehash every block and make sure that each hash starts with four zeros. So inside of the <code class="literal">for</code> loop let's mention this condition by first defining a variable as follows: </li></ol></div><pre class="programlisting">Blockchain.prototype.chainIsValid = function(blockchain) {
       let validChain = true; 
       for (var i = 1; i &lt; blockchain.length; i++) {
                const currentBlock = blockchain[i];
                const prevBlock = blockchain[i - 1];
<span class="strong"><strong> const blockHash = this.hashBlock ();</strong></span>
                if (currentBlock['previousBlockHash'] !==
                prevBlock['hash']) validChain = false;<span class="strong"><strong>
</strong></span>
       };  
<span class="strong"><strong></strong></span>return validChain;
};</pre><div class="orderedlist"><ol class="orderedlist arabic" start="10" type="1"><li>The <code class="literal">hashblock()</code> method accepts parameters such as: <code class="literal">previousBlockhash</code>, <code class="literal">currentBlockData</code> and the <code class="literal">nonce</code>. Let's pass these parameters now: </li></ol></div><pre class="programlisting">const blockHash = this.hashBlock (<span class="strong"><strong>prevBlock['hash']</strong></span>);</pre><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><div class="orderedlist"><ol class="orderedlist arabic" start="11" type="1"><li>Next, we have to pass <code class="literal">currentBlockData</code> as parameter, which, as you might remember from the previous chapter, consists of the transactions in the <code class="literal">currentBlock</code> and the index of the <code class="literal">currentBlock</code>: </li></ol></div><pre class="programlisting">const blockHash = this.hashBlock(prevBlock['hash'], <span class="strong"><strong>{ transactions: currentBlock['transactions'], index: currentBlock['index'] } </strong></span>);</pre><div class="orderedlist"><ol class="orderedlist arabic" start="12" type="1"><li>Finally, the last parameter that we have to pass is <code class="literal">nonce</code>: </li></ol></div><pre class="programlisting">const blockHash = this.hashBlock (prevBlock['hash'], { transactions: currentBlock['transactions'], index: currentBlock['index'] } <span class="strong"><strong>currentBlock['nonce']</strong></span>);</pre><div class="orderedlist"><ol class="orderedlist arabic" start="13" type="1"><li>After defining these parameters, we should have the hash of <code class="literal">currentBlock</code> stored in the <code class="literal">blockHash</code> variable. Next, we just want to validate that the hash starts with the four zeros. So, inside of the <code class="literal">for</code> loop, we'll mention the following condition: </li></ol></div><pre class="programlisting">if (blockHash.substring(0, 4) !== '0000') validChain = false;</pre><p>Now, we're basically iterating through the entire blockchain and simply checking two things:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">One check that we do is making sure that all of the hashes align properly. If they do not align properly, we indicate that the chain is not valid.</li><li style="list-style-type: disc">The other check that we are doing is hashing every block, and making sure that the <code class="literal">blockHash</code> string starts with four zeros. If it does not start with the four zeros, then we indicate that the chain is not valid.</li></ul></div><p>Now the <code class="literal">chainIsValid</code> method is just about done here. However, one important thing that you might have noticed is that we haven't checked the genesis block for any of the methods yet. In the loop that we defined in the preceding block of code, we're starting at position 1, and totally skipping position 0, which is the genesis block. The genesis block is a kind of special block, because we made it ourselves without doing a proof of work:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Consequently, in order to validate the genesis block, we just want to make sure that it has the properties that we initially put onto it. So, outside of the <code class="literal">for</code> loop, we'll mention this condition as follows: </li></ol></div><pre class="programlisting">const genesisBlock = blockchain[0];</pre><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Now we just want to check and verify that all of the properties on the genesis block are correct. If you remember in <a class="link" href="#" linkend="ch02">Chapter 2</a>, <span class="emphasis"><em>Building a Blockchain</em></span> where we defined the genesis block, we assigned to it values such as <code class="literal">nonce</code>, with a value of <code class="literal">100</code>, <code class="literal">previousBlockHash</code>, with a value <code class="literal">0</code>, and the <code class="literal">hash</code> of the string 0 as well. So, let's check for these properties now to make sure that they're correct. In the following snippet, we add the preceding line of code to the following variables: </li></ol></div><pre class="programlisting">const genesisBlock = blockchain[0];
<span class="strong"><strong>const correctNonce = genesisBlock['nonce'] === 100;</strong></span>
<span class="strong"><strong>const correctPreviousBlockHash = genesisBlock['previousBlockHash'] === '0';</strong></span>
<span class="strong"><strong>const correctHash = genesisBlock['hash'] === '0';</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>Finally, we want to verify <span>that</span><a id="id326255737" class="indexterm"></a> the genesis block should have no transactions in it. So, to check this, we'll mention the following condition: </li></ol></div><pre class="programlisting">const correctTransactions = genesisBlock['transactions'].length === 0;</pre><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>Now, if we do have a legitimate genesis block, then all of these variables that we defined should be the value true. If any of these variables are not valid, then we want to change the <code class="literal">validChain</code> variable to <code class="literal">false</code> so that we know the blockchain is not valid. Let's mention this condition as follows: </li></ol></div><pre class="programlisting">if (!correctNonce || !correctPreviousBlockHash || !correctHash || !correctTransactions) validChain = false;</pre><p>Mentioning this last condition completes the <code class="literal">chainIsValid</code> method.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec38"></a>Testing the chainIsValid method</h3></div></div></div><p>Now let's test the <code class="literal">chainIsValid</code> method by <span>implementing</span><a id="id326327640" class="indexterm"></a> the following steps: </p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>In the <code class="literal">test.js</code> file, let's import the blockchain data structure and create a new instance of the blockchain, called <code class="literal">bitcoin</code>:  </li></ol></div><pre class="programlisting">const Blockchain = require('./blockchain');
const bitcoin = new Blockchain();</pre><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Next, let's generate a blockchain for us to test. We'll do this by starting at one of the servers. So go to the terminal, type <code class="literal">npn run node_1</code> and press <span class="emphasis"><em>Enter</em></span>. Then you'll receive the response, <strong class="userinput"><code>Listening on port 3001</code></strong>.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>On node <code class="literal">3001</code>, now let's create a blockchain and add some data to it so that we can test the new blockchain. Currently, the blockchain on node <code class="literal">3001</code> only has the genesis block in it. So, let's add a couple more blocks to the chain by hitting the <code class="literal">/mine</code> endpoint. Therefore, in the browser, go to <code class="literal">localhost:3001/mine</code> to create a new block.</li><li>Now, if you go to <code class="literal">localhost:3001/blockchain</code>, you should be able to observe the new block as follows: </li></ol></div><div class="mediaobject"><img src="/graphics/9781789618822/graphics/014b4207-dce7-4217-a789-f2889456ebf4.png" /></div><p>Thus, at node <code class="literal">3001</code>, we now have two blocks in the chain and one pending transaction, which is the mining reward transaction.</p><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>Next, let's create some transactions to add to the blockchain. To add the transaction, go to Postman and just add a couple of transactions there, as seen in the following screenshot. Let's send these transactions to <code class="literal">localhost:3001</code>, and also hit the <code class="literal">/transaction/broadcast</code> endpoint:   
</li></ol></div><div class="mediaobject"><img src="/graphics/9781789618822/graphics/4a480eef-1659-482a-8e8d-2d3a750c0de3.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>You can similarly add many other transactions to the node. </li><li>Once the transactions have <span>been</span><a id="id326341524" class="indexterm"></a> added, let's mine a new block by going to <code class="literal">localhost:3001/mine</code>. Once the new block has been mined, visit <code class="literal">localhost:3001/blockchain</code> in order to verify that the block has been added to the network. You should observe an output like the following: </li></ol></div><div class="mediaobject"><img src="/graphics/9781789618822/graphics/f74cb71f-d510-4451-b9e3-4c71fac819cd.png" /></div><p> </p><p> </p><p>You'll see that node <code class="literal">3001</code> consists of the third block with all the transaction data that we passed inside the block. We also have one pending transaction.</p><div class="orderedlist"><ol class="orderedlist arabic" start="8" type="1"><li>Next, let's add a couple more transactions to the node <code class="literal">3001</code> and then mine a new block on that node. You'll get to observe the similar output as seen in the previous case. The new transactions data that we added is now present inside the fourth block that we mined. Take a look at the following screenshot: </li></ol></div><div class="mediaobject"><img src="/graphics/9781789618822/graphics/f9305fe3-cc79-44ff-9263-ea6dce24053b.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="9" type="1"><li>Next, let's mine two more blocks without any data in them. So now, we have a blockchain with six blocks in it. Out of these six blocks, two blocks don't have any transaction data present in them. </li><li>Copy the entire blockchain present on <code class="literal">localhost:3001</code> and paste it in the <code class="literal">test.js</code> file. Then, after pasting the data in the <code class="literal">test.js</code> file, let's save that pasted text as a variable: </li></ol></div><pre class="programlisting">const bc1 { //.... the entier blockchain that we copied and pasted };</pre><div class="orderedlist"><ol class="orderedlist arabic" start="11" type="1"><li>Let's use the <code class="literal">chainIsValid</code> method to <span>validate</span><a id="id326350670" class="indexterm"></a> the chain. To do this, in the <code class="literal">test.js</code> file, let's mention the following: </li></ol></div><pre class="programlisting">console.log('VALID:' , bitcoin.chainIsValid(bc1.chain));</pre><div class="orderedlist"><ol class="orderedlist arabic" start="12" type="1"><li>Let's save the <code class="literal">test.js</code> file and run it. </li></ol></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec6"></a>Verifying the output of the test</h4></div></div></div><p>Now, when we run this file, we <span>should</span><a id="id326350706" class="indexterm"></a> receive verification of a valid blockchain, because we didn't tamper with it and created it legitimately, using all of the correct methods. Let's verify whether or not the <code class="literal">chainIsValid</code> method works correctly:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Head over to the Terminal and cancel the previous processes that were running by typing <code class="literal">^C</code> in the Terminal. </li><li>Once the processes are cancelled, then in the Terminal, let's type <code class="literal">node dev/test.js</code> and press <span class="emphasis"><em>Enter</em></span>. As we haven't tampered with the blockchain, we'll get the <code class="literal">Valid: true</code> response, as seen in the following screenshot: </li></ol></div><div class="mediaobject"><img src="/graphics/9781789618822/graphics/582bac40-489b-47e5-a92c-5087c0d03fe8.png" /></div><p>Now, let's tamper with the blockchain a little bit and see if we can get a false value returned:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Inside of the blockchain data that we pasted into the <code class="literal">test.js</code> file, let's change one of the hashes on any one of the blocks to see if it invalidates the blockchain.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Once you have changed the hash of any block, save the file and run the test again. Since the data is tampered now, you'll get the <code class="literal">false</code> response: </li></ol></div><div class="mediaobject"><img src="/graphics/9781789618822/graphics/947415d6-7ff4-4e9f-b43f-e19f14968f48.png" /></div><p>Next, let's mess with some of the transaction data in one of the blocks. If we change any of the transaction data inside of one of the blocks, the chain should not be valid and we should receive a false response for the test. </p><p>Finally, let's test the genesis block, which is the first block in the chain:</p><div class="mediaobject"><img src="/graphics/9781789618822/graphics/68459ddf-0905-4ce6-b5d5-4c78307d8b76.png" /></div><p>In the <code class="literal">test.js</code> file in the blockchain data that we pasted, let's change the <code class="literal">nonce</code> value to 10 from 100. After saving the file and running the test again in the Terminal, we should get the output returned as <code class="literal">false</code>. Since we tampered with the data in the blockchain in the <code class="literal">test.js</code> file, when we ran the test we got the response of <code class="literal">false</code>. This signifies that the blockchain is not valid or <span>legitimate</span><a id="id325846331" class="indexterm"></a> anymore, as the data inside it has been tampered with. So, from this test we can conclude that the <code class="literal">chainIsValid</code> method works perfectly, just as we expected it to. </p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec39"></a>A tiny modification to verify the results properly</h3></div></div></div><p>Now, one tiny thing that we need to do to help us understand how the <code class="literal">chainIsValid</code> method works is to log out the <code class="literal">previousBlockHash</code> and the <code class="literal">currentBlock</code> hash of every single block so that we can compare them ourselves. Consequently, in the <code class="literal">chainIsValid</code> method inside of the <code class="literal">for</code> loop, let's add the following lines of code before the loop ends: </p><pre class="programlisting">console.log('previousBlockHash =&gt;', prevBlock [ 'hash']);
console.log('currentBlockHash =&gt;', currentBlock [ 'hash']);</pre><p>Let's save this modification and run the test again. This time, when we run the test, we should see all of the hashes logged out so that we can compare them for ourselves and see what's really happening inside of this method. After running the test, you should see the<code class="literal">previousBlockHash</code>and<code class="literal">currentBlockHash</code> values, as in the following screenshot: </p><div class="mediaobject"><img src="/graphics/9781789618822/graphics/9210f58c-050b-41e9-b99c-c435a617da33.png" /></div><p>From the preceding screenshot, you <span>can</span><a id="id325846396" class="indexterm"></a> observe that for every iteration, the <code class="literal">previousBlockHash</code> value matches the <code class="literal">currentBlockHash</code> value of the previous block. If you look at all of the hashes, you can see them logged out in pairs. From the screenshot, we can observe that we have many pairs of identical hashes, which is what makes the blockchain valid.  </p><p> </p><p> </p></div></div>