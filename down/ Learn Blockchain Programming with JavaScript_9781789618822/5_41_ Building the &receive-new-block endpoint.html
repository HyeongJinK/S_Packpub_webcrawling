<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec44"></a>Building the /receive-new-block endpoint</h2></div></div><hr /></div><p>The next thing that we're <span>going</span><a id="id325268059" class="indexterm"></a> to do is build the <code class="literal">/receive-new-block</code> endpoint that we use in the updated <code class="literal">/mine</code> endpoint. Let's get started on building the endpoint:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>In the <code class="literal">dev/networkNode.js</code> file, before the <code class="literal">/register-and-broadcast-node</code> endpoint, define the <code class="literal">/receive-new-block</code> endpoint as follows: </li></ol></div><pre class="programlisting">app.post('/receive-new-block', function(req, res) {
};</pre><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Inside this endpoint, the code expects to receive a new block that is being broadcast. Let's save that new block in a variable, as highlighted in the following code: </li></ol></div><pre class="programlisting">app.post('/receive-new-block', function(req, res) {
<span class="strong"><strong>const newBlock = req.body.newBlock;</strong></span>

};</pre><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>When all of the other nodes receive this new block, they need to check whether it's actually a real block and whether it fits into the chain properly. To verify this, the <code class="literal">previousBlockHash</code> on the <code class="literal">newBlock</code> is checked to make sure that it's equal to the hash on the last block in the chain. For this, access to the last block in the chain is required:</li></ol></div><pre class="programlisting">app.post('/receive-new-block', function(req, res) {
    const newBlock = req.body.newBlock;
<span class="strong"><strong> const lastBlock = bitcoin.getLastBlock(); </strong></span>
};</pre><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>Next, let's test if the hash of the last block in the chain is equal to the <code class="literal">previousBlockHash</code> in the <code class="literal">newBlock</code> instance:</li></ol></div><pre class="programlisting">  lastBlock.hash === newBlock.previousBlockHash; </pre><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>This way, we know that this <code class="literal">newBlock</code> does indeed come right after the <code class="literal">lastBlock</code> in the chain. The preceding statement that is defined will return either <code class="literal">true</code> or <code class="literal">false</code>. The <code class="literal">true</code> or <code class="literal">false</code> value will be saved in a <code class="literal">correctHash</code> variable:</li></ol></div><pre class="programlisting"><span class="strong"><strong>const correctHash = </strong></span>lastBlock.hash === newBlock.previousBlockHash;</pre><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>After the preceding check, we also want to make sure that the <code class="literal">newBlock</code> has the correct index. This means that the <code class="literal">newBlock</code> should be one index above the <code class="literal">lastBlock</code> in the chain. Add the following check: </li></ol></div><pre class="programlisting">const correctIndex = lastBlock['index'] + 1 === newBlock['index'];</pre><div class="orderedlist"><ol class="orderedlist arabic" start="7" type="1"><li>Next, two different actions need to be taken depending on whether or not the <code class="literal">newBlock</code> is legitimate. If the <code class="literal">newBlock</code> is legitimate, it should be accepted and added to the chain. If not, it should simply be rejected. In order to define this condition, let's use an <code class="literal">if</code>-<code class="literal">else</code> statement:</li></ol></div><pre class="programlisting">if (correctHash &amp;&amp; correctIndex) {
    bitcoin.chain.push(newBlock);

}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="8" type="1"><li>Now, since the <code class="literal">newBlock</code> has been added to the chain, the <code class="literal">pendingTransactions</code> array needs to be cleared out, because the pending transactions are now inside the new block. Therefore, inside the <code class="literal">if</code> statement, the next condition to be added is as follows:</li></ol></div><pre class="programlisting">bitcoin.pendingTransaction = [];</pre><div class="orderedlist"><ol class="orderedlist arabic" start="9" type="1"><li>Then, the final thing that <span>needs</span><a id="id325679414" class="indexterm"></a> to be done is to send a response back, saying that the block has been accepted and added to the chain. Inside the <code class="literal">if</code> statement, below the preceding line, add the response as follows: </li></ol></div><pre class="programlisting">res.json({
    note: 'New block received and accepted.',
    newBlock: newBlock
})</pre><div class="orderedlist"><ol class="orderedlist arabic" start="10" type="1"><li>If the <code class="literal">newBlock</code> is not legitimate and does not pass either of the tests defined previously, then a response is sent inside of the <code class="literal">else</code> statement to indicate that the block was rejected:</li></ol></div><pre class="programlisting">else{
  res.json({
      note:'New block rejected.',
      newBlock: newBlock
  });  
}</pre><p>With the addition of this previous condition, we've finished building the <code class="literal">/receive-new-block</code> endpoint.</p></div>