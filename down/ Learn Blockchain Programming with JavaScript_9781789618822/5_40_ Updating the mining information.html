<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec43"></a>Updating the mining information</h2></div></div><hr /></div><p>The next thing that is required to <span>synchronize</span><a id="id325458916" class="indexterm"></a> the network is to update the <code class="literal">/mine</code> endpoint. We are also going to add a new endpoint, called <code class="literal">/receive-new-block</code>. There's a need to update the <code class="literal">/mine</code> endpoint so that whenever a new block is created by a node, that new block is broadcast to all the other nodes in the network. This means that every node on the network is aware that a new block has been created and all the nodes hosting the blockchain stay synchronized.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec36"></a>The updated mining process</h3></div></div></div><p>Whenever a new block is mined, it will be <span>mined</span><a id="id325458941" class="indexterm"></a> on a particular node. To understand the updated mining process, let's assume that we want a node, hosted on port <code class="literal">3001</code>, to mine a new block for the blockchain:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Firstly, the <code class="literal">/mine</code> endpoint will be hit on the selected node. When the <code class="literal">/mine</code> endpoint is hit, a new block is created by doing a proof of work.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Once the new block is created, it is broadcast to all the other nodes in the network. All the other nodes will receive that new block at their <code class="literal">/receive-new-block</code> endpoint. This is shown in the following diagram:</li></ol></div><div class="mediaobject"><img src="/graphics/9781789618822/graphics/7c84f7b1-56ff-4f43-a23b-22b0bc569e42.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>After the broadcast is complete, the entire network will be synchronized and all the nodes will host the same blockchain. </li></ol></div><p>Another thing to note is that when a new block is broadcast and a node receives it, that new block will be added to the chain after the chain has validated that <span>the</span><a id="id325684269" class="indexterm"></a> block is legitimate. Then, the node clears out its <code class="literal">pendingTransactions</code> array, because all the pending transactions are now within the new block they just received.</p><p>In the next couple of sections, we're going to build this whole process step by step. As we build each of these steps, it should be easier to see how everything works together.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec37"></a>Refactoring the /mine endpoint</h3></div></div></div><p> Let's refactor the <code class="literal">/mine</code> endpoint by <span>implementing</span><a id="id325690273" class="indexterm"></a> the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Head over to the <code class="literal">dev/networkNode.js</code> file. In the <code class="literal">/mine</code> endpoint, beneath the part where we had defined the <code class="literal">newBlock</code> variable, let's add the functionality to broadcast the new block to all the other nodes in the network. To do this, follow the same process that we introduced in the previous sections—that is, to loop through all the other nodes inside the network, make a request to the nodes, and send the <code class="literal">newBlock</code> variable as data:</li></ol></div><pre class="programlisting">bitcoin.networkNodes.forEach(networkNodeUrl =&gt; {

})</pre><p>The preceding line mentions that for each of the <code class="literal">networkNodes</code>, we're going to make a request and send along the <code class="literal">newBlock</code>. </p><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>We then need some request options to send. These options will be defined as follows: </li></ol></div><pre class="programlisting">bitcoin.networkNodes.forEach(networkNodeUrl =&gt; {
<span class="strong"><strong>const requestOptions = {</strong></span>
<span class="strong"><strong></strong></span>
<span class="strong"><strong>    };</strong></span>

})</pre><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>The first option in this object is the <code class="literal">uri</code>. The <code class="literal">uri</code> to which we want to send the request will be the <code class="literal">networkNodeUrl</code> and the new endpoint that we are going to create, which will be <code class="literal">/receive-new-block</code>. We'll work on this endpoint in the next section:</li></ol></div><pre class="programlisting">bitcoin.networkNodes.forEach(networkNodeUrl =&gt; {
    const requestOptions = {
<span class="strong"><strong> uri: networkNodeUrl + '/receive-new-block',</strong></span>
    }; 

})</pre><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>The next option to be added is the method that will be used, which is the <code class="literal">POST</code> method:</li></ol></div><pre class="programlisting">bitcoin.networkNodes.forEach(networkNodeUrl =&gt; {
    const requestOptions = {
        uri: networkNodeUrl + '/receive-new-block',<span class="strong"><strong>
        method: 'POST',
</strong></span>
    }; 

})</pre><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>Next, let's send along the data that will be inside the body. We also want to send along a <code class="literal">newBlock</code> instance:</li></ol></div><pre class="programlisting">bitcoin.networkNodes.forEach(networkNodeUrl =&gt; {
    const requestOptions = {
        uri: networkNodeUrl + '/receive-new-block',<span class="strong"><strong>
</strong></span>method: 'POST',<span class="strong"><strong>
</strong></span><span class="strong"><strong> body: { newBlock: newBlock }</strong></span>
    }; 

})</pre><p> </p><p> </p><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>Finally, after the <code class="literal">body</code>, set <code class="literal">json</code> to <code class="literal">true</code>, as follows:</li></ol></div><pre class="programlisting">bitcoin.networkNodes.forEach(networkNodeUrl =&gt; {
    const requestOptions = {
        uri: networkNodeUrl + '/receive-new-block',<span class="strong"><strong>
</strong></span>method: 'POST',<span class="strong"><strong>
</strong></span><span class="strong"><strong></strong></span>body: { newBlock: newBlock },
<span class="strong"><strong>  json: true</strong></span>
    }; 

})</pre><div class="orderedlist"><ol class="orderedlist arabic" start="7" type="1"><li>After that, make the request by adding the following highlighted line of code:</li></ol></div><pre class="programlisting">bitcoin.networkNodes.forEach(networkNodeUrl =&gt; {
    const requestOptions = {
        uri: networkNodeUrl + '/receive-new-block',<span class="strong"><strong>
</strong></span>method: 'POST',<span class="strong"><strong>
</strong></span><span class="strong"><strong></strong></span>body: { newBlock: newBlock },
<span class="strong"><strong></strong></span> json: true
    }; 
<span class="strong"><strong>rp(requestOptions)</strong></span>
})</pre><div class="orderedlist"><ol class="orderedlist arabic" start="8" type="1"><li>Every time one of these <span>requests</span><a id="id326126637" class="indexterm"></a> is made, it's going to return a promise. Let's make an array of all of these promises by adding the following highlighted code:</li></ol></div><pre class="programlisting"><span class="strong"><strong>const requestPromises = [];</strong></span>
bitcoin.networkNodes.forEach(networkNodeUrl =&gt; {
    const requestOptions = {
        uri: networkNodeUrl + '/receive-new-block',<span class="strong"><strong>
</strong></span>method: 'POST',<span class="strong"><strong>
</strong></span><span class="strong"><strong></strong></span>body: { newBlock: newBlock },
<span class="strong"><strong></strong></span> json: true
    }; 
<span class="strong"><strong>requestPromises.push(rp(requestOptions));</strong></span>
});</pre><p>After our <code class="literal">forEach</code> loop has run, we should have an array that is filled with promises.</p><div class="orderedlist"><ol class="orderedlist arabic" start="9" type="1"><li>Next, let's run all of those promises. Therefore, after the <code class="literal">forEach</code> block, add the following code:</li></ol></div><pre class="programlisting">Promise.all(requestPromises)
.then(data =&gt; {
    // ....
})</pre><p>After all of the requests have run, we want to carry out another calculation inside <code class="literal">.then(data =&gt; {    })</code>. If you remember, when a new transaction is created, the mining rewards transaction code, <code class="literal">bitcoin.createNewTransaction(12.5, "00" , nodeAddress);</code>, needs to be broadcast throughout the entire blockchain network. At the moment, when a new block is mined, we create a mining reward transaction, but it is not broadcast to the whole network. To broadcast it, the request will be sent to the <code class="literal">/transaction/broadcast</code> endpoint, because it already has the functionality to broadcast transactions. We're just going to make a call to this endpoint with the mining reward transaction data passed in.</p><div class="orderedlist"><ol class="orderedlist arabic" start="10" type="1"><li>Before passing the mining reward transaction data, however, we need some request options:</li></ol></div><pre class="programlisting">Promise.all(requestPromises)
.then(data =&gt; {
<span class="strong"><strong>const requestOptions = {</strong></span>
<span class="strong"><strong>        uri: bitcoin.currentNodeUrl + '/transaction/broadcast',</strong></span>
<span class="strong"><strong>        method: 'POST',</strong></span>
    };    

})</pre><div class="orderedlist"><ol class="orderedlist arabic" start="11" type="1"><li>The <code class="literal">body</code> data will be sent as an object. In the <code class="literal">body</code>, let's add the mining reward transaction data:</li></ol></div><pre class="programlisting">Promise.all(requestPromises)
.then(data =&gt; {
    const requestOptions = {
        uri: bitcoin.currentNodeUrl + '/transaction/broadcast',
        method: 'POST',
<span class="strong"><strong>body: {</strong></span>
<span class="strong"><strong>            amount: 12.5, </strong></span>
<span class="strong"><strong>            sender:"00", </strong></span>
<span class="strong"><strong>            recipient: nodeAddress</strong></span>
<span class="strong"><strong>        }</strong></span>
    };    

})</pre><div class="orderedlist"><ol class="orderedlist arabic" start="12" type="1"><li>Finally, after the <code class="literal">body</code>, set <code class="literal">json</code> to <code class="literal">true</code> by adding the following line:</li></ol></div><pre class="programlisting">json: true</pre><div class="orderedlist"><ol class="orderedlist arabic" start="13" type="1"><li>Then, after the <code class="literal">requestOptions</code>, let's send the following request:</li></ol></div><pre class="programlisting">return rp(requestOptions);</pre><p>At this point, inside the <code class="literal">/mine</code> endpoint, a <span>bunch</span><a id="id326130205" class="indexterm"></a> of calculations are being carried out to create a new block. Then, once the new block is created, it is broadcast to all the other nodes inside the network. After the broadcast is complete inside the <code class="literal">.then</code> block, a new request to the <code class="literal">/transaction/broadcast</code> endpoint is made. This request will create a mining reward transaction and the nodes will then broadcast it to the entire blockchain network. Then, after the request runs and all of the calculations are complete, a response is sent: <strong class="userinput"><code>New block mined successfully</code></strong>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip14"></a>Note</h3><p>You can view the complete updated mine endpoint code at <a class="ulink" href="https://github.com/PacktPublishing/Learn-Blockchain-Programming-with-JavaScript/blob/master/dev/networkNode.js" target="_blank">https://github.com/PacktPublishing/Learn-Blockchain-Programming-with-JavaScript/blob/master/dev/networkNode.js</a>.</p></div></div></div>