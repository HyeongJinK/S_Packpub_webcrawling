<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec17"></a>Creating the createNewTransaction method</h2></div></div><hr /></div><p>The next method that we are going to <span>add</span><a id="id325462128" class="indexterm"></a> to our blockchain constructor function is called <code class="literal">createNewTransaction</code>. This method will create a new transaction for us. Let's follow the below mentioned steps to create the method: </p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Start building up this method by adding the following line of code after our <code class="literal">getLastBlock</code> method:</li></ol></div><pre class="programlisting">Blockchain.prototype.createNewTransaction = function () {

}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>The <code class="literal">function ()</code> will take three parameters, such as the following:</li></ol></div><pre class="programlisting">Blockchain.prototype.createNewTransaction = function (<span class="strong"><strong>amount, sender, recipient</strong></span>) {

}</pre><p>What these three parameters will do is as follows: </p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">amount</code>: This parameter will take in the amount of the transaction or how much is being sent in this transaction.</li><li style="list-style-type: disc"><code class="literal">sender</code>: This will take in the sender's address.</li><li style="list-style-type: disc"><code class="literal">recipient</code>: This will take in the recipient's address.</li></ul></div><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>The next thing that we want to do inside of our <code class="literal">createNewTransaction</code> method is create a transaction object. So, add the following line of code to our method:</li></ol></div><pre class="programlisting">const newTransaction = {

}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>This object will have three properties in it. It will have an <code class="literal">amount</code>, a <code class="literal">sender</code>, and the <code class="literal">recipient</code>. These are the same three parameters that we passed into our <code class="literal">function()</code>. So, type in the following:</li></ol></div><pre class="programlisting">Blockchain.prototype.createNewTransaction = function (amount, sender, recipient) {
    const newTransaction = {
<span class="strong"><strong>amount: amount,</strong></span>
<span class="strong"><strong>        sender: sender,</strong></span>
<span class="strong"><strong>        recipient: recipient,</strong></span>
    };

}</pre><p>This is what our transaction object will look like. All of the transactions that we record on our <code class="literal">Blockchain</code> are going to look just like this. They all are going to have an amount, a sender, and the recipient, which is pretty straightforward and simple.</p><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>The next thing that we want to do <span>now</span><a id="id326190187" class="indexterm"></a> is push this <code class="literal">newTransaction</code> data into our <code class="literal">newTransactions</code> array. Let's do this by adding the following code after our <code class="literal">newTransaction</code> object:</li></ol></div><pre class="programlisting">this.newTransactions.push(newTransaction);</pre><p>So, the new transaction that we just created will now be pushed into our <code class="literal">newTransactions</code> array.</p><p>Now, let's just try to understand what this <code class="literal">newTransactions</code> array actually is. Basically, what is happening here with this <code class="literal">newTransactions</code> array is that on our blockchain there are going to be a lot of people who will be making a lot of different transactions. They will be sending money from one person to another and this will be happening repetitively. Every time a new transaction is created, it's going to be pushed into our <code class="literal">newTransactions</code> array.</p><p>However, all of the transactions in this array are not really set in stone. They're not really recorded in our blockchain yet. They will get recorded in our blockchain when a new block is mined, which is when a new block is created. All of these new transactions are pretty much just pending transactions, and they have not been validated yet. They get validated, set in stone, and recorded in our blockchain when we create a new block with the help of the <code class="literal">createNewBlock</code> method. </p><p>In our <code class="literal">createNewBlock</code> method, you can observe in <code class="literal">transactions: this.newTransactions</code> that we set the transactions on a new block equal to the <code class="literal">newTransactions</code> or the pending transactions in our blockchain. You can think of this <code class="literal">newTransactions</code> property on our blockchain as a pending transactions property.</p><p>For easy reference,  let's actually change all of the <code class="literal">newTransactions</code> properties in our code to <code class="literal">pendingTransactions</code> properties. Overall, when a new transaction is created, it is pushed into our <code class="literal">pendingTransactions</code> array. Then, when a new block is mined or when a new block is created, that's when all of our pending transactions become recorded on our blockchain, and they are then set in stone and can never be changed.</p><p>The point of all this is that before our method ends, we want to return in which block we will be able to find the new transactionbecause our new transaction will be in the next block when it is mined. Consequently, we'll simply type the following code:</p><pre class="programlisting">this.newTransactions.push(newTransaction);
return.this.getlastBlock()['index'] + 1;</pre><p>In the preceding code, <code class="literal">this.getlastBlock()</code> returns a block object for us. We want to get the index property of this block – adding<code class="literal">['index']</code>will provide us with the index of the last block in our chain, and adding<code class="literal">+ 1</code>will provide us with the number of the block our <span>transaction</span><a id="id326210595" class="indexterm"></a> was pushed to. </p><p>Let's have a quick recap,  the <code class="literal">createNewTransaction</code> method simply creates a <code class="literal">newTransaction</code> object, and then we push that <code class="literal">newTransaction</code> into our <code class="literal">pendingTransactions</code> array. Finally, we return the number of the block that the <code class="literal">newTransaction</code> will be added to.</p><p> </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec7"></a>Testing the createNewTransaction method</h3></div></div></div><p> Let's test the <code class="literal">createNewTransaction</code> method that we <span>created</span><a id="id326210636" class="indexterm"></a> in the previous section. Just as a heads up: this section is going to be a lot of fun, as here you will really start to understand how powerful a blockchain can be and how blocks and transactions work with each other. You'll also get to learn how the transactions are recorded in the blockchain. So let's get started: </p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>We're going to test our <code class="literal">createNewTransaction</code> method in our <code class="literal">test.js</code> file. In this file, we've already required our <code class="literal">blockchain.js</code> file and have made a new instance of our <code class="literal">Blockchain</code> called <code class="literal">bitcoin</code>, which we are logging out at the end of our file. Take a look at the following screenshot for a quick review: </li></ol></div><div class="mediaobject"><img src="/graphics/9781789618822/graphics/d62444b1-6414-4ecf-bc84-993953ff974d.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Now, the first thing that we're going to do in our <code class="literal">test.js</code> file is create a new block using our <code class="literal">createNewBlock</code> method, similarly to what we did in the <span class="emphasis"><em>Testing the createNewBlock method</em></span> section. Type in the following into your <code class="literal">test.js</code> file: </li></ol></div><pre class="programlisting">bitcoin.createNewBlock(789457,'OIUOEDJETH8754DHKD','78SHNEG45DER56');</pre><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>Next, what we want to do is create some new transactions to test our <code class="literal">createNewTransaction</code> method. This <code class="literal">createNewTransaction</code> method takes in three parameters, such as <code class="literal">amount</code>, a <code class="literal">sender</code>, and the <code class="literal">recipient</code>. Let's add this transaction data to our test case:</li></ol></div><pre class="programlisting">bitcoin.createNewTransaction(100,'ALEXHT845SJ5TKCJ2','JENN5BG5DF6HT8NG9');</pre><p>In the preceding line of code, we've set the amount of the transaction to <code class="literal">100 </code>and the sender and recipient's address to some random hash numbers.</p><p> </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note4"></a>Note</h3><p>You might have noticed the names <code class="literal">ALEX</code> and <code class="literal">JEN</code> in the addresses. We've added those just to simplify the identification of who the sender and recipient is. In reality, you would more than likely not have this kind of name appear at the beginning of an address. We've done this to make it easier for us to reference these addresses.</p></div><p>Now, let's just quickly summarize what we have done so far in our test case. Take a look at the following code block: </p><pre class="programlisting">const Blockchain = require('./blockchain');

const bitcoin = new Blockchain();

bitcoin.createNewBlock(789457,'OIUOEDJETH8754DHKD','78SHNEG45DER56');

bitcoin.createNewTransaction(100,'ALEXHT845SJ5TKCJ2','JENN5BG5DF6HT8NG9');


console.log(bitcoin); </pre><p>In the preceding code, we first required the bitcoin blockchain, and then we created a new block. After that, we created a new transaction, and then we logged out the bitcoin blockchain.</p><p>When we run this <code class="literal">test.js</code> file, we should expect to see our bitcoin blockchain, which should have one block in the chain as well as one transaction in the <code class="literal">pendingTransactions</code> array because we have not mined or created a new block after <span>creating</span><a id="id326369809" class="indexterm"></a> the transaction. Let's save this file and run it to see what we get. </p><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>Now go to your terminal window, type in the following command, and then press <span class="emphasis"><em>Enter</em></span>:</li></ol></div><pre class="programlisting"><span class="strong"><strong>node dev/test.js</strong></span></pre><p> </p><p>We get to observe the bitcoin blockchain on the terminal window, as shown in the following screenshot: </p><div class="mediaobject"><img src="/graphics/9781789618822/graphics/416f33b4-5484-4d3c-a70a-8ea8f4241db8.png" /></div><p>In the output on your window and in the preceding screenshot, you can observe our chain, which has the one block that we created.  In our <code class="literal">pendingTransactions</code> array, we have one <span>pending</span><a id="id326369859" class="indexterm"></a> transaction, which is the transaction we created in the test case. Looking at the output of the test, we can conclude that, so far, our <code class="literal">createNewTransaction</code> method works fine. </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec2"></a>Adding a pending transaction to our blockchain </h4></div></div></div><p>Now let's try to understand <span>how</span><a id="id326383942" class="indexterm"></a> we can get the <code class="literal">pendingTransaction</code> into our actual <code class="literal">chain</code> up here. The way we do that is by mining a new block or by creating a new block. Let's do that now:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>After we create the <code class="literal">newTransaction</code>, let's create a new block using the <code class="literal">createNewBlock</code> method, as highlighted in the following code:</li></ol></div><pre class="programlisting">const Blockchain = require('./blockchain');

const bitcoin = new Blockchain();

bitcoin.createNewBlock(789457,'OIUOEDJETH8754DHKD','78SHNEG45DER56');

bitcoin.createNewTransaction(100,'ALEXHT845SJ5TKCJ2','JENN5BG5DF6HT8NG9');

<span class="strong"><strong>bitcoin.createNewBlock(548764,'AKMC875E6S1RS9','WPLS214R7T6SJ3G2');</strong></span>

console.log(bitcoin);</pre><p>What we have done is created a block, created a transaction, and then mined a new block. Now the transaction that we created should show up in our second block because we mined a block after we created a transaction.</p><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Now save the file and run the test again. Let's see what we get from this. Go to your terminal and again type in the <code class="literal">node dev/test.js</code> command and press <span class="emphasis"><em>Enter</em></span>. You will get to observe the output that is shown in the following screenshot: </li></ol></div><div class="mediaobject"><img src="/graphics/9781789618822/graphics/f2cd9337-b364-48d9-935d-4fb68464f4b7.png" /></div><p>Here, we have our entire blockchain again, which has two blocks in it because we mined two blocks. The chain has our first block (<strong class="userinput"><code>index: 1</code></strong>), which has no transactions and has our second block (<strong class="userinput"><code>index: 2</code></strong>),  in which, if you look at our transactions, it says that there is an <strong class="userinput"><code>Array</code></strong> that has items in it versus a first block's transaction array, which has no items in it.</p><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>Now take a closer look at the second block's transaction array. We should expect to see the transaction that we had created previously. Let's make the following highlighted modification to our test case: </li></ol></div><pre class="programlisting">const Blockchain = require('./blockchain');

const bitcoin = new Blockchain();

bitcoin.createNewBlock(789457,'OIUOEDJETH8754DHKD','78SHNEG45DER56');

bitcoin.createNewTransaction(100,'ALEXHT845SJ5TKCJ2','JENN5BG5DF6HT8NG9');

bitcoin.createNewBlock(548764,'AKMC875E6S1RS9','WPLS214R7T6SJ3G2');

<span class="strong"><strong>console.log(bitcoin.chain[1]);</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>In this modification, we just <span>log</span><a id="id326384051" class="indexterm"></a> out of the second block in our chain. <code class="literal">[1]</code> in the code defines the position of the second block.  Save this file and run it. In the output, you can observe that we are simply logging out of the second block in our chain and you can see that, for transactions, it has an array with one object in it. Check out the following screenshot: </li></ol></div><div class="mediaobject"><img src="/graphics/9781789618822/graphics/19b5b368-d7ff-4ced-be94-c678b8b17603.png" /></div><p>This object is the transaction that we created in our test. What we did here was just create a transaction and then mine it by creating a new block or mining a new block, which now has our transaction in it. </p><p>Now, let's carry out a couple more examples to help clarify what is happening here. Let's take the <code class="literal">createNewTransaction</code> method and duplicate it three more times after our <code class="literal">createNewBlock</code> method. Make the modifications to the amounts as you wish to.</p><p>What's happening over here is that, from the top, we are first creating a block and then creating a transaction. We are then creating or mining a new block, so we should have one block with no transactions and another block with one transaction in it. After we create our second block, we are creating three more new transactions. At this point, all three of these new transactions should be in our <code class="literal">pendingTransactions</code> array because we are not creating a new block after we create these three transactions. Lastly, we log out of our bitcoin blockchain again. Your test should now look similar to the following:</p><pre class="programlisting">const Blockchain = require('./blockchain');

const bitcoin = new Blockchain();

bitcoin.createNewBlock(789457,'OIUOEDJETH8754DHKD','78SHNEG45DER56');

bitcoin.createNewTransaction(100,'ALEXHT845SJ5TKCJ2','JENN5BG5DF6HT8NG9');

bitcoin.createNewBlock(548764,'AKMC875E6S1RS9','WPLS214R7T6SJ3G2');

bitcoin.createNewTransaction(50,'ALEXHT845SJ5TKCJ2','JENN5BG5DF6HT8NG9');
bitcoin.createNewTransaction(200,'ALEXHT845SJ5TKCJ2','JENN5BG5DF6HT8NG9');
bitcoin.createNewTransaction(300,'ALEXHT845SJ5TKCJ2','JENN5BG5DF6HT8NG9');

console.log(bitcoin);</pre><p>Now, if we save the file and run it, we should have two blocks in our chain, and we should also have three transactions in the <code class="literal">pendingTransactions</code> array. Let's see <span>what</span><a id="id326386391" class="indexterm"></a> we get here. You will get to observe the following output on your screen: </p><div class="mediaobject"><img src="/graphics/9781789618822/graphics/19cdc890-c098-4464-8828-b3b9fab8eb4b.png" /></div><p>In the preceding screenshot, you can observe that we have our blockchain. In this chain, we have two blocks, just like we expected to have, and in our <code class="literal">pendingTransactions</code> array, we have three transactions, which are the three transactions that we had created in our test file. </p><p>What we have to do next is get these pending transactions into our chain. For that, let's mine another block. Just copy and paste the <code class="literal">creatNewBlock</code> method after the three transactions that we created and make modifications to its parameters as you wish to. When we run the test now, the three transactions that are pending should appear in our new block. Let's save the file and run the test. You will get to observe the following output: </p><div class="mediaobject"><img src="/graphics/9781789618822/graphics/5821ed82-c276-4ff8-a61d-04cbdbf5b6a1.png" /></div><p>So, we have our blockchain, which has three blocks in it. Our <code class="literal">pendingTransactions</code> array is currently empty, but where did those three transactions go? As it turns out, they should be in the last block that we created, which is the <strong class="userinput"><code>index: 3</code></strong> block. Inside of this third block we have <span>our</span><a id="id326386444" class="indexterm"></a> transactions, which should be the three transactions we just created. Let's take a deeper look at this by making a tiny modification to the last line of our test code, which is <code class="literal">console.log(bitcoin.chain[2]); </code>. The value <code class="literal">2</code> here specifies the third block in the chain. Let's save this modification and run the test again.  You will get to see the third block in the chain:</p><div class="mediaobject"><img src="/graphics/9781789618822/graphics/7666f907-af63-41ad-88d1-4451c76d5cb3.png" /></div><p>In the transaction's array, you can see that we have all three of the transactions that we created. So, this is how our <code class="literal">createNewTransaction</code> and <code class="literal">createNewBlock</code> methods work with each other.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip5"></a>Note</h3><p>If you are having trouble understanding how both of these methods work or how they work together, we encourage you to mess around with your <code class="literal">test.js</code> file and create some new blocks, create some new transactions, log some different information out, and get a good idea of how these things work.</p></div><p> </p></div></div></div>