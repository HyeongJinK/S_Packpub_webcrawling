<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec27"></a>Building the /mine endpoint</h2></div></div><hr /></div><p>Let's build the final endpoint for <span>our</span><a id="id325462128" class="indexterm"></a> blockchain API: the mine endpoint, this will mine and create a new block:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>To create a new block, we are going to use our <code class="literal">createNewBlock</code> method, which we already defined in our <code class="literal">blockchain.js</code> file. Let's go to our <code class="literal">api.js</code> file and create a new block inside the <code class="literal">/mine</code> endpoint: </li></ol></div><pre class="programlisting">app.get('/mine', function(req, res) {
    const newBlock = bitcoin.createNewBlock();
});</pre><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>This <code class="literal">createNewBlock</code> method takes in three parameters: <code class="literal">nonce</code>, <code class="literal">previousBlockHash</code>, and <code class="literal">hash</code>:</li></ol></div><pre class="programlisting">Blockchain.prototype.createNewBlock = function(nonce, previousBlockHash, hash) {
  const newBlock = {
    index: this.chain.length + 1,
    timestamp: Date.now(),
    transactions: this.pendingTransactions,
    nonce: nonce,
    hash: hash,
    previousBlockHash: previousBlockHash
  };

  this.pendingTransactions = [];
  this.chain.push(newBlock);

  return newBlock;
};</pre><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>Now we have to do calculations to get all these three pieces of data, so let's do that. Let's start by getting the previous block so that we can get its hash:</li></ol></div><pre class="programlisting">app.get('/mine', function(req, res) {
  const lastBlock = bitcoin.getLastBlock();
  const previousBlockHash = lastBlock['hash'];</pre><p>As you can see, we have created <code class="literal">lastBlock</code>, which is the last block in our chain – or the previous block to our new block. To get the last block's <code class="literal">hash</code>, we have created <code class="literal">previousBlockHash</code>. With that, we can now have our <code class="literal">previousBlockHash</code>, which is one of the parameters that we need for our <code class="literal">createNewBlock</code> method next.</p><p> </p><p> </p><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>Next, let's get our <code class="literal">nonce</code>. To produce a <code class="literal">nonce</code> for our block, we need to generate a <code class="literal">proofOfWork</code>, which we created in the <code class="literal">blockchain.js</code> file:</li></ol></div><pre class="programlisting">Blockchain.prototype.proofOfWork = function(previousBlockHash, currentBlockData) {
  let nonce = 0;
  let hash = this.hashBlock(previousBlockHash, currentBlockData,
  nonce);
  while (hash.substring(0, 4) !== '0000') {
    nonce++;
    hash = this.hashBlock(previousBlockHash, currentBlockData,
    nonce);
  }

  return nonce;
};</pre><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>In our <code class="literal">/mine</code> endpoint, we will add the following line:</li></ol></div><pre class="programlisting">const nonce = bitcoin.proofOfWork(previousBlockHash, currentBlockData);</pre><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>So, from our <code class="literal">proofOfWork</code> method we will get a <code class="literal">nonce</code> returned to us. let's save that as our <code class="literal">nonce</code> variable. Our <code class="literal">proofOfWork</code> method takes in two parameters: <code class="literal">previousBlockHash</code>, which we <span>already</span><a id="id325693403" class="indexterm"></a> have, and <code class="literal">currentBlockData</code>. Let's define our <code class="literal">currentBlockData</code>:</li></ol></div><pre class="programlisting">const currentBlockData = {
    transactions: bitcoin.pendingTransactions,
    index: lastBlock['index'] + 1
  };</pre><p>We have our <code class="literal">currentBlockData</code> as an object, and this consists of the data. This data will simply consist of the <code class="literal">transactions</code> in this block, and also an <code class="literal">index</code>, which is the index of the new block that we are going to create; the index of our <code class="literal">lastBlock</code> plus 1. The <code class="literal">currentBlockData</code> object is simply going to be the <code class="literal">transactions</code> that are present in this new block and its <code class="literal">index</code>. With this, we can now calculate our<code class="literal">nonce</code>, as we have with our<code class="literal">previousBlockHash</code>and<code class="literal">currentBlockData</code>.</p><div class="orderedlist"><ol class="orderedlist arabic" start="7" type="1"><li>Now, the final parameter that our <code class="literal">createNewBlock</code> method has to take in is a <code class="literal">hash</code> of this new block, so let's calculate that now. To create a hash of this new block, we are going to use our <code class="literal">hashBlock</code> method. We are going to add the following line in our <code class="literal">/mine</code> endpoint:</li></ol></div><pre class="programlisting">const blockHash = bitcoin.hashBlock(previousBlockHash, currentBlockData, nonce);</pre><p>As you know, we have already created the <code class="literal">hashBlock</code> method in the <code class="literal">blockchain.js</code> file. This method accepts three parameters: <code class="literal">previousBlockHash</code>, <code class="literal">currentBlockData</code>, and <code class="literal">nonce</code>. We already have all of these parameters, so we are calling it and saving the results in a variable called <code class="literal">blockHash</code>. </p><div class="orderedlist"><ol class="orderedlist arabic" start="8" type="1"><li>We now have all of the parameters that we need to run our <code class="literal">createNewBlock</code> method, so let's assign those:</li></ol></div><pre class="programlisting">const newBlock = bitcoin.createNewBlock(nonce, previousBlockHash, blockHash);</pre><p>What's happening here is pretty awesome. As you can see, there are a lot of different calculations that go into creating this new block, and we are able to make all of these calculations by using our blockchain data structure. This is a pretty powerful data structure, and our blockchain can now mine new blocks by using <code class="literal">proofOfWork</code>, which is similar to how many other blockchains function as well.</p><div class="orderedlist"><ol class="orderedlist arabic" start="9" type="1"><li>At this point, we have created <span>our</span><a id="id326126662" class="indexterm"></a> new block, and all we really have left to do is send the response back to whoever mined this block. Next, we will be adding the following line in our <code class="literal">/mine</code> endpoint:</li></ol></div><pre class="programlisting">res.json({
  note: "New block mined successfully",
  block: newBlock
});</pre><p>We are simply sending back a note that says <strong class="userinput"><code>New block mined successfully</code></strong>, as well as stating the <code class="literal">newBlock</code> that we just created. Now, sending back this <code class="literal">newBlock</code> is not going to affect our blockchain in any way. We are sending back the <code class="literal">newBlock</code> so that the person who created or mined this new block knows what it looks like.</p><div class="orderedlist"><ol class="orderedlist arabic" start="10" type="1"><li>Now there is one thing left that we have to do: Every time someone mines a new block, they get a reward for creating that new block. All we have to do is make a transaction and send the person who mined this new block a little bit of bitcoin as their reward. To do that, inside the <code class="literal">/mine</code> endpoint, we are going to create a new transaction:</li></ol></div><pre class="programlisting">bitcoin.createNewTransaction(12.5, "00", nodeAddress);</pre><p>Currently, in 2018, there is a 12.5 bitcoin reward for mining a new block in the real bitcoin blockchain. Just to stay consistent with the real bitcoin, we're going to make our reward<code class="literal">12.5</code>bitcoin too. As a sender address, we have put the value<code class="literal">00</code>,. This way, whenever we are looking at transactions on our network, we know that if a transaction is made from the address<code class="literal">00</code>, it is a mining reward.</p><p>Now all we need is a recipient's address, <code class="literal">nodeAddress</code>. We need to send <code class="literal">12.5</code> bitcoins to whoever mined a new block – but how can we find that? Well, we're going to be sending this reward to the current node that we are on, which is this whole API file that we are working on. We can treat this entire API as a network node in the bitcoin blockchain. </p><p>In future chapters, we're going to have multiple instances of our API, and they are going to act as different network nodes in the big clean blockchain. Right now, whenever we hit any of the endpoints we created, we are always only communicating with this one network node. However, since we know that all blockchain technology is decentralized and hosted across many different network nodes, we are going to be creating more network nodes as we proceed further. But for now, our entire blockchain is hosted solely on this one network node.</p><p>Now, any time we hit the <code class="literal">/mine</code> endpoint, we <span>want</span><a id="id326126951" class="indexterm"></a> to reward this node for mining the new block. To give this node the <code class="literal">12.5</code> bitcoin reward that it deserves, we need an address to send the bitcoin to, so let's create an address for this node now.</p><p>To create an address for this node, we are going to import a new library called <code class="literal">uuid</code> using our terminal:</p><div class="mediaobject"><img src="/graphics/9781789618822/graphics/1a50b504-0bf8-4a3f-8806-53e9d47e1c75.png" /></div><p>Once you have typed in the <code class="literal">npm i uuid --save</code> command and hit <span class="emphasis"><em>Enter</em></span>, the package will be added. You can start the server again with the <code class="literal">npm start </code>command.</p><p>Now let's import our new <code class="literal">uuid</code> library at the top section of our<code class="literal">api.js</code>file:</p><pre class="programlisting">const uuid = require('uuid/v1');</pre><p>As you can see, we have imported version 1 of the <code class="literal">uuid</code> library. This library creates a unique random string for us, and we're going to use that string as this network node's address. For that, we are going to add the following line:</p><pre class="programlisting">const nodeAddress = uuid().split('-').join('');</pre><p>One thing that we want to alter about the <span>string</span><a id="id326130197" class="indexterm"></a> that we get from this library is that there are a couple of dashes present – we don't want any dashes in our address. Here, we're simply going to split that string on all of the dashes and then rejoin it with an empty string that's been passed in. The <code class="literal">nodeAddress</code> that we are going to get is a random string that is guaranteed to be unique to a very high percentage. We really want this string to be unique because we don't want to have two nodes with the same address, otherwise we would end up sending bitcoin to the wrong people and that wouldn't be good. Now we can simply pass this <code class="literal">nodeAddress</code> variable into our <code class="literal">createNewTransaction</code> method.</p><p>In the next section, we will test our <code class="literal">/mine</code> endpoint, along with our <code class="literal">/transaction</code> and <code class="literal">/blockchain</code> endpoints, to make sure that they all work and interact correctly.</p></div>