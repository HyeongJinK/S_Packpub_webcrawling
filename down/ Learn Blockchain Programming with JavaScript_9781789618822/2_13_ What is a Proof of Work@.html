<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec19"></a>What is a Proof of Work?</h2></div></div><hr /></div><p>The next method that we are <span>going</span><a id="id325462128" class="indexterm"></a> to add to our blockchain data structure is the <code class="literal">proofOfWork</code> method. This method is very important and essential to the blockchain technology. It is because of this method that Bitcoin and many other blockchains are so secure.</p><p>Now, you must be getting curious about what a <span class="strong"><strong>Proof of Work</strong></span> (<span class="strong"><strong>PoW</strong></span>) actually is. Well, if we take a look at our blockchain, every blockchain is pretty much a list of blocks. Every single block has to be created and added to the chain. However, we don't just want any block to be created and added to the chain. We want to make sure that every block that is added to the chain is legitimate, has the correct transactions, and has the correct data inside of it. This is because if it doesn't have the correct transactions or the correct data, then people could fake how much Bitcoin they have and essentially cause fraud and steal money from other people. So, every time a new block is created, we first have to make sure that it is a legitimate block by mining it through PoW.</p><p>A <code class="literal">proofOfWork</code> method will take in the <code class="literal">currentBlockData</code> and the <code class="literal">previousBlockHash</code>. From this data that we supply, the <code class="literal">proofOfWork</code> method will try to generate a specific hash. This specific hash in our example is going to be a hash that starts with four zeros. So, with the given <code class="literal">currentBlockData</code> and the <code class="literal">previousBlockHash</code>, the method will somehow generate a resulting hash that begins with four zeros.</p><p>Now let's try to understand how we can do this. As we learned in the previous sections, the hash that is generated from SHA256 is pretty much random. So, if the resulting hash is pretty much random, then how can we generate a hash from our current block that starts with four zeros? The only way this can be done is by trial and error, or by guessing and checking. So, what we will have to do is run our <code class="literal">hashBlock</code> method many times until we end up getting lucky one time by generating a hash that has four zeros at the beginning.</p><p>Now, you might be wondering that the input to our <code class="literal">hashBlock</code> method are the <code class="literal">previousBlockHash</code>, <code class="literal">currentBlockData</code>, and <code class="literal">nonce</code> parameters. How will these three parameters that have been passed in once and possibly generate multiple different hashes, when, in actual fact, we're always passing exactly the same data? Furthermore, as we know from the previous section that whenever we pass in a specific piece of data, we are always going to get the same resulting hash generated from that data.</p><p>So, how can we alter this data in a way that does not change our <code class="literal">currentBlockData</code> or the <code class="literal">previousBlockHash</code>, but we still get a resulting hash that has four zeros at the beginning of it?  The answer to this question is that we are going to constantly change the nonce value.</p><p>This might all seem a bit confusing right now, so let's try to clarify it by knowing what actually happens in a <code class="literal">proofOfWork</code> by breaking it down a little bit.</p><p>Essentially, what is happening in our <code class="literal">proofOfWork</code> is that we're going to repeatedly hash our block until we find the correct hash, which will be any hash that starts with four zeros. We'll be changing the input to our <code class="literal">hashBlock</code> method by constantly incrementing the <span>nonce</span><a id="id326169902" class="indexterm"></a> value. The first time that we run our <code class="literal">hashBlock</code> method, we are going to start with a nonce value of 0. Then, if that resulting hash does not have four zeros at the beginning of it, we are going to run our <code class="literal">hashBlock</code> method again, except this time we are going to increment our nonce value by 1. If we do not get the correct hash value again, we're going to increment the nonce value and try it again. If that doesn't work, we'll again increment the nonce value and try again. Then we'll continually run this <code class="literal">hashBlock</code> method until we find a hash that begins with four zeros. That is how our <code class="literal">proofOfWork</code> method will function.</p><p>You might be wondering how this <code class="literal">proofOfWork</code> method actually secures the blockchain. The reason for this is because in order to generate the correct hash, we're going to have to run our <code class="literal">hashBlock</code> method many times, and this is going to use up a lot of energy and computing power.</p><p> </p><p>So, if somebody wanted to go back into the blockchain and try to change a block or the data in that block – perhaps to give themselves more Bitcoin – they would have to do a ton of calculations and use a lot of energy to create the correct hash. In most cases, going back and trying to recreate an already existing block or trying to re-mine an already existing block with your own fake data is not feasible. On top of that, not only does our <code class="literal">hashBlock</code> method take in the <code class="literal">currentBlockData</code>, it also takes in the previous <code class="literal">BlockHash</code>. This means that all of the blocks in the blockchain are linked together by their data.</p><p>If somebody tries to go back and re-mine or recreate a block that already exists, they would also have to re-mine and recreate every single block that comes after the first one that they recreated. This would take an incredible amount of calculation and energy, and is just not feasible for a well-developed blockchain. A person would have to go in, recreate a block by using a proof of work, and then recreate every block after that by doing a new proof of work for each block. This is just not feasible for any well-produced blockchain, and this is the reason why blockchain technology is so secure.</p><p>To summarize this section, what our <code class="literal">proofOfWork</code> method will basically do is repeatedly hash our <code class="literal">previousBlockHash</code>, our <code class="literal">currentBlockData</code>, and a nonce until we get an acceptable generated hash that starts with four zeros.</p><p>This might all seem overwhelming and a little bit confusing right now, but don't worry – we are going to build the <code class="literal">proofOfWork</code> method in the following section, and <span>then</span><a id="id325902775" class="indexterm"></a> we're going to test it with many different types of data. This will help you to become much more familiar with how the <code class="literal">proofOfWork</code> method functions and how it is securing the blockchain.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec11"></a>Creating the proofOfWork method</h3></div></div></div><p>Let's build out the <code class="literal">proofOfWork</code> method, which we <span>discussed</span><a id="id325902797" class="indexterm"></a> in the preceding section:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>After the <code class="literal">hashBlock</code> method, define the <code class="literal">proofOfWork</code> method as follows: </li></ol></div><pre class="programlisting">Blockchain.prototype.proofOfWork = function() {

}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>This method takes in two parameters: <code class="literal">previousBlockHash</code> and <code class="literal">currentBlockData</code>: </li></ol></div><pre class="programlisting">Blockchain.prototype.proofOfWork = function( previousBlockHash, currentBlockData) { 

}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>The first thing that we want to do inside of our method is define a nonce:</li></ol></div><pre class="programlisting">Blockchain.prototype.proofOfWork = function( previousBlockHash, currentBlockData) { 
    let nonce = 0;

}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>Next, we want to hash all of our data for the first time, so type in the following highlighted line of code: </li></ol></div><pre class="programlisting">Blockchain.prototype.proofOfWork = function( previousBlockHash, currentBlockData) { 
    let nonce = 0;
<span class="strong"><strong>let hash = this.hashBlock(previousBlockHash, currentBlockData,
     nonce);</strong></span>
}</pre><p>In the preceding code, you may notice that we used the term <code class="literal">let</code> because both our nonce and hash will be changing as we move through the method.</p><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>The next step that we want to do is constantly run the <code class="literal">hashBlock</code> method over and over again until we get a hash that starts with four zeros. We're going to do this repeated operation with the help of a <code class="literal">while</code> loop:</li></ol></div><pre class="programlisting">Blockchain.prototype.proofOfWork = function( previousBlockHash, currentBlockData) { 
    let nonce = 0;
    let hash = this.hashBlock(previousBlockHash, currentBlockData,
     nonce); 
<span class="strong"><strong>while (hash.substring(0, 4) !== '0000' {</strong></span>

<span class="strong"><strong>    } </strong></span>
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>If the hash that we created does not start with four zeros, we'll want to run our hash again, except this time with the different value of nonce. Consequently, inside of the <code class="literal">while</code> loop, add the following highlighted lines of code: </li></ol></div><pre class="programlisting">Blockchain.prototype.proofOfWork = function( previousBlockHash, currentBlockData) { 
    let nonce = 0;
    let hash = this.hashBlock(previousBlockHash, currentBlockData,
    nonce); 
    while (hash.substring(0, 4) !== '0000' {
<span class="strong"><strong>nonce++;</strong></span>
<span class="strong"><strong>        hash = this.hashBlock(previousBlockHash, currentBlockData,
        nonce);</strong></span>
    }<span class="strong"><strong></strong></span>
}</pre><p>Inside of the <code class="literal">while</code> loop, we are running our <code class="literal">hashBlock</code> method again with all the same data, except this time our nonce is incremented and equal to 1 instead of 0. This will be the first iteration of our while loop. Now, after the first iteration, the new hash that is generated doesn't have the <span>first</span><a id="id326088404" class="indexterm"></a> four characters equal to 0000. In this case, we'll want to generate a new hash. So, our while loop will run again, the nonce value will be incremented to 2 and a new hash will be created. If that hash also does not start with four zeros then the <code class="literal">while</code> loop will run again, the nonce value will be incremented again, and the hash will be generated again.</p><p>Our loop will continue doing this until it winds up with a hash that starts with four zeros. This might take many iterations. This could happen 10 times, 10,000 times, or 100,000 times.</p><p>This loop is where all of the calculations will take place, and this is the reason why the <code class="literal">proofOfWork</code> method uses so much energy – there are a lot of calculations being made. We'll continue going through the <code class="literal">while</code> loop until we generate a suitable hash that starts with four zeros. When we finally have the correct hash, our <code class="literal">while</code> loop will stop running, and at the end of our proofOfWork, it will simply return the nonce value that gave us the valid hash: </p><pre class="programlisting">Blockchain.prototype.proofOfWork = function( previousBlockHash, currentBlockData) { 
    let nonce = 0;
    let hash = this.hashBlock(previousBlockHash, currentBlockData, nonce); 
    while (hash.substring(0, 4) !== '0000' {
        nonce++;
        hash = this.hashBlock(previousBlockHash, currentBlockData, nonce);
    }<span class="strong"><strong></strong></span>
<span class="strong"><strong>return nonce;</strong></span>
}</pre><p> </p><p> </p><p>So, this is how our <code class="literal">proofOfWork</code> method will work and validate the hash. </p><p>In the following section, we'll test our <code class="literal">proofOfWork</code> method to make sure that it works properly. We'll also study why we return a nonce value instead of returning the hash.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec12"></a>Testing the proofOfWork method</h3></div></div></div><p>Let's test our <code class="literal">proofOfWork</code> method to make sure that it works properly. We'll be testing the method in our <code class="literal">test.js</code> file. So, let's get started:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Open up the <code class="literal">test.js</code> file. You might <span>observe</span><a id="id326089719" class="indexterm"></a> the data in a similar way to the following screenshot, which is present in the file from the previous section, <span class="emphasis"><em>Testing the hashBlock method</em></span>:</li></ol></div><p><span class="emphasis"><em><div class="mediaobject"><img src="/graphics/9781789618822/graphics/3abd46d8-81ac-4f9f-9505-17d5b1d2ba15.png" /></div></em></span></p><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>If you don't have any data in the <code class="literal">test.js</code> file, add this to your <code class="literal">test.js</code> file, as shown in the preceding screenshot, and then you can begin testing the data.   </li><li>To test our <code class="literal">proofOfWork</code> method, we need the <code class="literal">previousBlockHash</code> and <code class="literal">currentBlockData</code>. So, in our test case, get rid of the nonce value and add the following lines of code to our file: </li></ol></div><pre class="programlisting">console.log(bitcoin.proofOfWork(previousBlockHash, currentBlockData));</pre><p>Now, what we should get as a result from this <code class="literal">proofOfWork</code> method is a nonce value. What our <code class="literal">proofOfWork</code> method essentially does is test to see what the correct nonce value is to hash with our block data and our <code class="literal">previousBlockHash</code> to generate a resulting block hash that starts with four zeros. Here, <code class="literal">proofOfWork</code> finds the correct nonce for us.</p><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>Save this file and run our test by typing the<code class="literal">node dev/test.js</code>command in our terminal window. After the test is run, you will observe that a number pops up as an output on the screen: </li></ol></div><div class="mediaobject"><img src="/graphics/9781789618822/graphics/75694527-bd77-4978-a103-f69082a1f179.png" /></div><p>What this number signifies is that it took 27,470 iterations for our <code class="literal">proofOfWork</code> method to find a hash that starts with four zeros.</p><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>Now, to understand this whole process in-depth, what we can do is, inside of our <code class="literal">while</code> loop, log out of every hash that we try. We will have to <span>make</span><a id="id326190188" class="indexterm"></a> minor modifications to our <code class="literal">while</code> loop, as highlighted in the following code block: </li></ol></div><pre class="programlisting">while (hash.substring(0, 4) !== '0000' {
    nonce++;
    hash = this.hashBlock(previousBlockHash, currentBlockData,
    nonce);
<span class="strong"><strong>console.log(hash);</strong></span>
}</pre><p>When we run our test file now, what's going to happen is we should actually get to see 27,000 different hashes logged out inside of our terminal. None of these hashes will start with four zeros, except for the last one. Only the last hash that gets logged out should start with four zeros because after our method, this will terminate and return the nonce value for which the valid hash was obtained. </p><p>Now let's save our <code class="literal">test.js</code> file again. You can now observe on your screen that we have a whole bunch of different hashes being logged out to the terminal: </p><div class="mediaobject"><img src="/graphics/9781789618822/graphics/f0c91f83-48e2-4784-bf19-9b64f9b6a084.png" /></div><p>You can also observe that for every single hash <span>that</span><a id="id326190234" class="indexterm"></a> has been logged out, the beginning is never four zeros in a row until we obtain our final value.</p><p>Basically, what is happening over here is that we are generating the hash from our <code class="literal">currentBlockData</code>, <code class="literal">previousBlockHash</code>, and <code class="literal">nonce</code> of value 0. Then, for the next hash, we are incrementing the nonce by 1. So, it's all the same input data, but the nonce value is incremented until the valid hash is obtained. Finally, at 27,470, with the value of a nonce, the valid hash is obtained.  </p><p>Now let's try using our <code class="literal">hashBlock</code> method. In our <code class="literal">dev/test.js</code> file, delete the <code class="literal">proofOfWork</code> method and add the following line of code: </p><pre class="programlisting">console.log(bitcoin.hashBlock(previousBlockHash, currentBlockData, nonce));</pre><p>In the preceding code, for the nonce let's input the value 27,470. This value we obtained from our <code class="literal">proofOfWork</code> method.   </p><p>What we would observe as output is running the single hash with the correct nonce value that we obtained by running the <code class="literal">proofOfWork</code> method. By doing this, we <span>should</span><a id="id326255753" class="indexterm"></a> generate a hash that starts with four zeros on the first try. Let's save it and run it. Once the test is run, you will get to observe the single hash that starts with four zeros, as shown in the following screenshot:  </p><div class="mediaobject"><img src="/graphics/9781789618822/graphics/6d75eb06-da63-4976-83da-43a17b529248.png" /></div><p>The <code class="literal">proofOfWork</code> is a very important part of blockchain technology. It is very difficult to calculate, as you can observe from the test results – it took us more than 27,000 iterations to generate the correct hash. Consequently, a <code class="literal">proofOfWork</code> takes in a lot of energy and many calculations, and is very difficult to calculate.</p><p>Once we have the correct proof or the nonce value at which the desired hash is generated, it should be very easy for us to verify that we have the correct nonce value. We can verify this by simply passing it into our <code class="literal">hashBlock</code> method – we would obtain the hash that starts with four zeros.</p><p>It takes a lot of work to generate a proof of work, but it is very easy to verify that it is correct. So, if we ever want to go back into our blockchain and check to make sure that a block is valid, all you have to do is hash that block's data with the previous block's hash and the nonce that was generated from the <code class="literal">proofOfWork</code> when that block was mined. If this returns a valid hash to us that starts with four zeros, then we already know that the block is valid.</p><p>Thus, from our test, we can conclude that the <code class="literal">proofOfWork</code> method works as expected.  </p></div></div>