<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec33"></a>Let’s talk architecture styles</h2></div></div><hr /></div><p>As the cloud movement takes shape, gone are the <span>days</span><a id="id324953596" class="indexterm"></a> of monolithic enterprise applications, and in step smaller decentralized services. Applications have become more asynchronous and scale both horizontally and vertically, with deployments becoming more automated and predictable. With Azure, there are certain architectural styles that are commonly leveraged, and while these styles don’t rely on a specific technology, there are some technologies that fit into these architectures well.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec21"></a>Common application patterns</h3></div></div></div><p>Let’s take a look at a few <span>common</span><a id="id324953612" class="indexterm"></a> patterns in Azure:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Microservices:</strong></span> Small, independent services <span>that</span><a id="id324953630" class="indexterm"></a> implement a single business function. They contain the code, configuration, and data repository needed to support the service. They are small pieces of Lego you can leverage to build applications that are team agnostic and are updated often with little to no application impact. The following are examples of microservice resources in Azure:
<div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Service Fabric</li><li style="list-style-type: disc">Functions</li><li style="list-style-type: disc">WebJobs</li><li style="list-style-type: disc">Kubernetes</li><li style="list-style-type: disc">Container Services</li><li style="list-style-type: disc">Container Instances</li></ul></div></li><li style="list-style-type: disc"><span class="strong"><strong>Tiered:</strong></span> These are the applications <span>that</span><a id="id325433765" class="indexterm"></a> are broken up into layers, such as presentation, business logic, and data access. They require a bit of coordination to update, and each layer can have an impact on other development teams. The following are examples of tiered resources for Azure:
<div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">App Services</li><li style="list-style-type: disc">VMs
</li></ul></div></li><li style="list-style-type: disc"><span class="strong"><strong>Messaging:</strong></span> These are pub/sub or Web-Queue-Worker models <span>that</span><a id="id325439848" class="indexterm"></a> use queues to process message tasks. These can be long-running and involve workflows in their processing structures. I lump these together because they are asynchronous message processes at the end of the day. The following are examples of messaging resources for Azure:
<div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">IoT Hub</li><li style="list-style-type: disc">Service Bus</li><li style="list-style-type: disc">Logic Apps</li><li style="list-style-type: disc">Storage Queues</li></ul></div></li></ul></div><p>One of the things I learned in approaching Azure is that it challenged my thoughts on architecture. These changes contained constraints on how I approached design. This made me think about my approaches in a different light, causing me to need to understand the underlying principles and the constraints behind the style. When looking at these design constraints, it was important to note the trade-offs and that styles may change based on the challenges you’re looking to work through. I learned to apply my simplistic approach to not create complexity within my application domain so that I can manage dependencies cleanly. I also needed to decouple communication using asynchronous messaging, which helped with reliability and scalability. With Azure being a closed ecosystem, one of the biggest takeaways for me is how to manage the applications, which included monitoring, alerting, and logging. Now that we understand the basic architectural styles, we need to understand the technology behind our design.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec22"></a>How to make technology choices</h3></div></div></div><p>Since we learned about our as-a-service model in Azure in <a class="link" href="#" linkend="ch01">Chapter 1</a>, <span class="emphasis"><em>Getting Started with Azure</em></span>, here, we will look at how to choose compute resources in the IaaS and PaaS models. Some mainstream compute options in Azure include Virtual Machines, App Services, Service Fabric, and Container Services. When you are selecting a compute option, you will want to consider cost, hosting, availability, and scaling. Some services, such as Azure Functions, have a true consumption model, such as pay for use. This carries its own <span>issues</span><a id="id325441689" class="indexterm"></a> on shared infrastructure, such as cold starts and so on. Azure functions can also be VM or App Plan backed with dedicated resources. So, in this example, hosting is shared, the cost is minimal, and availability and scale are based on shared services. The App Plan or VM backed pricing goes up with dedicated resources and more controllable scale.</p><p>Code in <span>compute resources or services</span> should be deployed and maintained via a DevOps practice, which we will cover in later chapters. The following diagram is a little compute cheat sheet I like to use when choosing a compute service as I begin my design:</p><div class="mediaobject"><img src="/graphics/9781786468659/graphics/a3a8fefd-ca2d-4232-af6a-6dbe21010d75.png" /></div><p>How to select a resource cheat sheet</p><p>Compute services generally require a data store, and the requirements for this data are increasing in larger and larger volumes every year. This data can trigger various business behaviors and require auditing and security at its core. With this in mind, a single data approach is not the best approach as we begin our journey. We now have a schema and schemaless data structures. But as our journey expands, as do the types of data stores available to you, you should take a moment to understand which model or combination of models best suits your application:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Relational</p></td><td style="border-bottom: 0.5pt solid ; "><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Conforms to ACID (Atomic, Consistent, Isolated, Durable)</li><li style="list-style-type: disc">Use when strong consistency is needed</li><li style="list-style-type: disc">New transaction isolation</li><li style="list-style-type: disc">Tried and true data storage</li></ul></div></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Key/Value</p></td><td style="border-bottom: 0.5pt solid ; "><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Hash table-based</li><li style="list-style-type: disc">Key/value paired</li><li style="list-style-type: disc">Value is a blob</li><li style="list-style-type: disc">Optimized for lookup</li><li style="list-style-type: disc">Highly scalable</li><li style="list-style-type: disc">Can be distributed across multiple nodes</li></ul></div></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Document</p></td><td style="border-bottom: 0.5pt solid ; "><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Like key/value, stores named field elements (documents)</li><li style="list-style-type: disc">Document data can be queried</li><li style="list-style-type: disc">Document data doesn’t need to be the same across all documents</li></ul></div></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Object</p></td><td style="border-bottom: 0.5pt solid ; "><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Used to store large binary objects</li><li style="list-style-type: disc">Consists of a unique ID, metadata, and stored data</li></ul></div></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Files</p></td><td style=""><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Same as an object but for files specifically</li></ul></div></td></tr></tbody></table></div><p> </p><p>Now that we have discussed some technologies to use when looking at designing applications for Azure, let’s look at some designs that I think are very useful.</p></div></div>