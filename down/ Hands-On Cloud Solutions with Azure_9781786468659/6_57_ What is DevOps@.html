<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec60"></a>What is DevOps?</h2></div></div><hr /></div><p><span class="strong"><strong>DevOps</strong></span> is a software development <span>method</span><a id="id324953598" class="indexterm"></a> that emphasizes communication, collaboration, integration, automation, and a measure of cooperation between solution developers and IT professionals. As you can see in the following diagram, the method introduces a good process flow between developers and operations:</p><div class="mediaobject"><img src="/graphics/9781786468659/graphics/66819947-a555-49c8-8532-10b40c53fe28.png" /></div><p>DevOps flow</p><p>So what makes DevOps different than all the other software delivery methodologies we have used. To begin with, DevOps began as a software development method meant to drive an increased velocity in the building, testing, and release of software by <span>getting</span><a id="id325632227" class="indexterm"></a> two main groups – <span class="strong"><strong>Developers</strong></span> (<span class="strong"><strong>Dev</strong></span>) and <span class="strong"><strong>Operations</strong></span> (<span class="strong"><strong>Ops</strong></span>) to work together more effectively. DevOps can be used in conjunction with your Agile or lean methodologies as it is not a replacement for these processes <span>but</span><a id="id325632250" class="indexterm"></a> an enhancement. It is meant to help guide as much automation as possible in the spirit of speed and quality, while helping to refine your operational flow for better velocity. </p><p>Above all, it’s a culture thing!</p><p>What is this culture change we talk about? Let's review what DevOps is:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">It is less about what we do and more about how we do it, which means it is about how work gets done, and how people interact with each other</li><li style="list-style-type: disc">It is not an off-the-shelf boxed solution that can just be implemented, there is no one-size-fits-all approach – it is implementation</li><li style="list-style-type: disc">It is everyone's job, not an individual effort</li><li style="list-style-type: disc">The process is more about people and less about how much "stuff" can be forced down the pipeline</li></ul></div><p>Some tips for the DevOps journey:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">It’s about trust – development and operations teams being segregated from one another and not being enabled to communicate, let alone collaborate, effectively </li><li style="list-style-type: disc">Understand the people – try to understand ourselves first and then those around us</li><li style="list-style-type: disc">Stop the blame game</li><li style="list-style-type: disc">Embrace failure and learn</li><li style="list-style-type: disc">Focus on bottlenecks and flow – don’t be afraid to rethink your process or find a new pair of eyes to see the things you can’t because you are too close</li><li style="list-style-type: disc">Eliminate unplanned work – if the culture is to keep doing things that are breaking and broken, it’s tough to put aside the hours outside of the firefighting to make things happen</li><li style="list-style-type: disc">Be continuous</li><li style="list-style-type: disc">Create cross-functional teams</li><li style="list-style-type: disc">Embrace transparency</li><li style="list-style-type: disc">Build mastery and purpose – a single goal everyone can focus on</li></ul></div><p> </p><p>The reason this is important to <span>me</span><a id="id325632617" class="indexterm"></a> is because DevOps solves some delivery issues. The development and operations of the people who deliver the software are gauged on separate results, as you can see in the following table:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; "><p>Development resources are gauged on:</p><p> </p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Feature delivered after manual unit test on development systems</li><li style="list-style-type: disc">Rewarded mainly on timely delivery</li><li style="list-style-type: disc">Development systems not the same as production</li><li style="list-style-type: disc">Little to no concern about infrastructure/deployment impact related to code changes</li><li style="list-style-type: disc">Little to no feedback on changes until later in the software cycle</li></ul></div></td><td style=""><p>Operations resources are gauged on:</p><p> </p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Code delivered with little to no concern about infrastructure concern</li><li style="list-style-type: disc">Reward mainly for uptime</li><li style="list-style-type: disc">Left with solving security issues</li><li style="list-style-type: disc">Left with solving monitoring of the application with little to no knowledge of the application</li><li style="list-style-type: disc">Usually engaged at the tail end of the application development cycle</li></ul></div></td></tr></tbody></table></div><p> </p><p>As you can see, it was almost as if we were actually pitted against each other, causing an uphill battle with each group throwing grenades in the form of tasks and each not really understanding the reason behind the urgency of the tasks. Here are some important attributes that are needed to help bridge this gap:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Release management
<div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">More in-depth understanding of risks, dependencies, compliance issues</li></ul></div></li><li style="list-style-type: disc">Release/deployment coordination
<div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Better tracking of discrete activities, more consistent/faster escalation of issues, a documented process control, and reporting</li></ul></div></li><li style="list-style-type: disc">Release/deployment automation
<div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">More consistent and repeatable processes that can be automatically invoked and executed with or without (non-production) an approval process</li></ul></div></li></ul></div><p>Why is this important regarding to solutions in Azure? With Azure being a deviation from common infrastructure practices, both from a fundamental perspective but also from a process perspective, the DevOps culture change works in tandem with the Azure culture change. This provides a new way of software delivery and the tooling help provides more consistency to the change. While DevOps isn’t holistically about tooling, Azure provides a decent set of DevOps tools and processes for release management. This allows you to either fully automate the delivery of your software all the way to production, or set up semi-automated processes with approvals and on-demand deployments for any platform. Azure DevOps provides these main areas that help support these processes in one software package:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Azure boards</li><li style="list-style-type: disc">Azure repos</li><li style="list-style-type: disc">Azure pipelines</li><li style="list-style-type: disc">Azure artifacts</li><li style="list-style-type: disc">Azure test plans</li></ul></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec28"></a>Azure Boards</h3></div></div></div><p>To me, source control of your <span>code</span><a id="id325658540" class="indexterm"></a> not only protects your source but helps control changes to that source, but this truly fails in comparison to the business process management that helps <span>define</span><a id="id325658549" class="indexterm"></a> these changes before they happen. <span class="strong"><strong>Azure Boards</strong></span> is the place you plan and track your project deliverables. Azure Boards provides the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Boards</strong></span>: The flow of <span>work</span><a id="id325658570" class="indexterm"></a> for the team</li><li style="list-style-type: disc"><span class="strong"><strong>Work Items</strong></span>: Items to be completed <span>by</span><a id="id325658584" class="indexterm"></a> an individual</li><li style="list-style-type: disc"><span class="strong"><strong>Backlogs:</strong></span> Plan, organize, and prioritize <span>work</span><a id="id325658599" class="indexterm"></a> for the team</li><li style="list-style-type: disc"><span class="strong"><strong>Sprints:</strong></span> Time <span>frame</span><a id="id325658613" class="indexterm"></a> to complete work</li><li style="list-style-type: disc"><span class="strong"><strong>Queries:</strong></span> Filter criteria for <span>work</span><a id="id325658627" class="indexterm"></a> items or bulk updating</li><li style="list-style-type: disc"><span class="strong"><strong>Plans:</strong></span> A way to <span>review</span><a id="id325658641" class="indexterm"></a> deliverables
<p> </p></li></ul></div><p>These are shown here in the following figure:</p><div class="mediaobject"><img src="/graphics/9781786468659/graphics/27f94db3-fe8e-4094-9308-7f8019edc835.png" /></div><p>Azure Boards screen</p><p>All of the these are visualized within Azure Boards, which then leads us to how do we manage the code changes. Azure Repos provides code repositories to store source code and name the changes/version of that source code. These to me are the biggest features within Azure DevOps, as they are designed to protect the code and the meeting of the business process. Building a backlog and mapping out tasks helps everyone understand the deliverables and tasks being completed to meet those deliverables and then protect the code behind those deliverables. Now, this book holistically isn't about requirement gathering and project makeup. I wanted to take some time to review these events as I believe they are just as important as building the solutions. With this, let's talk about some things that will impact our development of the solution in Azure—protecting our source code. Let's look at a simplified flow the process code should take, shown here in the following diagram: </p><p> </p><div class="mediaobject"><img src="/graphics/9781786468659/graphics/5f0f8a67-24f5-4ae5-a735-0ebbed9d7c33.png" /></div><p>Simplified code flow with CI/CD</p><p>I prefer Git and the GitFlow process for my repository, as the pull request or PR process allows for better code review of changes being checked in the main branch. Now, branching structures can be a religious battle, but I prefer to keep it simple with the main and release strategy GitFlow offers out of the box. Even as a single developer model, I use this as it helps me keep myself honest. Let's take a quick look at how this plays out for the development process. The following diagram shows the pieces that are in play:</p><div class="mediaobject"><img src="/graphics/9781786468659/graphics/ed918142-8178-4e2a-a2e1-95864853f066.png" /></div><p>Development process flow</p><p>Learn more about Azure Boards at <a class="ulink" href="https://azure.microsoft.com/en-us/services/devops/boards/" target="_blank">https://azure.microsoft.com/en-us/services/devops/boards/</a>. </p><p> </p><p> </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec29"></a>Azure Artifacts</h3></div></div></div><p>Now, <span class="strong"><strong>Azure Artifacts</strong></span> is the package <span>you</span><a id="id325658929" class="indexterm"></a> share across applications, such as npm and NuGet. I leverage them a significant amount <span>over include 3rd party binaries directly, meaning the old <code class="literal">lib</code> folder in the source code with references to the <code class="literal">dlls</code></span>. When <span>you</span><a id="id325694925" class="indexterm"></a> use this process, it allows Azure Pipeline to restore/update the packages and deploy proper versions based on the <code class="literal">package.json</code> file in each project. I also recommend that if you have internal frameworks, that you package them and provide them through a feed, as you can see here in the following diagram:</p><div class="mediaobject"><img src="/graphics/9781786468659/graphics/2146458c-a6d3-448b-a7f2-db96277e90c1.png" /></div><p>Artifact dashboard and feed</p><p>If you would like to learn more <span>about</span><a id="id325694953" class="indexterm"></a> building your own package manager, you can get more information at <a class="ulink" href="https://docs.microsoft.com/en-us/azure/devops/artifacts/index?view=vsts" target="_blank">https://docs.microsoft.com/en-us/azure/devops/artifacts/index?view=vsts</a>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec30"></a>Azure Pipelines</h3></div></div></div><p><span class="strong"><strong>Azure DevOps Release Pipelines</strong></span> should have a <span>flow</span><a id="id325708630" class="indexterm"></a> that provides feedback on the state of the code to the individual developers checking in the code. This feedback should <span>come</span><a id="id325708637" class="indexterm"></a> in as quickly as <span>possible</span><a id="id325708646" class="indexterm"></a> and code check ins should be small and iterative. You should have your teams refrain from checking in larger amounts of code covering a large number of requirements; smaller check ins are easier to handle and adjust to. This will help reduce the merging process, however, teams should always do one pull for the latest code. Let's look at the sequence diagram of this process, as shown in the following diagram:</p><div class="mediaobject"><img src="/graphics/9781786468659/graphics/23d34bdf-a7d6-4883-9d38-791706d431b5.png" /></div><p>Release pipeline sequence diagram</p><p>Pipelines can not only deploy code but infrastructure as well, and are referred to as your CI/CD process. <span class="strong"><strong>Continuous Integration</strong></span> (<span class="strong"><strong>CI</strong></span>), is the process of developers checking in code, running tests, and receiving feedback based on the <span>stability</span><a id="id325708676" class="indexterm"></a> of the code <span>being</span><a id="id325708684" class="indexterm"></a> checked in. This process is integral as providing feedback this early in the process helps provide better overall code quality and more predictable build/test models, which means not relying on developer machines and hearing <span class="emphasis"><em>well, it works on my machine</em></span>. <span class="strong"><strong>Continuous Delivery</strong></span> (<span class="strong"><strong>CD</strong></span>), is the process that ensures your code is in a shippable state and <span>you</span><a id="id325708704" class="indexterm"></a> will use it to deploy source automatically to the configured environment. So, to sum this up, CI is the process that creates the artifacts to deploy and CD is the process to deploy them. </p><p>To start using Azure Pipelines, you will need to ensure the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">You have an organization created in Azure DevOps</li><li style="list-style-type: disc">Your source control is in a repository that Azure DevOps can access</li></ul></div><p>This will be the biggest part of your interaction with Azure DevOps and to me, the most fun. There is nothing like creating a process to automatically deploy your source code, once you check it in and tests have been completed. Once <span>this</span> is complete, you can create tests to validate the code that was just deployed. You can create your first pipeline in Azure DevOps at <code class="literal">https://docs.microsoft.com/en-in/azure/devops/pipelines/get-started-yaml?view=vsts</code>. </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec31"></a>Azure Test Plans</h3></div></div></div><p>One of the biggest things I think is <span>overlooked</span><a id="id325708737" class="indexterm"></a> in most software development is testing. Testing is an art most developers don't master nor understand. What I mean by that is <span>they</span><a id="id325708745" class="indexterm"></a> will test the code in accordance with how it was written. Azure Test Plans helps with the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Unit and functional testing</li><li style="list-style-type: disc">Continuous testing</li><li style="list-style-type: disc">Stakeholder feedback</li><li style="list-style-type: disc">Exploratory and manual testing</li><li style="list-style-type: disc">Performance testing</li></ul></div><p>The start of this process begins with unit testing and can lead to some functional testing to gain early and quick feedback. Pushing to a test environment can also help with gaining stakeholder feedback faster and allow course corrections more quickly. So, if you want to keep your changes smaller to allow for faster delivery of code then this process will help.</p><p> </p><p>Now, this isn't a book on testing so the more you automate lower in the development cycle, the more exploratory and performance testing time is available. I would like to point out that performance testing is more about code performance over the traditional <span class="emphasis"><em>testing the infrastructure</em></span> to know when to order more <span class="emphasis"><em>things</em></span> to help it run. Azure provides a large amount of scalability immediately over having to wait to order. So, your performance side focuses more on code than on infrastructure.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec32"></a>How I use Azure DevOps</h3></div></div></div><p>I usually start by creating an organization project at <a class="ulink" href="https://dev.azure.com/" target="_blank">https://dev.azure.com/</a>, then turn over the backlog to the business side of the house with a model of <span class="strong"><strong>Epic – Features – Tasks</strong></span>, with the <span>tasks</span><a id="id325717329" class="indexterm"></a> being entered by the developers. I work with the business team to create a good overall definition of <span class="emphasis"><em>done</em></span> for tasks, so the developers will understand how things are considered complete. I then create a repository for code, usually in Git, as I prefer the overall process of code merging. This does <span>come</span><a id="id325717340" class="indexterm"></a> with the caveat of the team understanding the process of PRing code and how to fetch the latest code changes before checking in to help minimize the collisions in code check in. Earlier, I included how the backlog looks, but let's look at how we get to the rest of the project setup. When you log in to the DevOps portal (<a class="ulink" href="https://dev.azure.com" target="_blank">https://dev.azure.com</a>), you will need to select your organization and the project within that organization, as you can see in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781786468659/graphics/1cd69ed7-df9f-474f-97a9-61885cb3181f.png" /></div><p>Azure DevOps dashboard</p><p>Once you select the project, you will then see the Azure DevOps menu structure and we need to create a repository for the code. I usually try to keep my repositories as small and as manageable as I can, only placing code needed. I use NuGet for shared code and third party libraries to simply dependencies. As you can see here, in the following diagram, create your repository or repositories needed to support the code development:</p><div class="mediaobject"><img src="/graphics/9781786468659/graphics/94bedcd9-a101-499b-b1ac-673ad0524637.png" /></div><p>Create a repository in Azure DevOps</p><p>I generally use HTTPS for Windows-based machines and SSH for Linux-based machines for repository cloning. For those who don't know, cloning is creating a <span class="emphasis"><em>local</em></span> copy of the only repository and branching is create a working copy of the code to work on. The <span>code</span><a id="id325717387" class="indexterm"></a> being worked on will use a pull request or PR to merge the <span>code</span><a id="id325717396" class="indexterm"></a> back into the CI main branch. This helps so that you can have an extra set of eyes to review the code by a different team member before it is checked in, formerly called a <span class="emphasis"><em>code review</em></span>. The PR process includes a build and an automated run of unit testing, then the merge happens.</p><p>Once your code repository in main is updated with a PR, your release pipeline should take over and build, then release your code to your development integration environment. This release or future releases can be released to QA or production with the same targeted build by either a manual/automated release with approvals. Let's see how a build would look, shown here in the following diagram:</p><div class="mediaobject"><img src="/graphics/9781786468659/graphics/ecf64ef4-70d8-4a01-8ccb-5bc36eca86b4.png" /></div><p>Build view</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip25"></a>Note</h3><p>For your <code class="literal">azure-pipelines.yml</code> file, the acceptable pool values are as follows:<code class="literal">pool:</code><code class="literal">vmImage: 'Ubuntu 16.04' # other options: 'macOS 10.13', 'VS2017-Win2016'</code></p></div><p>Once the builds are completed, you can now build out your release, as you can see in the following diagram. Now, I would like to note that there is not a one size fits all for pipelines, as they should contain all the necessary pieces to deploy an application:</p><div class="mediaobject"><img src="/graphics/9781786468659/graphics/6c8b1e68-57b0-4826-9655-547f3d92f8ce.png" /></div><p>Azure Pipelines release</p><p>So at the end of the day, I like my builds and releases to be phased, meaning I run the infrastructure part, the code deploys part, then the tests. I like to ensure I build out my PR and CI build process upfront as well, as my release process to automatically deploy at least to my development integration environment.</p></div></div>