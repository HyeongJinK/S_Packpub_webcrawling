<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec65"></a>Graph traversals</h2></div></div><hr /></div><p>A graph traversal means to visit all <span>the</span><a id="id326096708" class="indexterm"></a> vertices of the graph, while keeping track of which nodes or vertices have already been visited and which ones have not. A graph traversal algorithm is efficient if it traverses all the nodes of the graph in the minimum possible time. A common strategy of graph traversal is to follow a path until a dead end is reached, then traverse back up until there is a point where we meet an alternative path. We can also iteratively move from one node to another in order to traverse the full graph, or part of it. Graph traversal algorithms are very important in answering many fundamental problems—they can be useful to determine how to reach from one vertex to another in a graph, and which path from the A to B vertices in the graph is better than other paths. In the next section, we will discuss two important graph traversal algorithms: <span class="strong"><strong>breadth-first search</strong></span> (<span class="strong"><strong>BFS</strong></span>) and <span class="strong"><strong>depth-first search</strong></span> (<span class="strong"><strong>DFS</strong></span>).</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec58"></a>Breadth-first traversal </h3></div></div></div><p>Breadth-first traversal algorithms work breadth-wise in <span>the</span><a id="id325989981" class="indexterm"></a> graph. A queue data structure is used to store the information of vertices that are to be visited in the graph. We begin with <span>the</span><a id="id325989998" class="indexterm"></a> starting node, the <span class="strong"><strong>A</strong></span> node. Firstly, we visit that node, and then we look up all of its neighboring, or adjacent, vertices. We first visit these adjacent vertices one by one, while adding their neighbors to the list of vertices that are to be visited. We follow this process until we have visited all the vertices of the graph, ensuring that no vertex is visited twice.</p><p>Let's consider an example to better understand breadth-first traversal for graphs, using the following diagram:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/92b20157-8b78-413d-9c6a-2d76e30e131c.png" /></div><p>In the preceding diagram, we have a graph of five nodes on the left, and on the right, a queue data structure to store the vertices to be visited. We start visiting the first node, <span class="strong"><strong>A</strong></span>, and then add all its adjacent vertices, <span class="strong"><strong>B</strong></span>, <span class="strong"><strong>C</strong></span>, and <span class="strong"><strong>E</strong></span>, to the queue. Here, it is important to note that there are multiple ways of adding the adjacent nodes to the queue, since there are three nodes, <span class="strong"><strong>B</strong></span>, <span class="strong"><strong>C</strong></span>, and <span class="strong"><strong>E</strong></span>, that can be added in the queue as either <span class="strong"><strong>BCE</strong></span>, <span class="strong"><strong>CEB</strong></span>, <span class="strong"><strong>CBE</strong></span>, <span class="strong"><strong>BEC</strong></span>, or <span class="strong"><strong>ECB</strong></span>, each of which would give us different tree traversal results.</p><p> </p><p> </p><p>All of these possible solutions to the graph traversal are correct, but in this example, we will add the nodes in alphabetical order. The <span class="strong"><strong>A</strong></span>node is visited as shown: </p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/5631e020-3c1a-4142-a864-2b85170d6e1e.png" /></div><p>Once we have visited the <span class="strong"><strong>A</strong></span> vertex, next, we visit its first adjacent vertex, <span class="strong"><strong>B</strong></span>, and add those adjacent vertices that are not already added in the queue or not visited. In this case, we have to add the <span class="strong"><strong>D</strong></span>vertex to the queue:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/4616780c-e042-4aa3-b0d8-a4e569ab0102.png" /></div><p>Now, after visiting the <span class="strong"><strong>B</strong></span> vertex , we visit the next vertex from the queue—the <span class="strong"><strong>C</strong></span> vertex. And again, add those of its adjacent vertices that have not already been added in the queue. In this case, there are no unrecorded vertices left, so there is no need to do anything:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/987aa2f9-97cc-436f-8e1c-afe0ed6d0feb.png" /></div><p> </p><p>After visiting the <span class="strong"><strong>C</strong></span> vertex, we visit the next vertex from the queue, the <span class="strong"><strong>E</strong></span> vertex:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/a717e7fd-c865-4081-95a2-5f1ce238d4b7.png" /></div><p>Similarly, after visiting the <span class="strong"><strong>E</strong></span> vertex, we visit the <span class="strong"><strong>D</strong></span> vertex in the last step:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/1aa00311-608d-4c89-9a58-c278de680405.png" /></div><p>Therefore, the BFS algorithm for traversing <span>the</span><a id="id325851499" class="indexterm"></a> preceding graph visits the vertices in the order of <span class="strong"><strong>A-B-C-E-D</strong></span>. This is one of the possible solutions to the BFS traversal for the preceding graph, but we can get many possible solutions, depending on how we add the adjacent nodes to <span>the</span><a id="id325855473" class="indexterm"></a> queue.</p><p>To learn the implementation of this algorithm in Python, let's consider another example of an undirected graph. Consider the following diagram as a graph:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/dd3386cf-8fdd-4912-a28f-cb4f68336e4d.png" /></div><p>The adjacency list for the graph is as follows:</p><pre class="programlisting">    graph = dict() 
    graph['A'] = ['B', 'G', 'D'] 
    graph['B'] = ['A', 'F', 'E'] 
    graph['C'] = ['F', 'H'] 
    graph['D'] = ['F', 'A'] 
    graph['E'] = ['B', 'G'] 
    graph['F'] = ['B', 'D', 'C'] 
    graph['G'] = ['A', 'E'] 
    graph['H'] = ['C'] </pre><p>To traverse this graph using the breadth-first algorithm, we will employ the use of a queue. The algorithm creates a list to store the vertices that have been visited as the traversal process proceeds. We shall start our traversal from the <code class="literal">A</code> node.</p><p>The <code class="literal">A</code> node is queued and added to the list of visited nodes. Afterward, we use a <code class="literal">while</code> loop to effect traversal of the graph. In the <code class="literal">while</code> loop, the A node is dequeued. Its unvisited adjacent nodes, B, G, and D, are sorted in alphabetical order and queued up. The queue will now contain the B, D, and G nodes. These nodes are also added to the list of visited nodes. At this point, we start another iteration of the <code class="literal">while</code> loop, because the queue is not empty, which also means that we are not really done with the traversal.</p><p>The B node is dequeued. Out of its adjacent nodes, A, F, and E, node A has already been visited. Therefore, we only queue the E and F nodes in alphabetical order. The E and F nodes are then added to the list of visited nodes.</p><p>Our queue now holds the following nodes at this point—D, G, E, and F. The list of visited nodes contains A, B, D, G, E, and F.</p><p>The D node is dequeued, but all of its adjacent nodes have been visited, so we simply dequeue it. The next node at the front of the queue is G. We dequeue the G node, but we also find out that all its adjacent nodes have been visited, because they are in the list of visited nodes. So, the G node is also dequeued. We dequeue the E node too, because all of its nodes have also been visited. The only node in the queue now is the F node.</p><p>The F node is dequeued, and we realize that out of its adjacent nodes, B, D, and C, only C has not been visited. We then enqueue the C node and add it to the list of visited nodes. Then, the C node is dequeued. C has the adjacent nodes of F and H, but F has already been visited, leaving the H node. The H node is enqueued and added to the list of visited nodes.</p><p>Finally, the last iteration of the <code class="literal">while</code> loop will lead to the H node being dequeued. Its only adjacent node, C, has already been visited. Once the queue is completely empty, the loop breaks.</p><p>The output of the traversal the graph in the diagram is A, B, D, G, E, F, C, and H.</p><p>The code for a BFS is as follows:</p><pre class="programlisting">    from collections import deque 

    def breadth_first_search(graph, root): 
        visited_vertices = list() 
        graph_queue = deque([root]) 
        visited_vertices.append(root) 
        node = root 

        while len(graph_queue) &gt; 0: 
            node = graph_queue.popleft() 
            adj_nodes = graph[node] 

            remaining_elements = 
                set(adj_nodes).difference(set(visited_vertices)) 
            if len(remaining_elements) &gt; 0: 
                for elem in sorted(remaining_elements): 
                    visited_vertices.append(elem) 
                    graph_queue.append(elem) 

        return visited_vertices </pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note9"></a>Note</h3><p>When we want to find out whether a set of nodes are in the list of visited nodes, we use the <code class="literal">remaining_elements = set(adj_nodes).difference(set(visited_vertices))</code> statement. This uses the <code class="literal">set</code> object's <code class="literal">difference</code> method to find the nodes that are in <code class="literal">adj_nodes</code>, but not in <code class="literal">visited_vertices</code>.</p></div><p>In the worst-case scenario, each vertex or node and <span>the</span><a id="id325855601" class="indexterm"></a> edge will be traversed, thus the time complexity of the BFS algorithm is <code class="literal">O(|V| + |E|)</code>, where <code class="literal">|V|</code> is <span>the</span><a id="id325860325" class="indexterm"></a> number of vertices or nodes, while <code class="literal">|E|</code> is the number of edges in the graph.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec59"></a>Depth-first search</h3></div></div></div><p>As the name suggests, the DFS algorithm traverses <span>the</span><a id="id325895053" class="indexterm"></a> depth of any <span>particular</span><a id="id325895160" class="indexterm"></a> path in the graph before traversing its breadth. As such, child nodes are visited first before sibling nodes. The <code class="literal">stack</code> data structure is used to implement the DFS algorithm.</p><p>We start by visiting the A node, and then we look at the neighbors of the A vertex, then a neighbor of that neighbor, and so on. Let's consider the following graph in the context of DFS:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/87d04746-2b0b-411f-afd3-34ec345e9660.png" /></div><p>After visiting the <span class="strong"><strong>A</strong></span> vertex, we visit one of its neighbors, <span class="strong"><strong>B</strong></span>, as shown:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/5b085dc5-5a3e-4d30-b376-45f562b1a864.png" /></div><p>After visiting the <span class="strong"><strong>B</strong></span> vertex, we look at another neighbor of <span class="strong"><strong>A</strong></span>, that is, <span class="strong"><strong>S</strong></span>, as there is no vertex connected to <span class="strong"><strong>B</strong></span> which can be visited. Next, we look for the neighbors of the <span class="strong"><strong>S</strong></span> vertex, which are the <span class="strong"><strong>C</strong></span> and <span class="strong"><strong>G</strong></span> vertices. We visit <span class="strong"><strong>C</strong></span> as follows:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/8ae023e6-0314-4e68-bd83-9172d3d14454.png" /></div><p>After visiting the <span class="strong"><strong>C</strong></span>node, we visit its neighboring vertices, <span class="strong"><strong>D</strong></span> and <span class="strong"><strong>E</strong></span>:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/e800c5d5-2695-42c7-b956-f2e86b7ff96d.png" /></div><p> </p><p>Similarly, after visiting the <span class="strong"><strong>E</strong></span> vertex, we visit the <span class="strong"><strong>H</strong></span> and <span class="strong"><strong>F</strong></span> vertices, as shown in the following graphs:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/0a9ae9bd-82d8-4810-bf55-6d7cae6e7397.png" /></div><p>Finally, we visit the <span class="strong"><strong>F</strong></span> node:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/98569b98-cff3-4c4b-b5e0-0dd9337f8810.png" /></div><p> </p><p> </p><p>The output of the DFS traversal is <span class="strong"><strong>A-B-S-C-D-E-H-G-F</strong></span>.</p><p>To implement the DFS, we <span>start</span><a id="id325922071" class="indexterm"></a> with the adjacency <span>list</span><a id="id325922080" class="indexterm"></a> of the given graph. Here is the adjacency list of the preceding graph:</p><pre class="programlisting">graph = dict() 
    graph['A'] = ['B', 'S'] 
    graph['B'] = ['A'] 
    graph['S'] = ['A','G','C'] 
    graph['D'] = ['C'] 
    graph['G'] = ['S','F','H'] 
    graph['H'] = ['G','E'] 
    graph['E'] = ['C','H'] 
    graph['F'] = ['C','G'] 
    graph['C'] = ['D','S','E','F'] </pre><p>The implementation of the DFS algorithm begins by creating a list to store the visited nodes. The <code class="literal">graph_stack</code> stack variable is used to aid the traversal process. We are using a regular Python list as a stack. The starting node, called <code class="literal">root</code>, is passed with the graph's adjacency matrix, graph. <code class="literal">root</code> is pushed onto the stack. <code class="literal">node = root</code> holds the first node in the stack:</p><pre class="programlisting">    def depth_first_search(graph, root): 
        visited_vertices = list() 
        graph_stack = list() 

        graph_stack.append(root) 
        node = root </pre><p>The body of the <code class="literal">while</code> loop will be executed, provided the stack is not empty. If <code class="literal">node</code> is not in the list of visited nodes, we add it. All adjacent nodes to <code class="literal">node</code> are collected by <code class="literal">adj_nodes = graph[node]</code>. If all the adjacent nodes have been visited, we pop that node from the stack and set <code class="literal">node</code> to <code class="literal">graph_stack[-1]</code>. <code class="literal">graph_stack[-1]</code> is the top node on the stack. The <code class="literal">continue</code> statement jumps back to the beginning of the <code class="literal">while</code> loop's test condition.</p><pre class="programlisting">        while len(graph_stack) &gt; 0: 
            if node not in visited_vertices: 
                visited_vertices.append(node) 
            adj_nodes = graph[node] 
            if set(adj_nodes).issubset(set(visited_vertices)): 
                graph_stack.pop() 
                if len(graph_stack) &gt; 0: 
                    node = graph_stack[-1] 
                continue 
                else: 
                    remaining_elements =                                
                    set(adj_nodes).difference(set(visited_vertices)) 

            first_adj_node = sorted(remaining_elements)[0] 
            graph_stack.append(first_adj_node) 
            node = first_adj_node 
        return visited_vertices </pre><p>If, on the other hand, not all the adjacent nodes have been visited, then the nodes that are yet to be visited are obtained by finding the difference between the <code class="literal">adj_nodes</code> and <code class="literal">visited_vertices</code> with the <code class="literal">remaining_elements = set(adj_nodes).difference(set(visited_vertices))</code> statement.</p><p>The first item within <code class="literal">sorted(remaining_elements)</code> is assigned to <code class="literal">first_adj_node</code>, and pushed onto the stack. We then point the top of the stack to this node.</p><p>When the <code class="literal">while</code> loop exists, we will return <code class="literal">visited_vertices</code>.</p><p>We will now explain the working of the source code by relating it to the previous example. The <span class="strong"><strong>A</strong></span> node is chosen as our starting node. <span class="strong"><strong>A</strong></span> is pushed onto the stack and added to the <code class="literal">visisted_vertices</code> list. In doing so, we mark it as having been visited. The <code class="literal">graph_stack</code>stack is implemented with a simple Python list. Our stack now has A as its only element. We examine the <span class="strong"><strong>A</strong></span> node's adjacent nodes, <span class="strong"><strong>B</strong></span> and <span class="strong"><strong>S</strong></span>. To test whether all the adjacent nodes of <span class="strong"><strong>A</strong></span> have been visited, we use the <code class="literal">if</code> statement:</p><pre class="programlisting">    if set(adj_nodes).issubset(set(visited_vertices)): 
        graph_stack.pop() 
        if len(graph_stack) &gt; 0: 
            node = graph_stack[-1] 
        continue </pre><p>If all the nodes have been visited, we pop the top of the stack. If the <code class="literal">graph_stack</code>stack is not empty, we assign the node on top of the stack to <code class="literal">node</code>, and start the beginning of another execution of the body of the <code class="literal">while</code> loop. The <code class="literal">set(adj_nodes).issubset(set(visited_vertices))</code>statement will evaluate to <code class="literal">True</code> if all the nodes in <code class="literal">adj_nodes</code> are a subset of <code class="literal">visited_vertices</code>. If the <code class="literal">if</code> statement fails, it means that some nodes remain to be visited. We obtain that list of nodes with <code class="literal">remaining_elements = set(adj_nodes).difference(set(visited_vertices))</code>.</p><p>Referring to the diagram, the <span class="strong"><strong>B</strong></span> and <span class="strong"><strong>S</strong></span> nodes will be stored in <code class="literal">remaining_elements</code>. We will access the list in alphabetical order as follows:</p><pre class="programlisting">    first_adj_node = sorted(remaining_elements)[0] 
    graph_stack.append(first_adj_node) 
    node = first_adj_node</pre><p> </p><p> </p><p> </p><p> </p><p>We sort <code class="literal">remaining_elements</code> and return the first node to <code class="literal">first_adj_node</code>. This will return <span class="strong"><strong>B</strong></span>. We push the <span class="strong"><strong>B</strong></span> node onto the stack by appending it to the <code class="literal">graph_stack</code>. We prepare the <span class="strong"><strong>B</strong></span> node for access by assigning it to <code class="literal">node</code>.</p><p>On the next iteration of the <code class="literal">while</code> loop, we add the <span class="strong"><strong>B</strong></span> node to the list of <code class="literal">visited nodes</code>. We discover that the only adjacent node to <span class="strong"><strong>B</strong></span>, which is <span class="strong"><strong>A</strong></span>, has already been visited. Because all the adjacent nodes of <span class="strong"><strong>B</strong></span> have been visited, we pop it off the stack, leaving <span class="strong"><strong>A</strong></span> as the only element on the stack. We return to <span class="strong"><strong>A</strong></span> and examine whether all of its adjacent nodes have been visited. The <span class="strong"><strong>A</strong></span> node now has <span class="strong"><strong>S</strong></span> as the only unvisited node. We push <span class="strong"><strong>S</strong></span> to the stack and begin the whole process again.</p><p>The output of the traversal is <code class="literal">A-B-S-C-D-E-H-G-F</code>.</p><p>DFS find <span>applications</span><a id="id325948988" class="indexterm"></a> in solving <span>maze</span><a id="id325981971" class="indexterm"></a> problems, finding connected components, and finding the bridges of a graph, among others.</p></div></div>