<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec14"></a>Overview of data types and objects</h2></div></div><hr /></div><p>Python contains various built-in data types. These include four numeric types (<code class="literal">int</code>, <code class="literal">float</code>, <code class="literal">complex</code>, <code class="literal">bool</code>), four sequence types (<code class="literal">str</code>, <code class="literal">list</code>, <code class="literal">tuple</code>, <code class="literal">range</code>), one mapping type (<code class="literal">dict</code>), and two set types. It is also possible to create user-defined objects, such as functions or classes. We will look at the string and the list data types in this <span>chapter</span><a id="id325644866" class="indexterm"></a> and the <span>remaining</span><a id="id325644853" class="indexterm"></a> built-in types in <span>the next chapter</span>.</p><p>All data types in Python are <span class="strong"><strong>objects</strong></span>. In fact, pretty much everything is an object in Python, including modules, classes, and functions, as well as literals such as strings and integers. Each object in Python has a <span class="strong"><strong>type</strong></span>, a <span class="strong"><strong>value,</strong></span> and an <span class="strong"><strong>identity</strong></span>. When we write <code class="literal">greet= "helloworld"</code>, we are creating an instance of a string object <span>with</span><a id="id326635046" class="indexterm"></a> the value <code class="literal">"hello world"</code> and the identity of <code class="literal">greet</code>. The identity of an object acts as a <span>pointer</span><a id="id326637561" class="indexterm"></a> to the object's location in memory. The <span>type</span><a id="id326637568" class="indexterm"></a> of an object, also known as the object's class, describes the object's internal representation, as well as the methods and operations it supports. Once an instance of an object is created, its identity and type cannot be changed.</p><p>We can get the identity of an object by using the built-in function <code class="literal"><span>id()</span></code>. This returns an identifying integer and on most systems, this refers to its memory location, although you should not rely on this in any of your code.</p><p>Also, there are a number of ways to compare objects; for example, see the following:</p><pre class="programlisting">if a==b:    # a and b have the same value

if a is b:    # if a and b are the same object

if type(a) is type(b):   #a and b are the same type</pre><p> </p><p> </p><p>An important distinction <span>needs</span><a id="id326637600" class="indexterm"></a> to be made between <span class="strong"><strong>mutable</strong></span> and <span class="strong"><strong>immutable</strong></span> objects. Mutable objects such as lists can have their values changed. They have methods, such as <code class="literal">insert()</code> or <code class="literal">append()</code>, that change an object's value. Immutable objects such as strings <span>cannot</span><a id="id326637755" class="indexterm"></a> have their values changed, so when we run their methods, they simply return a value rather than change the value of an underlying object. We can, of course, use this value by assigning it to a variable or using it as an argument in a function. For example, the <code class="literal">int</code> class is immutable—once an instance of it is created, its value cannot be changed<span>, however,</span> an identifier referencing this object can be reassigned another value.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec8"></a>Strings</h3></div></div></div><p>Strings are immutable sequence objects, with <span>each</span><a id="id325846840" class="indexterm"></a> character representing an element in the sequence. As with all objects, we use methods to perform operations. Strings, being immutable, do not change the instance; each method simply returns a value. This value can be stored as another variable or given as an argument to a function or method.</p><p> </p><p>Th<span>e following table is a list of some of the</span> most commonly used <span>string</span><a id="id325846858" class="indexterm"></a> methods and their descriptions:</p><p> </p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Method</p></td><td style="border-bottom: 0.5pt solid ; "><p>Description</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">s.capitalize</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Returns a string with only the first character capitalized, the rest remaining lowercase.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">s.count(substring,[start,end])</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Counts occurrences of a substring.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">s.expandtabs([tabsize])</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Replaces tabs with spaces.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">s.endswith(substring,[start, end]</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Returns <code class="literal">True</code> if a string ends with a specified substring.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">s.find(substring,[start,end])</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Returns index of first presence of a substring.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">s.isalnum()</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Returns <code class="literal">True</code> if all chars are alphanumeric of string <code class="literal">s</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">s.isalpha()</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Returns <code class="literal">True</code> if all chars are alphabetic of string <code class="literal">s</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">s.isdigit()</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Returns <code class="literal">True</code> if all chars are digits in the string.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">s.split([separator],[maxsplit])</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Splits a string separated by whitespace or an optional separator. Returns a list.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">s.join(t)</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Joins the strings in sequence <code class="literal">t</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">s.lower()</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Converts the string to all lowercase.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">s.replace(old, new[maxreplace])</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Replaces old substring with a new substring.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">s.startswith(substring, [start, end]])</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Returns <code class="literal">True</code> if the string starts with a specified substring.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">s.swapcase()</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Returns a copy of the string with swapped case in the string.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">s.strip([characters])</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Removes whitespace or optional characters.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">s.lstrip([characters])</code></p></td><td style=""><p>Returns a copy of the string with leading characters removed.</p></td></tr></tbody></table></div><p> </p><p>Strings, like all sequence types, support indexing and slicing. We can retrieve any character from a string by using its <span>index</span><code class="literal">s[i]</code>. We can retrieve a slice of a string by using <code class="literal">s[i:j]</code>, where <code class="literal">i</code> and <code class="literal">j</code> are the start and end points of the slice. We can return an extended slice by using a stride, as in the following—<code class="literal">s[i:j:stride]</code>. The following code should make this clear:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/3b820464-a413-4163-9867-1ed68c53845c.png" /></div><p>The first two examples are pretty straightforward, returning the character located at index <code class="literal"><span>1</span></code> and the first seven characters of the string, respectively. Notice that indexing begins at <code class="literal">0</code>. In the third example, we are using a stride of <code class="literal">2</code>. This results in every <span>second</span><a id="id325921139" class="indexterm"></a> character being returned. In the final example, we omit the end index and the slice returns every second character in the entire string.</p><p>You can use any expression, variable, or operator as an index as long as the value is an integer:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/b1a56d25-cf81-4299-9737-a314284f55d2.png" /></div><p>Another common operation is traversing through a string with a loop:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/0605840e-194b-4b05-baeb-75cc89e91919.png" /></div><p>Given that strings are immutable, a common question that arises is how we perform operations such as inserting values. Rather than changing a string, we need to think of ways to build new string objects for the results we need. For example, if we wanted to insert a word into our greeting, we could assign a variable to the following:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/eaf74d40-70f5-4c60-a6a6-9a88544842d6.png" /></div><p>As this code shows, we use the slice operator to split the string at index position <code class="literal">5</code> and use <code class="literal">+</code> to concatenate. Python never interprets the contents of a string as a number. If we need to perform mathematical operations on a string, we need to first convert them to a numeric type:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/97cdac93-8f73-4e23-954b-f2935aa76913.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec9"></a>Lists</h3></div></div></div><p>List is one of the most commonly used <span>built-in data structures</span>, as they can store any number of different data types. They are simple representations of objects and are indexed by <span>integers</span><a id="id325963404" class="indexterm"></a> starting from zero, as we saw in the case of <span class="emphasis"><em>strings. </em></span></p><p>The following table contains the most commonly used <span>list</span><a id="id325963417" class="indexterm"></a> methods and their descriptions:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong><span>Method</span></strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Description</strong></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">list(s)</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Returns a list of sequence <code class="literal"><span>s.</span></code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">s.append(x)</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Appends element <code class="literal">x</code> at the end of list <code class="literal">s</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">s.extend(x)</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Appends list <code class="literal">x</code> at the end of list <code class="literal">s</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">s.count(x)</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Returns the count of the occurrence of <code class="literal">x</code> in list <code class="literal">s</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">s.index(x,[start],[stop])</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Returns the smallest index <code class="literal">i</code>, where <code class="literal">s[i]==x</code>. We can include an optional start and stop index for the lookup.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">s.insert(i,e)</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Inserts <code class="literal">x</code> at index <code class="literal">i</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">s.pop(i)</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Returns the element <code class="literal">i</code> and removes it from the list <code class="literal">s</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">s.remove(x)</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Removes element <code class="literal">x</code> from the list <code class="literal">s</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">s.reverse()</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Reverses the order of list <code class="literal">s</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">s.sort(key,[reverse])</code></p></td><td style=""><p>Sorts list <code class="literal">s</code> with optional key and reverses it.</p></td></tr></tbody></table></div><p> </p><p>In Python, lists implementation is different when compared to other languages. Python does not create multiple copies of a variable. For example, when we assign a value of one variable in another variable, both variables point to the same memory address where the value is stored. A copy would only be allocated if the variables change their values. This feature makes Python memory efficient, in the sense that it only creates multiple copies when it is required.  </p><p>This has important consequences for mutable compound objects such as lists. Consider the following code:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/d7aea6c9-92dc-4c5f-b4a7-d986d87e40a4.png" /></div><p>In the preceding code, both the <code class="literal">list1</code> and <code class="literal">list2</code><span> </span> variables are pointing to the same memory location. However, when we change the <code class="literal">y</code> through <code class="literal">list2</code> to <code class="literal">4</code>, we are actually changing the same <code class="literal">y</code> variable that <code class="literal">list1</code> is pointing to as well.</p><p>An important feature of <code class="literal">list</code> is that it can contain nested structures; that is, list can contain other lists. For example, in the following code, list <code class="literal">items</code> contains three other lists:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/2b5a796f-ef73-419d-879b-fa3e21a253fd.png" /></div><p>We can access the values of the list using the bracket operators and, since lists are mutable, they are copied in place. The following example demonstrates how we can use this to update elements; for example, here we are raising the price of flour by 20 percent:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/fa937984-0741-4942-ae81-d94ed400e309.png" /></div><p>We can create a list from expressions <span>using</span><a id="id325974940" class="indexterm"></a> a very common and intuitive method; that is, <span class="strong"><strong>list comprehensions.</strong></span> It allows us to create a list through an expression directly into the list. Consider the following example, where a list <code class="literal">l</code> is created using this expression:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/09e01c7c-293a-4a6e-bd83-c508ff96c6f6.png" /></div><p>List comprehensions can be quite flexible; for example, consider the following code. It essentially shows two different ways to performs a function composition, where we apply one function (<code class="literal">x*4</code>) to another (<code class="literal">x*2</code>). The following code prints out two lists representing the function composition of <code class="literal">f1</code> and <code class="literal">f2</code>, calculated first using a for loop and then using a list comprehension:</p><pre class="programlisting">def f1(x): return x*2 
def f2(x): return x*4

lst=[]
for i in range(16):
   lst.append(f1(f2(i)))

print(lst)
print([f1(x) for x in range(64) if x in [f2(j) for j in range(16)]])

</pre><p>The first line of output is from the for loop construct. The second is from the list comprehension expression:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/3093d2e5-5604-4f65-b139-b7fc64c19f61.png" /></div><p>List comprehensions can also be used to replicate the action of nested loops in a more compact form. For example, we multiply each of the elements contained within <code class="literal">list1</code> with each other:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/11450a5e-c45d-4037-85b6-6cd6114dfc95.png" /></div><p>We can also use list comprehensions with other objects such as strings, to build more complex structures. For example, the following code creates a list of words and their letter count:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/d19dc71f-38cc-42e3-8906-86844453c17b.png" /></div><p>As we will see, lists form the foundation of many of the data structures we will look at. Their versatility, ease of creation, and use enable them to build more specialized and complex data structures.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec0"></a>Functions as first class objects</h4></div></div></div><p>In Python, it is not only <span>data</span><a id="id325975305" class="indexterm"></a> types that are treated as objects. Both functions and classes are what are known as <span>first class objects</span>, allowing them to be manipulated in the same ways as built-in data types. By definition, first class objects are the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Created at runtime</li><li style="list-style-type: disc">Assigned as a variable or in a data structure</li><li style="list-style-type: disc">Passed as an argument to a function</li><li style="list-style-type: disc">Returned as the result of a function</li></ul></div><p>In Python, the term <span class="strong"><strong>first class object</strong></span> is a bit of a misnomer, since it implies some sort of hierarchy, whereas all Python <span>objects</span><a id="id325993497" class="indexterm"></a> are essentially first class.</p><p>To have a look at how this works, let's define a simple function:</p><pre class="programlisting">def greeting(language): 
   if language=='eng': 
        return 'hello world'
      if language =='fr'
        return 'Bonjour le monde'
      else: return  'language not supported'

</pre><p>Since user-defined functions are objects, we can do things such as include them in other objects, such as lists:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/d4a932ed-c174-4043-860b-79f6404547ec.png" /></div><p>Functions can also be used as <span>arguments</span><a id="id325993525" class="indexterm"></a> for other functions. For example, we can define the following function:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/ee2e7c73-7ee6-4f90-9787-da2ea1504fb0.png" /></div><p>Here, <code class="literal">callf()</code> takes a function as an argument, sets a language variable to <code class="literal">'eng'</code>, and then calls the function with the language variable as its argument. We could see how this would be useful if, for example, we wanted to produce a program that returns specific sentences in a variety of languages, perhaps for some sort of natural language application. Here, we have a central place to set the language. As well as our greeting function, we could create similar functions that return different sentences. By having one point where we set the language, the rest of the program logic does not have to worry about this. If we want to change the language, we simply change the language variable and we can keep everything else the same.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec10"></a>Higher order functions</h3></div></div></div><p>Functions that take other <span>functions</span><a id="id326005164" class="indexterm"></a> as arguments, or that return functions, are called <span class="strong"><strong>higher order functions</strong></span>. Python 3 contains two built-in higher order functions—<code class="literal">filter()</code> and <code class="literal">map().</code> Note that in earlier versions of Python, these functions returned lists; in Python 3, they return an iterator, <span>making</span><a id="id326005182" class="indexterm"></a> them much more efficient. The <code class="literal">map()</code> function provides an easy way to transform each item into an iterable object. For example, here is an efficient, compact way to perform an operation on a sequence. Note the use of the <code class="literal">lambda</code> anonymous function:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/c03f1394-7b56-4692-af7b-8118d065701a.png" /></div><p>Similarly, we can use the filter built-in function to filter items in a list:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/0e3e275e-1a6f-4482-8067-ab05194ab0c5.png" /></div><p>Note that both map and filter perform the same <span>function</span><a id="id326013892" class="indexterm"></a> similar to what <span>can be achieved by</span><span>list</span><a id="id326013905" class="indexterm"></a> comprehensions. There does not seem to be a great deal of difference in the performance characteristics, apart from a slight performance advantage when using the <span>in-built</span> functions map and filter without the <code class="literal">lambda</code> operator, compared to list comprehensions. Despite this, most style guides recommend the use of list comprehensions over built-in functions, possibly because they tend to be easier to read.</p><p>Creating our own higher order functions is one of the hallmarks of functional programming style. A practical example of how higher order functions can be useful is demonstrated by the following. Here, we are passing the <code class="literal">len</code> function as the key to the sort function. This way, we can sort a list of words by length:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/9e4a6ab9-fb54-425a-a3e9-154df92f9082.png" /></div><p>Here is another example for case-insensitive sorting:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/1598db3d-ebf6-4082-8261-61c78797a88e.png" /></div><p>Note the difference between the <code class="literal">list.sort()</code> method and the sorted built-in function. The <code class="literal">list.sort()</code> method, a method of the list object, sorts the existing instance of a <span>list</span><a id="id326028667" class="indexterm"></a> without copying it. This method changes the target object and returns <code class="literal">None</code>. It is an important convention in Python that functions or methods that <span>change</span><a id="id326028679" class="indexterm"></a> the object return <code class="literal">None</code>, to make it clear that no new object was created and that the object itself was changed.</p><p>On the other hand, the sorted built-in function returns a new list. It actually accepts any iterable object as an argument, but it will always return a list. Both <span class="emphasis"><em>list sort</em></span> and <span class="emphasis"><em>sorted</em></span> take two optional keyword arguments as key.</p><p>A simple way to sort more complex structures is to use the index of the element to sort, using the lambda operator, for example:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/6fbcf13c-1a52-40e2-acae-fd8d0b67260a.png" /></div><p>Here we have sorted the items by price.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec11"></a>Recursive functions</h3></div></div></div><p>Recursion is one of the most <span>fundamental</span><a id="id326028717" class="indexterm"></a> concepts of computer science. It is called <span class="emphasis"><em>recursion</em></span> when a function <span>takes</span><a id="id326028729" class="indexterm"></a> one or more calls to itself during execution. Loop iterations and recursion are different in the sense that <span class="emphasis"><em>loops</em></span> execute statements repeatedly through a Boolean condition or through a series of elements, whereas recursion repeatedly calls a function. In Python, we can implement a recursive function simply by calling it within its own function body. To stop a recursive function turning into an infinite loop, we need at least one argument that tests for a terminating case to end the recursion. This is sometimes called the base case. <span>It should be pointed out that recursion is different from iteration. Although both involve repetition, iteration loops through a sequence of operations, whereas recursion repeatedly calls a function.</span> Technically, recursion is a special case of iteration known as tail iteration, and it is usually always possible to convert an iterative function to a recursive function and vice versa. The interesting thing about recursive functions is that they are able to describe an infinite object within a finite statement.</p><p>The following code should demonstrate the <span>difference</span><a id="id326034450" class="indexterm"></a> between recursion and iteration. Both these <span>functions</span><a id="id326034458" class="indexterm"></a> simply print out numbers between low and high, the first one using iteration and the second using recursion:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/de617a2c-847e-4535-8208-49485e42ca93.png" /></div><p>Notice that for <code class="literal">iterTest</code>, the iteration example, we use a while statement to test for the condition, then call the print method, and finally increment the low value. The recursive example tests for the condition, prints, then calls itself, incrementing the low variable in its argument. In general, iteration is more efficient; however, recursive functions are often easier to understand and write. Recursive functions are also useful for manipulating recursive data structures such as linked lists and trees, as we will see.</p><p> </p><p> </p></div></div>