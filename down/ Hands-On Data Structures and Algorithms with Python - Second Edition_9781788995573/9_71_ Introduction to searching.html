<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec71"></a>Introduction to searching</h2></div></div><hr /></div><p>Searching algorithms are <span>categorized</span><a id="id326637524" class="indexterm"></a> into two broad types:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">The searching algorithm is applied to the list of items that are already sorted; that is, applied to the ordered set of items</li><li style="list-style-type: disc">The searching algorithm is applied to the unordered set of items, which are not sorted</li></ul></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec63"></a>Linear search</h3></div></div></div><p>The <span class="emphasis"><em>searching</em></span> operation is to find <span>out</span><a id="id325851498" class="indexterm"></a> a given item from the stored data. If the <span>searched</span><a id="id325851507" class="indexterm"></a> item is available in the stored list then it returns the index position where it is located, or else it returns that the item is not found. The simplest approach to search for an item in a list is the linear search method, in which we look for items one by one in the whole list.</p><p>Let's take an example of <code class="literal">5</code> list items <code class="literal">{60, 1, 88, 10, 11, 100}</code> to understand the linear search algorithm, as shown in the following diagram:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/b29209b8-631b-4422-8190-13381ddc1356.png" /></div><p>The preceding list has elements that are accessible through the list index. To find an element in the list, we employ the linear searching technique. This technique traverses the list of elements by using the index to move from the beginning of the list to the end. Each element is examined, and if it does not match the search item, the next item is examined. By hopping from one item to the next, the list is traversed sequentially.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note10"></a>Note</h3><p>We use list items with integer values in this chapter to help you understand the concept, since integers can be compared easily; however, a list item can hold any other data type as well.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec64"></a>Unordered linear search</h3></div></div></div><p>The linear search approach <span>depends</span><a id="id325855507" class="indexterm"></a> on how the list items are stored—whether they are <span>sorted</span><a id="id325855515" class="indexterm"></a> in order or stored without any order. Let's first see if a list has items that are not sorted.</p><p> </p><p>Consider an example list that <span>contains</span><a id="id325855561" class="indexterm"></a> elements 60, 1, 88, 10, and 100—an <span>unordered</span><a id="id325855568" class="indexterm"></a> list. The items in the list have no order by magnitude. To perform a search operation on such a list, one proceeds from the very first item and compares that with the search item. If the search item is not matched then the next element in the list is examined. This continues till we reach the last element in the list or until a match is found.</p><p>Here is the implementation in Python for the linear search on an unordered list of items:</p><pre class="programlisting">    def search(unordered_list, term): 
       unordered_list_size = len(unordered_list) 
        for i in range(unordered_list_size): 
            if term == unordered_list[i]: 
                return i 

        return None </pre><p>The <code class="literal">search</code> function takes two parameters; the first is the list that holds our data, and the second parameter is the item that we are looking for, called the <span class="strong"><strong>search term</strong></span>.</p><p>The size of the array is obtained and determines the number of times the <code class="literal">for</code> loop is executed. The following code depicts this:</p><pre class="programlisting">        if term == unordered_list[i]: 
            ... </pre><p>On every pass of the <code class="literal">for</code> loop, we test if the search term is equal to the indexed item. If this is true, then there is a match, and there is no need to proceed further with the search. We return the index position where the searched item is found in the list.</p><p>If the loops run to the end of the list with no match found, then <code class="literal">None</code> is returned to signify that there is no such item in the list.</p><p>In an unordered list of items, there is no guiding rule for how elements are inserted. Thus, it impacts the way the search is performed. As such, we must visit all the items in the list one after the other. As can be seen in the following diagram, the search for the term <span class="strong"><strong>66</strong></span> starts from the first element and moves to the next element in the list.</p><p> </p><p> </p><p>Thus, the first <span class="strong"><strong>60</strong></span> is compared with <span class="strong"><strong>66</strong></span>, and if it is not equal, we compare <span class="strong"><strong>66</strong></span> with the next element <span class="strong"><strong>1</strong></span>, then <span class="strong"><strong>88</strong></span>, and so on till we find the search term in the list:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/a910accf-56da-4f70-8f39-73280d12586d.png" /></div><p>The unordered linear search has a worst-case running time of <code class="literal">O(n)</code>. All the elements may need to be visited before finding the search term. The worst-case scenario will be when the search term is located at the last position of the list.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec65"></a>Ordered linear search</h3></div></div></div><p>Another case in a <span>linear</span><a id="id325896261" class="indexterm"></a> search is when the list elements have been sorted; then our <span>search</span><a id="id325896269" class="indexterm"></a> algorithm can be improved. Assuming the elements have been sorted in ascending order, the search operation can take advantage of the ordered nature of the list to make the search more efficient.</p><p>The algorithm is reduced to the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Move through the list sequentially</li><li>If a search item is greater than the object or item currently under inspection in the loop, then quit and return <code class="literal">None</code></li></ol></div><p>In the process of iterating through the list, if the search term is greater than the current item, then there is no need to continue with the search.</p><p>Let's consider an example to see how this works. We take a list of items, as <span>shown</span><a id="id325896315" class="indexterm"></a> in the following diagram, and we want to <span>search</span><a id="id325896324" class="indexterm"></a> term <code class="literal">5</code>:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/ae168b3f-c223-4267-862e-bab0b6726938.png" /></div><p>When the search operation starts and the first element is compared with the search term (<span class="strong"><strong>5</strong></span>), no match is found. However, there are more elements in the list so the search operation moves on to examine the next element. A more compelling reason to move on in the sorted list is that we know the search item may match any of the elements greater than <span class="strong"><strong>2</strong></span>.</p><p>After the fourth comparison, we come to the conclusion that the search term cannot be found in any position later in the list where <span class="strong"><strong>6</strong></span> is located. In other words, if the current item is greater than the search term, then it means there is no need to further search the list.</p><p>Here is the implementation of the linear search when the list is already sorted:</p><pre class="programlisting">    def search(ordered_list, term): 
        ordered_list_size = len(ordered_list) 
        for i in range(ordered_list_size): 
            if term == ordered_list[i]: 
                return i 
            elif ordered_list[i] &gt; term: 
                return None 

        return None </pre><p>In the preceding code, the <code class="literal">if</code> statement now caters for checking if the search item is found in the list or not. <code class="literal">elif</code> tests the condition where <code class="literal">ordered_list[i] &gt; term</code>. The method returns <code class="literal">None</code> if the comparison evaluates to <code class="literal">True</code>.</p><p>The last line in the method returns <code class="literal">None</code> because the loop may go through the list and still the search item is not matched in the list.</p><p>The worst-case time complexity of an ordered linear search is <code class="literal">O(n)</code>. In general, this kind of search is considered inefficient especially when dealing with large datasets.</p></div></div>