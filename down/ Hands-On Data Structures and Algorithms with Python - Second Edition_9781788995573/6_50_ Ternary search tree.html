<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec53"></a>Ternary search tree</h2></div></div><hr /></div><p>A ternary tree is a data structure where each node of the tree can contain up to <code class="literal">3</code> children. It is <span>different</span><a id="id326346242" class="indexterm"></a> compared to the binary search tree in the sense that a node in a binary tree can have a maximum of <code class="literal">2</code> children, whereas a node in the ternary tree can have a maximum of <code class="literal">3</code> children. The ternary tree data structure is also considered a special case of the trie data structure. In trie data structure, each node contains 26 pointers to its children when we use trie data structure to store strings in contrast to the ternary search tree data structure, where we have 3 pointers to its children.</p><p>The ternary search tree can be represented as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Each node stores a character in it</li><li style="list-style-type: disc">It has the equal pointer that points to a node that stores a value equal to the current node</li><li style="list-style-type: disc">It has the left pointer that points to a node that stores a value smaller than the current node</li><li style="list-style-type: disc">It has the right pointer that points to a node that stores a value greater than the current node</li><li style="list-style-type: disc">Each node has a flag variable that keeps track of whether that node is the end of a string or not</li></ul></div><p>To better understand the ternary search tree data structure, we will demonstrate it through an example where we insert the strings <span class="strong"><strong>PUT</strong></span>, <span class="strong"><strong>CAT</strong></span>, <span class="strong"><strong>SIT</strong></span>, <span class="strong"><strong>SING</strong></span>, and <span class="strong"><strong>PUSH</strong></span> to an empty ternary tree, as shown in the following diagram:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/f6629b2b-3a1b-4d97-b1c0-d5bef25c4c5c.png" /></div><p>Inserting a value into a ternary search tree is quite similar to how we do it in a binary search tree. In the ternary search tree, we follow these steps to insert a string in the ternary search tree:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Since the tree is empty initially, we start by creating the root node with the first character, <span class="strong"><strong>P</strong></span>, and then we create another node for the character <span class="strong"><strong>U</strong></span>, and finally the character <span class="strong"><strong>T</strong></span>.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Next, we wish to add the word <span class="strong"><strong>CAT</strong></span>. First, we compare the first character <span class="strong"><strong>C</strong></span> with the root node character, <span class="strong"><strong>P</strong></span>. Since it does not match, and it is smaller than the root node, we create a new node for the character <span class="strong"><strong>C</strong></span> on the left-hand side of the root node. Furthermore, we create the nodes for characters <span class="strong"><strong>A</strong></span> and <span class="strong"><strong>T</strong></span>.</li><li>Next, we add a new word, <span class="strong"><strong>SIT</strong></span>. First, we compare the first character, <span class="strong"><strong>S</strong></span>, with the root node character, <span class="strong"><strong>P</strong></span>. Since it does not match, and character <span class="strong"><strong>S</strong></span> is greater than character <span class="strong"><strong>P</strong></span>, we create a new node on the right-hand side for the character <span class="strong"><strong>S</strong></span>. Furthermore, we create nodes for characters <span class="strong"><strong>I</strong></span> and <span class="strong"><strong>T</strong></span>.</li><li>Next, we insert a new word, <span class="strong"><strong>SING</strong></span>, into the <span>ternary</span><a id="id325895164" class="indexterm"></a> search tree. We start by comparing the first character, <span class="strong"><strong>S</strong></span>, to the root node. Since it does not match, and the character <span class="strong"><strong>S</strong></span> is greater than the root node <span class="strong"><strong>P</strong></span>, we look at the next character to the right-hand side, that is, <span class="strong"><strong>S</strong></span>. Here, the character matches, so we compare the next character, which is <span class="strong"><strong>I</strong></span>; this also matches. Next, we compare the character <span class="strong"><strong>N</strong></span>, to the character <span class="strong"><strong>T</strong></span> in the tree. Here, the characters do not match, so we move to the left-hand side of node <span class="strong"><strong>T</strong></span>. Here, we create a new node for the character <span class="strong"><strong>N</strong></span>. Furthermore, we create another new node for the character <span class="strong"><strong>G</strong></span>.</li><li>Then, we add a new node, <span class="strong"><strong>PUSH</strong></span>, in the ternary search tree. First, we compare the first character of the word, that is, <span class="strong"><strong>P</strong></span>, to the root node. Since it matches, we look at the next character in the <span>ternary</span><a id="id325898537" class="indexterm"></a> tree. Here, the character <span class="strong"><strong>U</strong></span> also matches with the next character of the word. So, we look at the next character of the word, that is, <span class="strong"><strong>S</strong></span>. It doesn't match with the next character in the tree, which is <span class="strong"><strong>T</strong></span>. Therefore, we create a new node for the character <span class="strong"><strong>S</strong></span> to the left-hand side of node <span class="strong"><strong>T</strong></span> since character <span class="strong"><strong>S</strong></span> is smaller than <span class="strong"><strong>T</strong></span>. Next, we create another node for the next character, <span class="strong"><strong>H</strong></span>.</li></ol></div><p>Take note that each node in the ternary tree keeps track of which node is the leaf node or non-leaf node via the use of a flag variable. </p><p>Ternary search trees are very efficient for strings searching for related applications such as when we wish to search all of the strings that start with a given prefix, or when we wish to search for a phone number that starts with given specific numbers, spell checks, and so on.</p><p> </p><p> </p></div>