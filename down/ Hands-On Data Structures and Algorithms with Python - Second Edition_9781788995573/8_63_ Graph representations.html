<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec64"></a>Graph representations</h2></div></div><hr /></div><p>Graphs can be represented with <span>two</span><a id="id325644845" class="indexterm"></a> main forms while implementing them in Python. One way is to use an adjacency list, and the other is to use an adjacency matrix. Let's consider an example, shown in the following diagram, to develop both types of representation for graphs:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/2b193e21-f31b-443a-a99d-c6dd1c3715bd.png" /></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec56"></a>Adjacency lists</h3></div></div></div><p>An adjacency list stores <span>all</span><a id="id326439115" class="indexterm"></a> the nodes, along with other <span>nodes</span><a id="id326439102" class="indexterm"></a> that are directly connected to them in the graph. Two nodes, <code class="literal">A</code> and <code class="literal">B</code>, in a graph <code class="literal">G</code>, are said to be adjacent if there is a direct connection between them. A <code class="literal">list</code> data structure in Python is used to represent a graph. The <code class="literal">indices</code> of the list can be used to represent the nodes or vertices in the graph.</p><p> </p><p>At each index, the adjacent <span>nodes</span><a id="id325990020" class="indexterm"></a> to that vertex are stored. For example, <span>consider</span><a id="id326439112" class="indexterm"></a> the following adjacency list corresponding to the sample graph shown previously:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/edcc2f71-d1d2-4152-80ad-376f1b3971f1.png" /></div><p>The numbers in the box represent the vertices. The <code class="literal">0</code> index represents the <code class="literal">A</code> vertex of the graph, with its adjacent nodes being <code class="literal">B</code> and <code class="literal">C</code>. The <code class="literal">1</code> index represents the <code class="literal">B</code>vertex of the graph, with its adjacent nodes of <code class="literal">E</code>, <code class="literal">C</code>, and <code class="literal">A</code>. Similarly, the other vertices, <code class="literal">C</code>, <code class="literal">E</code>, and <code class="literal">F</code>, of the graph are represented at the indices of <code class="literal">2</code>, <code class="literal">3</code>, and <code class="literal">4</code> with their adjacent nodes, as shown in the previous diagram. </p><p>Using a <code class="literal">list</code> for the representation is quite restrictive, because we lack the ability to directly use the vertex labels. Therefore, a <code class="literal">dictionary</code> data structure is more suitable to represent the graph. To implement the same preceding graph using a dictionary data structure, we can use the following statements:</p><pre class="programlisting">    graph = dict() 
    graph['A'] = ['B', 'C'] 
    graph['B'] = ['E','C', 'A'] 
    graph['C'] = ['A', 'B', 'E','F'] 
    graph['E'] = ['B', 'C'] 
    graph['F'] = ['C'] </pre><p>Now we can easily establish that the <span class="strong"><strong>A</strong></span>vertex has the adjacent vertices of <span class="strong"><strong>B</strong></span>and<span class="strong"><strong>C</strong></span>. The <span class="strong"><strong>F</strong></span> vertex has the <span class="strong"><strong>C</strong></span> vertex as its only neighbor. Similarly, the <span class="strong"><strong>B</strong></span> vertex has adjacent vertices of <span class="strong"><strong>E</strong></span>,<span class="strong"><strong>B</strong></span>, and<span class="strong"><strong>A</strong></span>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec57"></a>Adjacency matrices</h3></div></div></div><p>Another approach by which a <span>graph</span><a id="id326438818" class="indexterm"></a> can be represented is by using an <span>adjacency</span><a id="id326438826" class="indexterm"></a> matrix. A matrix is a two-dimensional array. The idea here is to represent the cells with a <code class="literal">1</code> or <code class="literal">0</code>, depending on whether two vertices are connected by an edge or not. We demonstrate an example graph, along with its corresponding adjacency matrix, in the following diagram:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/80e4c637-2cd8-41b2-be6a-69423d5ef475.png" /></div><p>An adjacency matrix can be implemented using the <span>given</span> an adjacency list. To implement the adjacency matrix, let's take the previous dictionary-based implementation of the graph. Firstly, we have to obtain the key elements of the adjacency matrix. It is <span>important</span> to note that these matrix elements are the vertices of the graph. We can get the key elements by sorting the keys of the graph. The code snippet for this is as follows:</p><pre class="programlisting">    matrix_elements = sorted(graph.keys()) 
    cols = rows = len(matrix_elements) </pre><p>Next, the length of the keys of the graph is used to provide the dimensions of the adjacency matrix, which are stored in <code class="literal">cols</code> and <code class="literal">rows</code>, and the values in the <code class="literal">cols</code> and <code class="literal">rows</code> are equal. We then create an empty adjacency matrix of the right size for the number of <code class="literal">cols</code> by <code class="literal">rows</code>, filling it with zeros. The <code class="literal">edges_list</code> variable will store the tuples that form the edges in the graph. For example, an edge between the A and B nodes will be stored as <code class="literal">(A, B)</code>. The code snippet to initialize an empty adjacency matrix is as follows:</p><pre class="programlisting">    adjacency_matrix = [[0 for x in range(rows)] for y in range(cols)] 
    edges_list = []</pre><p> </p><p> </p><p> </p><p> </p><p>The multidimensional array is filled using a nested <code class="literal">for</code> loop:</p><pre class="programlisting">    for key in matrix_elements: 
        for neighbor in graph[key]: 
            edges_list.append((key, neighbor)) </pre><p>The neighbors of a vertex are obtained by <code class="literal">graph[key]</code>. The key, in combination with the <code class="literal">neighbor</code>, is then used to create the tuple stored in <code class="literal">edges_list</code>.</p><p>The output of the preceding Python code for storing the edges of the graph is as follows:</p><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; [('A', 'B'), ('A', 'C'), ('B', 'E'), ('B', 'C'), ('B', 'A'), ('C', 'A'), </strong></span>
<span class="strong"><strong>     ('C', 'B'), ('C', 'E'), ('C', 'F'), ('E', 'B'), ('E', 'C'), </strong></span>
<span class="strong"><strong>     ('F', 'C')]</strong></span></pre><p>The next step in implementing the <span>adjacency</span><a id="id326439504" class="indexterm"></a> matrix is to fill it, using <code class="literal">1</code> to denote the presence of an <span>edge</span><a id="id326439513" class="indexterm"></a> in the graph. This can be done with the <code class="literal">adjacency_matrix[index_of_first_vertex][index_of_second_vertex] = 1</code> statement. The full code snippet that marks the presence of edges of the graph is as follows</p><pre class="programlisting">    for edge in edges_list: 
        index_of_first_vertex = matrix_elements.index(edge[0]) 
        index_of_second_vertex = matrix_elements.index(edge[1]) 
        adjacency_matrix[index_of_first_vertex][index_of_second_vertex] = 1 </pre><p>The <code class="literal">matrix_elements</code> array has its <code class="literal">rows</code> and <code class="literal">cols</code>, starting from <code class="literal">A</code> to all other vertices with indices of <code class="literal">0</code> to <code class="literal">5</code>. The <code class="literal">for</code> loop iterates through our list of tuples and uses the <code class="literal">index</code> method to get the corresponding index where an edge is to be stored.</p><p>The output of the preceding code is the adjacency matrix for the sample graph shown previously. The adjacency matrix produced looks like the following:</p><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt;</strong></span>
<span class="strong"><strong>[0, 1, 1, 0, 0]</strong></span>
<span class="strong"><strong>[1, 0, 0, 1, 0]</strong></span>
<span class="strong"><strong>[1, 1, 0, 1, 1]</strong></span>
<span class="strong"><strong>[0, 1, 1, 0, 0]</strong></span>
<span class="strong"><strong>[0, 0, 1, 0, 0]</strong></span></pre><p>At row <code class="literal">1</code> and column <code class="literal">1</code>, the <code class="literal">0</code> represents <span>the</span><a id="id326440065" class="indexterm"></a> absence of an edge between A and A. Similarly, at column <code class="literal">2</code> and row <code class="literal">3</code>, there is a value of <code class="literal">1</code> that denotes the edge between the C and B vertices in the graph.</p><p> </p><p> </p></div></div>