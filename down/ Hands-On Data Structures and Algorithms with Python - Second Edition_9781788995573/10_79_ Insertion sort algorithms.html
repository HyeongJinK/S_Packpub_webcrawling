<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch10lvl1sec78"></a>Insertion sort algorithms</h2></div></div><hr /></div><p>The idea of <span>swapping</span><a id="id325851504" class="indexterm"></a> adjacent elements to sort a <span>list</span><a id="id325851492" class="indexterm"></a> of items can also be used to implement the insertion sort. An insertion sorting algorithm maintains a sub-list that is always sorted, while the other portion of the list remains unsorted. We take elements from the unsorted sub-list and insert them in the correct position in the sorted sub-list, in such a way that this sub-list remains sorted. </p><p>In insertion sorting, we start with one element, assuming it to be sorted, and then take another element from the unsorted sub-list and place it at the correct position (in relation to the first element) in the sorted sub-list. This means that our sorted sub-list now has two elements. Then, we again take another element from the unsorted sub-list, and place it in the correct position (in relation to the two already sorted elements) in the sorted sub-list. We repeatedly follow this process to insert all the elements one by one from the unsorted sub-list into the sorted sub-list. The shaded elements denote the ordered sub-lists, and in each iteration, an element from the unordered sub-list is inserted at the correct position in the sorted sub-list.</p><p>Let's consider an example to <span>understand</span><a id="id325851485" class="indexterm"></a> the working of the insertion <span>sorting</span><a id="id325845052" class="indexterm"></a> algorithm. In our example, we'll be sorting a list of <code class="literal">6</code> elements: <code class="literal">{45, 23, 87, 12, 32, 4}</code>. Firstly, we start with <code class="literal">1</code> element, assuming it to be sorted, then take the next element, <code class="literal">23</code>, from the unsorted sub-list and insert it at the correct position in the sorted sub-list. In the next iteration, we take the third element, <code class="literal">87</code>, from the unsorted sub-list, and again insert it into the sorted sub-list at the correct position. We follow the same process until all elements are in the sorted sub-list. This whole process is shown in the following diagram:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/4ac41fa2-9c7e-40ab-ad62-dbe1ad0d15fd.png" /></div><p> </p><p>To understand the implementation of the insertion sorting algorithm, let's take another example list of <code class="literal">5</code> elements, <code class="literal">{5, 1, 100, 2, 10}</code>, and examine the process with a detailed explanation.</p><p> Let's consider the following array:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/dbdfd3a7-9f41-4260-8982-f8b29fa7dc71.png" /></div><p>The algorithm starts <span>by</span><a id="id325644839" class="indexterm"></a> using a <code class="literal">for</code> loop to run between the <span class="strong"><strong>1</strong></span> and <span class="strong"><strong>4</strong></span> indices. We <span>start</span><a id="id325644857" class="indexterm"></a> from index <span class="strong"><strong>1</strong></span> because we assume the sub-array at index <span class="strong"><strong>0</strong></span> to already be in the correctly sorted order:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/1347512b-547f-446d-a083-66021fb4f959.png" /></div><p>At the start of the execution of the loop, we have the following:</p><pre class="programlisting">    for index in range(1, len(unsorted_list)): 
        search_index = index 
        insert_value = unsorted_list[index] </pre><p>At the beginning of the execution of each run of the <code class="literal">for</code> loop, the element at <code class="literal">unsorted_list[index]</code> is stored in the <code class="literal">insert_value</code> variable. Later, when we find the appropriate position in the sorted portion of the list, <code class="literal">insert_value</code> will be stored at that index or location:</p><pre class="programlisting">    for index in range(1, len(unsorted_list)): 
        search_index = index 
        insert_value = unsorted_list[index] 

        while search_index &gt; 0 and unsorted_list[search_index-1] &gt; 
              insert_value : 
            unsorted_list[search_index] = unsorted_list[search_index-1] 
            search_index -= 1 

        unsorted_list[search_index] = insert_value </pre><p>The <code class="literal">search_index</code> is used to provide information to the <code class="literal">while</code> loop; that is, exactly where to find the next element that needs to be inserted into the sorted sub-list.</p><p> </p><p>The <code class="literal">while</code> loop traverses the list backward, guided by <span>two</span><a id="id325837827" class="indexterm"></a> conditions: first, if <code class="literal">search_index &gt; 0</code>, then it means that there are more elements in the sorted portion of the list; second, for the <code class="literal">while</code> loop to run, <code class="literal">unsorted_list[search_index-1]</code> must be greater than the <code class="literal">insert_value</code> variable. The <code class="literal">unsorted_list[search_index-1]</code> array will do either of the following things:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Point to the element, just before the <code class="literal">unsorted_list[search_index]</code>, before the <code class="literal">while</code> loop is executed the first time</li><li style="list-style-type: disc">Point to one element before <code class="literal">unsorted_list[search_index-1]</code> after the <code class="literal">while</code> loop has been run the first time</li></ul></div><p>In our example list, the <code class="literal">while</code> loop will be executed because <span class="emphasis"><em>5 &gt; 1</em></span>. In the body of the while loop, the element at <code class="literal">unsorted_list[search_index-1]</code> is stored at <code class="literal">unsorted_list[search_index]</code>. <code class="literal">search_index -= 1</code> moves the list traversal backward until it holds a value of <code class="literal">0</code>.</p><p>Our list now looks <span>like</span><a id="id325989367" class="indexterm"></a> the following:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/6b83999d-d76e-4aed-9444-d755ea7b990f.png" /></div><p>After the <code class="literal">while</code> loop exits, the last known position of <code class="literal">search_index</code> (which, in this case, is <code class="literal">0</code>) now helps us to know where to insert <code class="literal">insert_value</code>:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/ee79348f-d748-48f5-a9a6-8a2f50ecdfd7.png" /></div><p>On the second iteration of the <code class="literal">for</code> loop, <code class="literal">search_index</code> will have a value of <span class="strong"><strong>2</strong></span>, which is the index of the third element in the array. At this point, we start our comparison in the leftward direction (toward index <span class="strong"><strong>0</strong></span>). <span class="strong"><strong>100</strong></span> will be compared with <span class="strong"><strong>5</strong></span>, but because <span class="strong"><strong>100</strong></span> is greater than <span class="strong"><strong>5</strong></span>, the <code class="literal">while</code> loop will not be executed. <span class="strong"><strong>100</strong></span> will be replaced by itself, because the <code class="literal">search_index</code> variable never got decremented. As such, <code class="literal">unsorted_list[search_index] = insert_value</code> will have no effect.</p><p>When <code class="literal">search_index</code> is pointing at index <span class="strong"><strong>3</strong></span>, we compare <span class="strong"><strong>2</strong></span> with <span class="strong"><strong>100</strong></span>, and move <span class="strong"><strong>100</strong></span> to where <span class="strong"><strong>2</strong></span> is stored. We then compare <span class="strong"><strong>2</strong></span> with <span class="strong"><strong>5</strong></span> and move <span class="strong"><strong>5</strong></span> to where <span class="strong"><strong>100</strong></span> was initially stored. At this point, the <code class="literal">while</code> loop will break and <span class="strong"><strong>2</strong></span> will be stored in index <span class="strong"><strong>1</strong></span>. The array will be partially sorted with the values <code class="literal">[1, 2, 5, 100, 10]</code>.</p><p>The preceding step will occur one last time for the list to be sorted. </p><p>The insertion sorting algorithm is <span>considered</span><a id="id326359021" class="indexterm"></a> stable, in the sense that it does not <span>change</span><a id="id326359030" class="indexterm"></a> the relative order of elements that have equal keys. It also only requires no more memory than that consumed by the list, because it does the swapping in-place.</p><p>Insertion sorting algorithm gives a worst-case runtime complexity of <span class="strong"><strong><code class="literal">O(n<sup>2</sup>)</code></strong></span>, and a best-case complexity <code class="literal">O(n)</code>.</p></div>