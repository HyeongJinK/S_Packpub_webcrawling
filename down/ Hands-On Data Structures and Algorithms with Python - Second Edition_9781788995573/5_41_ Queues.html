<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec45"></a>Queues</h2></div></div><hr /></div><p>Another special type of list is the <span>queue</span><a id="id326030617" class="indexterm"></a> data structure. The queue data structure is very similar to the regular queue you are accustomed to in real life. If you have stood in line at an airport or to be served your favorite burger at your neighborhood shop, then you should know how things work in a queue.</p><p>Queues are very fundamental and an important concept to grasp since many other data structures are built on them.</p><p> </p><p> </p><p>A <span>queue</span><a id="id326029709" class="indexterm"></a> works as follows. The first person to join the queue usually gets served first, and everyone will be served in the order of how they joined the queue. The acronym FIFO best explains the concept of a queue. <span class="strong"><strong>FIFO</strong></span> stands for <span class="strong"><strong>first in, first out</strong></span>. When people are standing in a queue waiting for their <span>turn</span><a id="id326029701" class="indexterm"></a> to be served, service is only rendered at the front of the queue. The only time people exit the queue is when they have been served, which only occurs at the very front of the queue. See the following diagram, where people are standing in the queue, and the person in the front would be served first:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/6a32956b-1431-44ff-91bd-e5846764eead.png" /></div><p>To join the queue, participants must stand behind the last person in the queue. This is the only legal or permitted way the queue accepts new entrants. The length of the queue does not matter. </p><p>We shall provide various implementations of a queue, but this will revolve around the same concept of FIFO. The item added first will be read first. We shall call the operation to add an element to the queue as <code class="literal">enqueue</code>. When we delete an element from the queue, we shall call this a <code class="literal">dequeue</code>operation. Whenever an element is enqueued, the length or size of the queue increments by 1. Conversely, dequeuing items reduces the number of elements in the queue by 1.</p><p>To demonstrate the two operations, the following table shows the effects of <span>adding</span><a id="id325578028" class="indexterm"></a> and removing elements from a queue:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Queue operation</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Size</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Contents</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Operation results</strong></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">Queue()</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">[]</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Queue object created, which is empty. </p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">Enqueue</code> Packt </p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">['Packt']</code></p></td><td style="border-bottom: 0.5pt solid ; "><p> One item <span class="emphasis"><em>Packt</em></span> is added to queue.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">Enqueue</code> Publishing </p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">['Publishing', 'Packt']</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>One more item <span class="emphasis"><em>Publishing </em></span>is added to the queue. </p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">Size()</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">['Publishing', 'Packt']</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Return the number of items in the queue, which is 2 in this example.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">Dequeue()</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">['Publishing']</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>The <span class="emphasis"><em>Packt</em></span> item is dequeued and returned. (This item  was added first, so it is removed first.)</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">Dequeue()</code></p></td><td style="border-right: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; "><p><code class="literal">[]</code></p></td><td style=""><p>The <span class="emphasis"><em>Publishing</em></span> item is dequeued and returned. (This is the last item added, so it is returned last.)</p></td></tr></tbody></table></div><p> </p><p> </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec32"></a>List-based queues</h3></div></div></div><p>Queues can be implemented using various <span>methods</span><a id="id325855574" class="indexterm"></a> such as <code class="literal">list</code>, <code class="literal">stack</code>, and <code class="literal">node</code>. We shall <span>discuss</span><a id="id325855592" class="indexterm"></a> the implementation of queues using all these methods one by one. Let's start by implementing a queue using Python's <code class="literal">list</code> class. This is to help us quickly learn about queues. The operations that must be performed on the queue are encapsulated in the <code class="literal">ListQueue</code> class<span>:</span></p><pre class="programlisting">class ListQueue: 
    def __init__(self): 
        self.items = [] 
        self.size = 0 </pre><p>In the initialization method, <code class="literal">__init__</code>, the <code class="literal">items</code> instance variable is set to <code class="literal">[]</code>, which means the queue is empty when created. The size of the queue is also set to <code class="literal">zero</code>. The <code class="literal">enqueue</code> and <code class="literal">dequeue</code> are important methods in queues, and we will discuss them in the next subsections. </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec33"></a>The enqueue operation</h4></div></div></div><p>The <code class="literal">enqueue</code> operation <span>adds</span><a id="id325896313" class="indexterm"></a> an item to the queue. It uses the <code class="literal">insert</code> method of the <code class="literal">list</code> class to insert items (or data) at the front of the list. See the following code for the implementation of the <code class="literal">enqueue</code> method:</p><pre class="programlisting">  def enqueue(self, data): 
    self.items.insert(0, data)   # Always insert items at index 0
    self.size += 1               # increment the size of the queue by 1</pre><p>It is important to note how we implement insertions in queues using list. The concept is that we add the items at index <code class="literal">0</code> in a list; it is the first position in an array or list. To understand the concept of how the queue works when we add items at index <code class="literal">0</code> in a list, consider the following diagram. We start with an empty list. Initially, we add an item <code class="literal">1</code> at index <code class="literal">0</code>. Next, we add an item <code class="literal">2</code> at index <code class="literal">0</code>; it will shift the previously added item to the next index.</p><p>Next, when we again add a new item <code class="literal">3</code> to the list at index <code class="literal">0</code>, all the items already added to the list are shifted, as shown in the following figure. Similarly, when we add item <code class="literal">4</code> at index <code class="literal">0</code>, all the items are shifted in the list:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/2097cf55-667c-499d-9e35-f12a48ea1735.png" /></div><p>Thus, in our implementation of a <span>queue</span><a id="id325955356" class="indexterm"></a> using a Python list, the array index <code class="literal">0</code> is the only place where new data elements are inserted into the queue. The <code class="literal">insert</code> operation will shift existing data elements in the list by one position up and then insert the new data in the space created at index <code class="literal">0</code>.  </p><p>To make our queue reflect the addition of the new element, the size is increased by <code class="literal">1</code>:</p><pre class="programlisting">self.size += 1 </pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note6"></a>Note</h3><p>We could have used Python's <code class="literal">shift</code> method on the list as another way of implementing the insert at <code class="literal">0</code>. </p></div><p> </p><p> </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec34"></a>The dequeue operation</h4></div></div></div><p>The <code class="literal">dequeue</code> operation is used to <span>delete</span><a id="id325985497" class="indexterm"></a> items from the queue. This method returns the topmost item from the queue and deletes it from the queue. Here is the implementation of the <code class="literal">dequeue</code> method:</p><pre class="programlisting">  def dequeue(self):
    data = self.items.pop()    # delete the topmost item from the queue
    self.size -= 1             # decrement the size of the queue by 1
     return data</pre><p>The Python <code class="literal">list</code> class has a method called <code class="literal">pop()</code>. The <code class="literal">pop</code> method does the following:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Deletes the last item from the list</li><li>Returns the deleted item from the list back to the user or code that called it</li></ol></div><p>The last item in the list is popped and saved in the <code class="literal">data</code> variable. In the last line of the method, the data is returned.</p><p>Consider the following figure as our queue implementation, where three elements are added—<code class="literal">1</code>, <code class="literal">2</code>, and <code class="literal">3</code>. To perform a <code class="literal">dequeue</code> operation, the node with data <code class="literal">1</code> is removed from the front of the queue as it was added first:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/471a6c4a-22d6-4903-b16f-5e7f98105f2c.png" /></div><p>The resulting elements in the queue are shown as follows:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/afb2b3e3-123d-4b20-a807-b5a83278d683.png" /></div><p> </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note7"></a>Note</h3><p>The <code class="literal">enqueue</code> operation is very inefficient due to one reason. The method has to first shift all the elements by one space. Imagine there are 1 million elements in a list which need to be shifted around any time a new element is being added to the queue. This will make the enqueue process very slow for large lists.</p></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec33"></a>Stack-based queues</h3></div></div></div><p>Queues can also be implemented using two stacks. We initially set two instance <span>variables</span><a id="id326030622" class="indexterm"></a> to create an empty queue upon initialization. These are the stacks that will <span>help</span><a id="id326637642" class="indexterm"></a> us to implement a queue. The stacks, in this case, are simply Python lists that allow us to call <code class="literal">push</code> and <code class="literal">pop</code> methods on them, which eventually allow us to get the functionality of <code class="literal">enqueue</code> and <code class="literal">dequeue</code> operations. Here is the <code class="literal">Queue</code> class:</p><pre class="programlisting">class Queue: 
    def __init__(self): 
        self.inbound_stack = [] 
        self.outbound_stack = [] </pre><p>The<code class="literal">inbound_stack</code>is only used to store elements that are added to the queue. No other operation can be performed on this stack.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec35"></a>Enqueue operation</h4></div></div></div><p>The <code class="literal">enqueue</code> method is to add items to the queue. This method is very simple and only <span>receives</span><a id="id325955426" class="indexterm"></a> the <code class="literal">data</code> to append to the queue. This data is then passed to the <code class="literal">append</code> method of the <code class="literal">inbound_stack</code> in the <code class="literal">queue</code> class. Further, the <code class="literal">append</code> method is used to mimic the <code class="literal">push</code> operation, which pushes elements to the top of the stack. The following code is the implementation of <code class="literal">enqueue</code> using the stack in Python:</p><pre class="programlisting">def enqueue(self, data): 
    self.inbound_stack.append(data) </pre><p>To <code class="literal">enqueue</code> data onto the <code class="literal">inbound_stack</code>, the following code does the job:</p><pre class="programlisting">queue = Queue() 
queue.enqueue(5) 
queue.enqueue(6) 
queue.enqueue(7) 
print(queue.inbound_stack)</pre><p> </p><p> </p><p> </p><p> </p><p>A command-line output of the <code class="literal">inbound_stack</code> inside the queue is as follows:</p><pre class="programlisting"><span class="strong"><strong>[5, 6, 7]</strong></span></pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec36"></a>Dequeue operation</h4></div></div></div><p>The <code class="literal">dequeue</code> operation is used to delete the <span>elements</span><a id="id325955611" class="indexterm"></a> from the queue in the order of items added. New elements added to our queue end up in the <code class="literal">inbound_stack</code>. Instead of removing elements from the <code class="literal">inbound_stack</code>, we shift our attention to another stack, that is, <code class="literal">outbound_stack</code>. We shall delete the elements from our queue only through the <code class="literal">outbound_stack</code>.</p><p>To understand how <code class="literal">outbound_stack</code> can be used to delete the items from the queue, let us consider the following example. </p><p>Initially, our <code class="literal">inbound_stack</code> was filled with the elements <span class="strong"><strong>5</strong></span>, <span class="strong"><strong>6</strong></span>, and <span class="strong"><strong>7</strong></span>, as shown in the following diagram:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/83988f02-3783-44e5-a44c-4706c691f3f7.png" /></div><p>We first check if the <code class="literal">outbound_stack</code> is empty or not. As it is empty at the start, we move all the elements of the <code class="literal">inbound_stack</code> to the <code class="literal">outbound_stack</code> using the <code class="literal">pop</code> operation on the stack.  Now the <code class="literal">inbound_stack</code> becomes empty and the <code class="literal">outbound_stack</code> keeps the elements. We show this in the following diagram for more clarity:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/642d664b-63b3-4667-a290-a315082444b8.png" /></div><p>Now, if the <code class="literal">outbound_stack</code> is not empty, we <span>proceed</span><a id="id325956012" class="indexterm"></a> to remove the items from the queue using the <code class="literal">pop</code> operation. In the preceding figure, when we apply the <code class="literal">pop</code> operation on <code class="literal">outbound_stack</code>, we get the element <code class="literal">5</code>, which is correct as it was added first and should be the first element to be popped off from the queue. This leaves the <code class="literal">outbound_stack</code> with only two elements:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/bc4f699b-bc99-4b82-8298-d946849c4fda.png" /></div><p>Here is the implementation of the <code class="literal">dequeue</code> method for the queue:</p><pre class="programlisting">def dequeue(self):  
    if not self.outbound_stack: 
        while self.inbound_stack: 
            self.outbound_stack.append(self.inbound_stack.pop()) 
    return self.outbound_stack.pop() </pre><p>The <code class="literal">if</code> statement first checks whether the <code class="literal">outbound_stack</code> is empty or not. If it is not empty, we proceed to remove the element at the front of the queue using the <code class="literal">pop</code> method, shown as follows:</p><pre class="programlisting">return self.outbound_stack.pop() </pre><p>If the <code class="literal">outbound_stack</code> is empty instead, all the elements in the <code class="literal">inbound­_stack</code> are moved to the <code class="literal">outbound_stack</code> before the front element in the queue is popped out:</p><pre class="programlisting">while self.inbound_stack: 
    self.outbound_stack.append(self.inbound_stack.pop()) </pre><p>The <code class="literal">while</code> loop will continue to be executed as long as there are elements in the <code class="literal">inbound_stack</code>.</p><p>The <code class="literal">self.inbound_stack.pop()</code> statement will remove the latest element that was added to the <code class="literal">inbound_stack</code> and immediately passes the popped data to the <code class="literal">self.outbound_stack.append()</code> method call.</p><p>Let us consider an example code to understand the operations on the queue. We firstly use the queue implementation to add three items in the queue,that is, <code class="literal">5</code>, <code class="literal">6</code>, and <code class="literal">7</code>. Next, we <span>apply</span><a id="id325979301" class="indexterm"></a> dequeue operations to remove items from the queue. Here is the code :</p><pre class="programlisting">queue = Queue() 
queue.enqueue(5) 
queue.enqueue(6) 
queue.enqueue(7) 
print(queue.inbound_stack) 
queue.dequeue() 
print(queue.inbound_stack) 
print(queue.outbound_stack) 
queue.dequeue() 
print(queue.outbound_stack) </pre><p>The output for the preceding code is as follows:</p><pre class="programlisting"><span class="strong"><strong> [5, 6, 7] </strong></span>
<span class="strong"><strong> [] </strong></span>
<span class="strong"><strong> [7, 6] </strong></span>
<span class="strong"><strong> [7]</strong></span></pre><p>The preceding code snippet firstly adds elements to a queue and prints out the elements within the queue. Next, the <code class="literal">dequeue</code> method is called, after which a change in the number of elements is observed when the queue is printed out again.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip8"></a>Note</h3><p><span>Implementing a q</span>ueue with two stacks is very important and questions about this are often posed during interviews.</p></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec34"></a>Node-based queues</h3></div></div></div><p>Using a Python list to implement a queue is a good <span>start</span><a id="id325979360" class="indexterm"></a> to get a feel for how queues work. It is also <span>possible</span><a id="id325979368" class="indexterm"></a> for us to implement our own queue data structure by utilizing pointer structures.</p><p>A queue can be implemented using a doubly linked list, and <code class="literal">insertion</code> and <code class="literal">deletion</code> operations on this data structure, and that has a time complexity of <code class="literal"><span class="emphasis"><em>O(1)</em></span></code>.</p><p>The definition for the <code class="literal">node</code> class remains the same as the <code class="literal">Node</code> we defined when we discussed in the doubly linked lists. A doubly linked list can be treated as a queue if it enables a FIFO kind of data access, where the first element added to the list is the first to be removed.</p><p> </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec37"></a>Queue class</h4></div></div></div><p>The <code class="literal">queue</code> class is very <span>similar</span><a id="id325979617" class="indexterm"></a> to that of the doubly linked <code class="literal">list</code> class and the <code class="literal">Node</code> class to adding a node in a doubly linked list:</p><pre class="programlisting">class Node(object):
    def __init__(self, data=None, next=None, prev=None):
        self.data = data
        self.next = next
        self.prev = prev

class Queue: 
    def __init__(self): 
        self.head = None 
        self.tail = None 
        self.count = 0 </pre><p>Initially, the <code class="literal">self.head</code> and <code class="literal">self.tail</code> pointers are set to <code class="literal">None</code> upon creation of an instance of the <code class="literal">queue</code> class. To keep a count of the number of nodes in <code class="literal">Queue</code>, the <code class="literal">count</code> instance variable is also maintained here and initially set to <code class="literal">0</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec38"></a>The enqueue operation</h4></div></div></div><p>Elements are added to a <code class="literal">Queue</code> object via the <code class="literal">enqueue</code> method. The elements or data are added through nodes. The <code class="literal">enqueue</code> method code is very <span>similar</span><a id="id325979676" class="indexterm"></a> to the <code class="literal">append</code> operation of the doubly linked list which we discussed in<a class="link" href="#" linkend="ch04">Chapter 4</a>, <span class="emphasis"><em>Lists and Pointer Structures</em></span>.</p><p>The enqueue operation creates a node from the data passed to it and appends it to the <code class="literal">tail</code> of the queue, and points both <code class="literal">self.head</code> and <code class="literal">self.tail</code> to the newly created node if the queue is empty. The total count of elements in the queue is increased by the line <code class="literal">self.count += 1</code>. If the queue is not empty, the new node's previous variable is set to the tail of the list, and the tail's next pointer (or variable) is set to the new node. Lastly, we update the tail pointer to point to the new node. This is shown in the following code:</p><pre class="programlisting">    def enqueue(self, data): 
        new_node = Node(data, None, None) 
        if self.head is None: 
            self.head = new_node 
            self.tail = self.head 
        else: 
            new_node.prev = self.tail 
            self.tail.next = new_node 
            self.tail = new_node 

        self.count += 1</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec39"></a>The dequeue operation</h4></div></div></div><p>The other operation that makes our doubly linked list behave as a queue is the <code class="literal">dequeue</code> method. This method removes the node at the front of the queue. To remove the first <span>element</span><a id="id325990582" class="indexterm"></a> pointed to by <code class="literal">self.head</code>, an <code class="literal">if</code> statement is used:</p><pre class="programlisting">def dequeue(self): 
    current = self.head 
         if self.count == 1: 
             self.count -= 1 
             self.head = None 
             self.tail = None 
         elif self.count &gt; 1: 
             self.head = self.head.next 
             self.head.prev = None 
             self.count -= 1 </pre><p><code class="literal">current</code> is initialized by pointing it to <code class="literal">self.head</code>. If <code class="literal">self.count</code> is <code class="literal">1</code>, then it means only one node is in the list and invariably the queue. Thus, to remove the associated node (pointed to by <code class="literal">self.head</code>), the <code class="literal">self.head</code> and <code class="literal">self.tail</code> variables are set to <code class="literal">None</code>.</p><p>If the queue has many nodes, then the head pointer is shifted to point to the next node after <code class="literal">self.head</code>.</p><p>After the <code class="literal">if</code> statement is executed, the method returns the node that was pointed to by the <code class="literal">head</code>. Also, the variable <code class="literal">self.count</code> is decremented by <code class="literal">1</code> in both of these conditions, that is, when the count is initially <code class="literal">1</code> and more than <code class="literal">1</code>.</p><p>Equipped with these methods, we have implemented a queue, borrowing heavily from the idea of a doubly linked list.</p><p>Remember also that the only things transforming our doubly linked list into a queue are the two methods, namely, <code class="literal">enqueue</code> and <code class="literal">dequeue</code> methods.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec35"></a>Application of queues</h3></div></div></div><p>Queues can be used to implement a <span>variety</span><a id="id326032900" class="indexterm"></a> of functionalities in many real computer-based applications. For instance, instead of providing each computer on a network with its own printer, a network of computers can be made to share one printer by queuing what each printer wants to print. When the printer is ready to print, it will pick one of the items (usually called jobs) in the queue to print out. It will print the command from the computer that has given the command first and in the order of the commands given by different computers. </p><p> </p><p>Operating systems also queue processes to be executed by the CPU. Let's create an application that makes use of a queue to create a bare-bones media player.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec40"></a>Media player queues</h4></div></div></div><p>The most music player software allows users to add <span>songs</span><a id="id326032920" class="indexterm"></a> to a playlist. Upon hitting the play button, all the songs in the main playlist are played one after the other. Sequential playing of the songs can be implemented with queues because the first song to be queued is the first song that is to be played. This aligns with the FIFO acronym. We will implement our own playlist queue to play songs in the FIFO manner.</p><p>Our media player queue will only allow for the addition of tracks and a way to play all the tracks in the queue. In a full-blown music player, threads would be used to improve how the queue is interacted with, while the music player continues to be used to select the next song to be played, paused, or even stopped.</p><p>The <code class="literal">track</code> class will simulate a musical track:</p><pre class="programlisting">from random import randint 
class Track: 
    def __init__(self, title=None): 
        self.title = title 
        self.length = randint(5, 10) </pre><p>Each track holds a reference to the title of the <span>song</span><a id="id326032942" class="indexterm"></a> and also the length of the song. The length of the song is a random number between <code class="literal">5</code> and <code class="literal">10</code>. The random module in Python provides the <code class="literal">randint</code> function to enable us to generate the random numbers. The class represents any MP3 track or file that contains music. The random length of a track is used to simulate the number of seconds it takes to play a song or track.</p><p>To create a few tracks and print out their lengths, we do the following:</p><pre class="programlisting">track1 = Track("white whistle") 
track2 = Track("butter butter") 
print(track1.length) 
print(track2.length) </pre><p>The output of the preceding code is as follows:</p><pre class="programlisting"><span class="strong"><strong>6</strong></span>
<span class="strong"><strong>7</strong></span></pre><p> </p><p> </p><p>Your output may be different depending on the random length generated for the two tracks.</p><p>Now, let's create our queue. Using inheritance, we simply inherit from the <code class="literal">queue</code> class:</p><pre class="programlisting">import time 
class MediaPlayerQueue(Queue): 

    def __init__(self): 
        super(MediaPlayerQueue, self).__init__() </pre><p>A call is made to properly initialize the queue by making a call to <code class="literal">super</code>. This class is essentially a queue that holds a number of track objects in a queue. To add tracks to the queue, an <code class="literal">add_track</code> method is created:</p><pre class="programlisting">    def add_track(self, track): 
        self.enqueue(track) </pre><p>The method passes a <code class="literal">track</code> object to the <code class="literal">enqueue</code> method of the queue <code class="literal">super</code> class. This will, in effect, create a <code class="literal">Node</code> using the <code class="literal">track</code> object (as the node's data) and point either the tail, if the queue is not empty, or both head and tail, if the queue is empty, to this new node.</p><p>Assuming the tracks in the queue are played <span>sequentially</span><a id="id326034125" class="indexterm"></a> from the first track added to the last (FIFO), then the <code class="literal">play</code> function has to loop through the elements in the queue:</p><pre class="programlisting">def play(self): 
        while self.count &gt; 0: 
            current_track_node = self.dequeue() 
            print("Now playing {}".format(current_track_node.data.title)) 
            time.sleep(current_track_node.data.length) </pre><p>The <code class="literal">self.count</code> keeps count of when a <span>track</span><a id="id326034147" class="indexterm"></a> is added to our queue and when tracks have been dequeued. If the queue is not empty, a call to the <code class="literal">dequeue</code> method will return the node (which houses the <code class="literal">track</code> object) at the front of the queue. The <code class="literal">print</code> statement then accesses the title of the track through the <code class="literal">data</code> attribute of the node. To further simulate the playing of a track, the <code class="literal">time.sleep()</code> method halts program execution till the number of seconds for the track has elapsed:</p><pre class="programlisting">time.sleep(current_track_node.data.length)</pre><p>The media player queue is made up of nodes. When a track is added to the queue, the track is hidden in a newly created node and associated with the data attribute of the node. That explains why we access a node's <code class="literal">track</code> object through the data property of the node which is returned by the call to <code class="literal">dequeue</code>:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/1ac2cc2d-139b-4383-aca3-0d441e8a117e.png" /></div><p>You can see that, instead of our <code class="literal">node</code> object just storing just any data, it <span>stores</span><a id="id326034644" class="indexterm"></a> tracks in this case.</p><p>Let's take our music player for a spin:</p><pre class="programlisting">track1 = Track("white whistle") 
track2 = Track("butter butter") 
track3 = Track("Oh black star") 
track4 = Track("Watch that chicken") 
track5 = Track("Don't go") </pre><p>We create five track objects with random <span>words</span><a id="id326034659" class="indexterm"></a> as titles:</p><pre class="programlisting">print(track1.length) 
print(track2.length) 
<span class="strong"><strong>&gt;&gt; 8
</strong></span><span class="strong"><strong>&gt;&gt; 9</strong></span></pre><p>The output should be different from what you get on your machine due to the random length.</p><p>Next, an instance of the <code class="literal">MediaPlayerQueue</code> class is created:</p><pre class="programlisting">media_player = MediaPlayerQueue()</pre><p> </p><p> </p><p>The <span>tracks</span><a id="id326034698" class="indexterm"></a> will be added and the output of the <code class="literal">play</code> function should <span>print</span><a id="id326034882" class="indexterm"></a> out the tracks being played in the same order in which we queued them:</p><pre class="programlisting">media_player.add_track(track1) 
media_player.add_track(track2) 
media_player.add_track(track3) 
media_player.add_track(track4) 
media_player.add_track(track5) 
media_player.play() </pre><p>The output of the preceding code is as follows:</p><pre class="programlisting"><span class="strong"><strong>&gt;&gt;Now playing white whistle</strong></span>
<span class="strong"><strong>    &gt;&gt;Now playing butter butter</strong></span>
<span class="strong"><strong>    &gt;&gt;Now playing Oh black star</strong></span>
<span class="strong"><strong>    &gt;&gt;Now playing Watch that chicken</strong></span>
<span class="strong"><strong>    &gt;&gt;Now playing Don't go</strong></span></pre><p>Upon execution of the program, it can be seen that the tracks are played in the order in which they were queued. When playing the track, the system also pauses for the number of seconds equal to that of the length of the track.</p></div></div></div>