<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec29"></a>Sets</h2></div></div><hr /></div><p>Sets are unordered collections of unique items. Sets are themselves mutable—we can add and remove <span>items</span><a id="id326535812" class="indexterm"></a> from them; however, the items themselves must be immutable. An important distinction with sets is that they cannot contain duplicate items. Sets are typically used to perform mathematical operations such as intersection, union, difference, and complement.</p><p> </p><p><span>Unlike sequence types, set types do not provide any indexing or slicing operations. There are two types of set objects in Python</span>, the mutable <code class="literal">set</code> object and the immutable <code class="literal">frozenset</code> object. Sets are created using comma-separated values within curly braces. By the way, we cannot create an empty set using <code class="literal">a={}</code>, because this will create a dictionary. To create an empty set, we write either <code class="literal">a=set()</code> or <code class="literal">a=frozenset()</code>.</p><p>Methods and <span>operations</span><a id="id326582217" class="indexterm"></a><span>of sets are described in the following ta</span>ble:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Method</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Description</strong></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">len(a)</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Provides the total number of elements in the <code class="literal">a</code> set.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">a.copy()</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Provides another copy of the <code class="literal">a</code> set.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">a.difference(t)</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Provides a set of elements that are in the <code class="literal">a</code>set but not in <code class="literal">t</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">a.intersection(t)</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Provides a set of elements that are in both sets, <code class="literal">a</code> and <code class="literal">t</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">a.isdisjoint(t)</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Returns <code class="literal">True</code> if no element is common in both the sets, <code class="literal">a</code> and <code class="literal">t</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">a.issubset(t)</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Returns <code class="literal">True</code> if all of the elements of the <code class="literal">a</code> set are also in the <code class="literal">t</code> set.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">a.issuperset(t)</code></p></td><td style=""><p>Returns <code class="literal">True</code> if all of the elements of the <code class="literal">t</code> set are also in the <code class="literal">a</code> set.</p></td></tr></tbody></table></div><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">a.symmetric_difference(t)</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Returns a set of elements that are in either the <code class="literal">a</code> or <code class="literal">t</code> sets, but not in both.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">a.union(t)</code></p></td><td style=""><p>Returns a set of elements that are in either the <code class="literal">a</code> or <code class="literal">t</code> sets.</p></td></tr></tbody></table></div><p> </p><p>In the preceding table, the <code class="literal">t</code>parameter can be any Python object that supports iteration and all methods are available to both <code class="literal">set</code> and <code class="literal">frozenset</code> objects. It is important to be aware that the operator versions of these methods require their arguments to be sets, whereas the methods themselves can accept any iterable type. For example, <code class="literal">s-[1,2,3]</code>, for any set, <code class="literal">s</code>, will generate an unsupported operand type. Using the equivalent, <code class="literal">s.difference([1,2,3])</code> will return a result.</p><p>M<span>utable <code class="literal">set</code> objects have additional methods, described in the follo</span>wing table:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Method</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Description</strong></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">s.add(item)</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Adds an item to <code class="literal">s</code>; nothing happens if the item is already added.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">s.clear()</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Removes all elements from the set, <code class="literal">s</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">s.difference_update(t)</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Removes those elements from the <code class="literal">s</code>set that are also in the other set, <code class="literal">t</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">s.discard(item)</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Removes the item from the set, <code class="literal">s</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">s.intersection_update(t)</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Remove the items from the set, <code class="literal">s</code>, which are not in the intersection of the sets, <code class="literal">s</code> and <code class="literal">t</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">s.pop()</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Returns an arbitrary item from the set, <code class="literal">s</code>, and it removes it from the <code class="literal">s</code> set.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">s.remove(item)</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Deletes the item from the <code class="literal">s</code> set.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">s.symetric_difference_update(t)</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Deletes all of the elements from the <code class="literal">s</code> set that are not in the symmetric difference of the sets, <code class="literal">s</code> and <code class="literal">t</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">s.update(t)</code></p></td><td style=""><p>Appends all of the items in an iterable object, <code class="literal">t</code>, to the <code class="literal">s</code> set.</p></td></tr></tbody></table></div><p> </p><p>Here, consider a simple <span>example</span><a id="id325584733" class="indexterm"></a> showing addition, removal, discard, and clear operations:</p><pre class="programlisting">&gt;&gt;&gt; s1 = set()
&gt;&gt;&gt; s1.add(1)
&gt;&gt;&gt; s1.add(2)
&gt;&gt;&gt; s1.add(3)
&gt;&gt;&gt; s1.add(4)
&gt;&gt;&gt; s1
{1, 2, 3, 4}
&gt;&gt;&gt; s1.remove(4)
&gt;&gt;&gt; s1
{1, 2, 3}
&gt;&gt;&gt; s1.discard(3)
&gt;&gt;&gt; s1
{1, 2}
&gt;&gt;&gt;s1.clear()
&gt;&gt;&gt;s1
set()</pre><p>The following example demonstrates some simple set operations and their results:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/c1efb6bb-a268-4db0-b0bf-b9be95944e15.png" /></div><p> </p><p>Notice that the <code class="literal">set</code> object does not care that its members are not all of the same type, as long as they are all immutable. If you try to use a mutable object such as a list or dictionary in a set, you will receive an unhashable type error. Hashable types all have a hash value that does not change throughout the lifetime of the instance. All built-in immutable types are hashable. All built-in mutable types are not hashable, so they cannot be used as elements of sets or keys to dictionaries.</p><p>Notice also in the preceding code that when we print out the union of <code class="literal">s1</code> and <code class="literal">s2</code>, there is only one element with the value <code class="literal">'ab'</code>. This is a natural property of sets in that they do not include duplicates.</p><p>In addition to these built-in methods, there are a number of other operations that we can perform on sets. For example, to test for membership of a set, use the following:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/d3a9d8e8-a66c-442f-8cbd-04d2a81f52bb.png" /></div><p>We can loop through elements in a set using the following:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/13868d7e-ac8f-4a7e-8528-f93a440a34a4.png" /></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec15"></a>Immutable sets</h3></div></div></div><p>Python has an <span>immutable</span><a id="id325585047" class="indexterm"></a> set type called <code class="literal">frozenset</code>. It works pretty much exactly like <code class="literal">set</code>, apart from not allowing methods or <span>operations</span><a id="id325585062" class="indexterm"></a> that change values such as the <code class="literal">add()</code> or <code class="literal">clear()</code> methods. There are several ways that this immutability can be useful.</p><p>For example, since normal sets are mutable and <span>therefore</span><a id="id325585112" class="indexterm"></a> not hashable, they cannot be used as members of other sets. On the other hand <code class="literal">frozenset</code> is immutable and <span>therefore</span><a id="id325585124" class="indexterm"></a> able to be used as a member of a set:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/0847bfe1-ba04-4428-992f-83c900c5983b.png" /></div><p>Also, the immutable property of <code class="literal">frozenset</code> means we can use it for a key to a dictionary, as in the following example:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/0f31cf26-a96b-4b98-9290-38fe6664f500.png" /></div></div></div>