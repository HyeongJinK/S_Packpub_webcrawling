<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch10lvl1sec80"></a>Quick sort algorithms</h2></div></div><hr /></div><p>The quick sort algorithm is very <span>efficient</span><a id="id325977661" class="indexterm"></a> for sorting. The quick sort <span>algorithm</span><a id="id325977984" class="indexterm"></a> falls under the divide and conquer class of algorithms, similar to the merge sort algorithm, where we break (divide) a problem into smaller chunks that are much simpler to solve (conquer).</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec67"></a>List partitioning</h3></div></div></div><p>The concept behind quick sorting is <span>partitioning</span><a id="id325977649" class="indexterm"></a> a given list or array. To partition the list, we first select a pivot. All the elements in the list will be compared with this pivot. At the end of the partitioning process, all elements that are less than the pivot will be to the left of the pivot, while all elements greater than the pivot will lie to the right of the pivot in the array.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl3sec46"></a>Pivot selection</h4></div></div></div><p>For the sake of simplicity, we'll take the first <span>element</span><a id="id325977636" class="indexterm"></a> in an array as the pivot. This kind of pivot selection degrades in performance, especially when sorting an already sorted list. Randomly picking the middle or last element in the array as the pivot does not improve the performance of the quick sort. We will discuss a better approach to select the pivot and find the smallest element in a list in thenext chapter.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec68"></a>An illustration with an example</h3></div></div></div><p>In this algorithm, we partition an <span>unsorted</span><a id="id325977614" class="indexterm"></a> array into two sub-arrays, in such a way that all the elements on the left side of that partition point (also called a pivot) should be smaller than the pivot, and all the elements on the right side of the pivot should be greater. After the first iteration of the quick sort algorithm, the chosen pivot point is placed in the list at its correct position. After the first iteration, we obtain two unordered sub-lists, and follow the same process again on these two sub-lists. Thus, the quick sort algorithm partitions the list into two parts and recursively applies the quick sort algorithm on these two sub-lists to sort the whole list. </p><p>We start by choosing a pivot point with which all the items are to be compared, and at the end of the first iteration, this value will be placed in its correct position in the ordered list. Next, we use two pointers, a left pointer, and a right pointer. The left pointer initially points to the value at index <span class="strong"><strong>1</strong></span>, and the right pointer points to the value at the last index. The main idea behind the quick sort algorithm is to move the items that are on the wrong side of the pivot value. So, we start with the left pointer, moving from in a left-to-right direction, until we reach a position where the item has a greater value than the pivot value. Similarly, we move the right pointer toward the left until we find a value less than a pivot value. Next, we swap these two values indicated by the left and right pointers. We repeat the same process until both pointers cross each other; in other words, when the right pointer index indicates a value less than that of the left pointer index.</p><p>Let's take an example of a list of numbers, {<span class="strong"><strong>45</strong></span>, <span class="strong"><strong>23</strong></span>, <span class="strong"><strong>87</strong></span>, <span class="strong"><strong>12</strong></span>, <span class="strong"><strong>72</strong></span>, <span class="strong"><strong>4</strong></span>, <span class="strong"><strong>54</strong></span>, <span class="strong"><strong>32</strong></span>, <span class="strong"><strong>52</strong></span>}, to understand how the quick sort algorithm works. Let's assume that the pivot point in our list is the first element, <span class="strong"><strong>45</strong></span>. We move the left pointer from index<span class="strong"><strong>1</strong></span>in a rightward direction, and stop when we reach the value<span class="strong"><strong>87</strong></span>, because (<span class="strong"><strong>87</strong></span>&gt;<span class="strong"><strong>45</strong></span>). Next, we move the right pointer toward the left, and stop when we find the value<span class="strong"><strong>32</strong></span>, because (<span class="strong"><strong>32</strong></span>&lt;<span class="strong"><strong>45</strong></span>). </p><p> </p><p> </p><p>Now, we swap these two values, as <span>shown</span><a id="id325644860" class="indexterm"></a> in the following diagram:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/21f6547f-59d9-4ac4-ae6e-b1de54eecd5a.png" /></div><p>After that, we repeat the same process and move the left pointer toward the right direction, and stop when we find the value<span class="strong"><strong>72</strong></span>, because (<span class="strong"><strong>72</strong></span>&gt;<span class="strong"><strong>45</strong></span>). Next, we move the right pointer toward the left and stop when we reach the value 4, because (<span class="strong"><strong>4</strong></span>&lt;<span class="strong"><strong>45</strong></span>). Now, we swap these two values, because they are in the wrong direction of the pivot value. We repeat the same process and stop once the right pointer index value becomes less than the left pointer index. Here, we find <span class="strong"><strong>4</strong></span> as the splitting point, and swap it with the pivot value. This is <span>shown</span><a id="id325837806" class="indexterm"></a> in the following diagram:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/44bc08c0-e405-4066-adb9-e4907e49acb7.png" /></div><p> </p><p>It can be observed that after the first iteration of the quick sort algorithm, the pivot value <span class="strong"><strong>45</strong></span> is placed at its correct position in the list.</p><p>Now we have two sub-lists:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>The sub-list to the left of the pivot value, <span class="strong"><strong>45</strong></span>, has values of less than <span class="strong"><strong>45</strong></span>.</li><li>Another sub-list to the right of the pivot value contains <span>values</span><a id="id325978628" class="indexterm"></a> greater than 45. We will apply the quick sort algorithm recursively on these two sub-lists, and repeat it until the whole list is sorted.</li></ol></div><div class="mediaobject"><img src="/graphics/9781788995573/graphics/0c2320ac-410a-4f90-bf17-105cc382e5e7.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec69"></a>Implementation</h3></div></div></div><p>The partitioning step is very important in <span>understanding</span><a id="id325978852" class="indexterm"></a> the implementation of the quick sort algorithm, so we will start with an examination of implementing the partitioning first.</p><p>Let's look at another example to understand the implementation. Consider the following list of integers. We shall partition this list using the partition function, as follows:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/f909125d-2530-4184-8e51-0f0f5ea8951a.png" /></div><p>Consider the following code for this:</p><pre class="programlisting">     def partition(unsorted_array, first_index, last_index): 

        pivot = unsorted_array[first_index] 
        pivot_index = first_index 
        index_of_last_element = last_index 

        less_than_pivot_index = index_of_last_element 
        greater_than_pivot_index = first_index + 1 
        ...</pre><p>The partition function receives, as its parameters, the indices of the first and last elements of the array that we need to partition. </p><p>The value of the pivot is stored in the <code class="literal">pivot</code> variable, while its index is stored in <code class="literal">pivot_index</code>. We are not using <code class="literal">unsorted_array[0]</code>, because when the unsorted array parameter is called with a segment of an array, index <code class="literal">0</code> will not necessarily point to the first element in that array. The index of the next <span>element</span><a id="id325979092" class="indexterm"></a> to the pivot, that is, the <span class="strong"><strong>left pointer</strong></span>, <code class="literal">first_index + 1</code>, marks the position where we begin to look for an element in the array that is greater than the <code class="literal">pivot</code>, as <code class="literal">greater_than_pivot_index = first_index + 1</code>. The <span class="strong"><strong>right pointer</strong></span> <code class="literal">less_than_pivot_index</code> variable points to the position of the last element in the <code class="literal">less_than_pivot_index = index_of_last_element</code> list, where we begin the search for the element that is less than the pivot:</p><pre class="programlisting">    while True: 

        while unsorted_array[greater_than_pivot_index] &lt; pivot and 
              greater_than_pivot_index &lt; last_index: 
              greater_than_pivot_index += 1 

        while unsorted_array[less_than_pivot_index] &gt; pivot and 
              less_than_pivot_index &gt;= first_index: 
              less_than_pivot_index -= 1 </pre><p>At the beginning of the execution of the main <code class="literal">while</code> loop, the array looks like this:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/98a13f8f-98e7-4838-8b46-87f576e68f29.png" /></div><p>The first inner <code class="literal">while</code> loop moves one index to the right until it lands on index <span class="strong"><strong>2</strong></span>, because the value at that index is greater than <span class="strong"><strong>43</strong></span>. At this point, the first <code class="literal">while</code> loop breaks and does not continue. At each test of the condition in the first <code class="literal">while</code> loop, <code class="literal">greater_than_pivot_index += 1</code> is evaluated only if the <code class="literal">while</code> loop's test condition evaluates to <code class="literal">True</code>. This makes the search for an element, greater than the pivot, progress to the next element on the right.</p><p> </p><p>The second inner <code class="literal">while</code> loop moves one index at a time to the left, until it lands on index <span class="strong"><strong>5</strong></span>, whose value, <span class="strong"><strong>20</strong></span>, is less than <span class="strong"><strong>43</strong></span>:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/c6a54b7f-f6ed-495e-a515-0e106a52e19c.png" /></div><p>At this point, neither inner <code class="literal">while</code> loop can be executed any further:</p><pre class="programlisting">    if greater_than_pivot_index &lt; less_than_pivot_index: 
        temp = unsorted_array[greater_than_pivot_index] 
            unsorted_array[greater_than_pivot_index] =    
                unsorted_array[less_than_pivot_index] 
            unsorted_array[less_than_pivot_index] = temp 
    else: 
        break</pre><p>Since <code class="literal">greater_than_pivot_index &lt; less_than_pivot_index</code>, the body of the <code class="literal">if</code> statement swaps the element at those indexes. The <code class="literal">else</code> condition breaks the infinite <span>loop</span><a id="id326383438" class="indexterm"></a> any time that <code class="literal">greater_than_pivot_index</code> becomes greater than <code class="literal">less_than_pivot_index</code>. In such a condition, it means that <code class="literal">greater_than_pivot_index</code> and <code class="literal">less_than_pivot_index</code> have crossed over each other.</p><p>Our array now looks like the following:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/a90a5e97-880c-4079-aa36-fb0c11bd4786.png" /></div><p>The <code class="literal">break</code> statement is executed when <code class="literal">less_than_pivot_index</code> is equal to <span class="strong"><strong>3</strong></span> and <code class="literal">greater_than_pivot_index</code> is equal to <span class="strong"><strong>4</strong></span>.</p><p> </p><p>As soon as we exit the <code class="literal">while</code> loop, we interchange the element at <code class="literal">unsorted_array[less_than_pivot_index]</code> with that of <code class="literal">less_than_pivot_index</code>, which is returned as the index of the pivot:</p><pre class="programlisting">    unsorted_array[pivot_index]=unsorted_array[less_than_pivot_index] 
    unsorted_array[less_than_pivot_index]=pivot 
    return less_than_pivot_index </pre><p>The following diagram shows how the code interchanges <span class="strong"><strong>4</strong></span> with <span class="strong"><strong>43</strong></span> as the last step in the partitioning process:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/1e4e4762-9b9f-4577-ae14-5381b0f1848f.png" /></div><p>To recap, the first time the <code class="literal">quick_sort</code> function was called, it was partitioned about the element at index <span class="strong"><strong>0</strong></span>. After the return of the partitioning function, we obtain the array in the order of [<span class="strong"><strong>4</strong></span>, <span class="strong"><strong>3</strong></span>, <span class="strong"><strong>20</strong></span>, <span class="strong"><strong>43</strong></span>, <span class="strong"><strong>89</strong></span>, <span class="strong"><strong>77</strong></span>].</p><p>As you can see, all elements to the <span>right</span><a id="id326384276" class="indexterm"></a> of element <span class="strong"><strong>43</strong></span> are greater than <span class="strong"><strong>43</strong></span>, while those to the left are smaller. Thus, the partitioning is complete.</p><p>Using the split point <span class="strong"><strong>43</strong></span> with index <span class="strong"><strong>3</strong></span>, we will recursively sort the two sub-arrays, [<span class="strong"><strong>4</strong></span>, <span class="strong"><strong>30</strong></span>, <span class="strong"><strong>20</strong></span>] and [<span class="strong"><strong>89</strong></span>, <span class="strong"><strong>77</strong></span>], using the same process we just went through.</p><p>The body of the main <code class="literal">quick_sort</code> function is as follows:</p><pre class="programlisting">    def quick_sort(unsorted_array, first, last): 
        if last - first &lt;= 0: 
            return 
    else: 
        partition_point = partition(unsorted_array, first, last) 
        quick_sort(unsorted_array, first, partition_point-1) 
        quick_sort(unsorted_array, partition_point+1, last) </pre><p>The <code class="literal">quick_sort</code> function is a very simple method, taking up no more than six lines of code. The heavy lifting is done by the <code class="literal">partition</code> function. When the <code class="literal">partition</code> method is called, it returns the partition point. This is the point in the <code class="literal">unsorted_array</code> array where all elements to the left are less than the pivot value, and all elements to its right are greater than it.</p><p> </p><p>When we print the state of <code class="literal">unsorted_array</code> immediately after the partition progress, we see clearly how the partitioning happens:</p><pre class="programlisting"><span class="strong"><strong>Output:</strong></span>
<span class="strong"><strong>[43, 3, 20, 89, 4, 77]</strong></span>
<span class="strong"><strong>[4, 3, 20, 43, 89, 77]</strong></span>
<span class="strong"><strong>[3, 4, 20, 43, 89, 77]</strong></span>
<span class="strong"><strong>[3, 4, 20, 43, 77, 89]</strong></span>
<span class="strong"><strong>[3, 4, 20, 43, 77, 89]</strong></span></pre><p>Taking a step back, let's sort the first sub-array after the first partition has happened. The partitioning of the <code class="literal">[4, 3, 20]</code> sub-array will stop when <code class="literal">greater_than_pivot_index</code> is at index <code class="literal">2</code>, and <code class="literal">less_than_pivot_index</code> is at index <code class="literal">1</code>. At that point, the two markers are said to have crossed. Because <code class="literal">greater_than_pivot_index</code> is greater than <code class="literal">less_than_pivot_index</code>, further execution of the <code class="literal">while</code> loop will cease. Pivot <code class="literal">4</code> will be exchanged with <code class="literal">3</code>, while index <code class="literal">1</code> is returned as the partition point.</p><p>In the quicksort algorithm, the partition algorithm takes <code class="literal">O(n)</code> time. As the <span>quicksort</span><a id="id325608032" class="indexterm"></a> algorithm follows the <span class="emphasis"><em>divide and conquer</em></span> paradigm, it takes <code class="literal">O(log n)</code> time; therefore, the overall average-case runtime complexity of the quicksort algorithm is <code class="literal">O(n) * O(log n) = O(n log n)</code>. The quicksort algorithm gives a worst-case runtime complexity of <code class="literal">O(n<sup>2</sup>)</code>. The worst-case complexity for the quicksort algorithm would be when it selects the worst pivot point every time, and one of the partitions always has a single element. For example, if the list is already sorted, the worst-case complexity would occur if the partition picks the smallest element as a pivot point. When worst-case complexity does occur, the quicksort algorithm can be improved by using the randomized quicksort. The quicksort algorithm is very efficient when sorting large amounts of data compared to the other aforementioned algorithms for sorting.</p></div></div>