<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch10lvl1sec81"></a>Heap sort algorithms</h2></div></div><hr /></div><p>In <span>Chapter 8</span>, <span class="emphasis"><em>Graphs and Other Algorithms</em></span>, we implemented a binary <span>heap</span><a id="id325979042" class="indexterm"></a> data structure. Our implementation always made sure that, after an element <span>had</span><a id="id325979034" class="indexterm"></a> been removed or added to a heap, the heap order property was maintained, by using the <code class="literal">sink()</code> and <code class="literal">arrange()</code> helper methods.</p><p> </p><p> </p><p>The heap data structure can be used to implement a sorting algorithm called the heap sort. As a recap, let's create a simple heap with the following items:</p><pre class="programlisting">    h = Heap() 
    unsorted_list = [4, 8, 7, 2, 9, 10, 5, 1, 3, 6] 
    for i in unsorted_list: 
        h.insert(i) 
    print("Unsorted list: {}".format(unsorted_list)) </pre><p>The heap, <code class="literal">h</code>, is created and the elements in the <code class="literal">unsorted_list</code> are inserted. After each method call to <code class="literal">insert</code>, the heap order property is restored by the subsequent call to the <code class="literal">float</code> method. After the loop is terminated, element <code class="literal">4</code> will be at the top of our heap.</p><p>The number of elements in our heap is <code class="literal">10</code>. If we call the <code class="literal">pop</code> method on the <code class="literal">h</code> heap object 10 times, and store the actual elements being popped, we end <span>up</span><a id="id325978977" class="indexterm"></a> with a sorted list. After each <code class="literal">pop</code> operation, the heap is <span>readjusted</span><a id="id325978969" class="indexterm"></a> to maintain the heap order property.</p><p>The <code class="literal">heap_sort</code> method is as follows:</p><pre class="programlisting">    class Heap: 
        ... 
        def heap_sort(self): 
            sorted_list = [] 
            for node in range(self.size): 
                n = self.pop() 
                sorted_list.append(n) 

            return sorted_list </pre><p>The <code class="literal">for</code> loop simply calls the <code class="literal">pop</code> method <code class="literal">self.size</code> number of times. Now, <code class="literal">sorted_list</code> will contain a sorted list of items after the loop terminates.</p><p>The <code class="literal">insert</code> method is called <span class="emphasis"><em>n</em></span> number of times. Together with the <code class="literal">arrange()</code> method, the <code class="literal">insert</code> operation takes a worst-case runtime of <code class="literal">O(n log n)</code>, as does the <code class="literal">pop</code> method. As such, this sorting algorithm incurs a worst-case runtime of <code class="literal">O(n log n)</code>.</p><p>A comparison of the complexities of different sorting algorithms is given in the <span>following</span><a id="id325855515" class="indexterm"></a> table:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Algorithm</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>worst-case</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>average-case</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>best-case</strong></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Bubble sort</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">O(n<sup>2</sup>)</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">O(n<sup>2</sup>)</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">O(n)</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Insertion sort</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">O(n<sup>2</sup>)</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">O(n<sup>2</sup>)</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">O(n)</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Selection sort</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">O(n<sup>2</sup>)</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">O(n<sup>2</sup>)</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">O(n<sup>2</sup>)</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Quicksort</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">O(n<sup>2</sup>)</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">O(n log n)</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">O(n log n)</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>heapsort</p></td><td style="border-right: 0.5pt solid ; "><p><code class="literal">O(n log n)</code></p></td><td style="border-right: 0.5pt solid ; "><p><code class="literal">O(n log n)</code></p></td><td style=""><p><code class="literal"> O(n Log n)</code></p></td></tr></tbody></table></div></div>