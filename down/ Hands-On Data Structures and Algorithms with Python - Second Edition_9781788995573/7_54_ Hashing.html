<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec56"></a>Hashing</h2></div></div><hr /></div><p>Hashing is a <span>concept</span><a id="id326336565" class="indexterm"></a> in which, when we give data of an arbitrary size to a function, we get a small simplified value. This function is called a <span class="strong"><strong>hash function</strong></span>. Hashing uses a <span>hash</span><a id="id325855515" class="indexterm"></a> function that maps the given data to another range of data, so that a new range of data can be used as an index in the hash table. More specifically, we will use hashing to convert strings into integers. In our discussions in this chapter, we are using strings to convert into integers, however, it can be any other data type which can be converted into integers. Let's look at an example to better understand the concept. We want to hash the expression <code class="literal">hello world</code>, that is, we want to get a numeric value that we could say <span class="emphasis"><em>represents</em></span> the string.</p><p>We can obtain the unique ordinal value of any character by using the <code class="literal">ord()</code> function. For example, the <code class="literal">ord('f')</code> function gives 102. Further, to get the hash of the whole string, we could just sum the ordinal numbers of each character in the string. See the following code snippet:</p><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; </strong></span>sum(map(ord, 'hello world'))
1116</pre><p>The obtained numeric value, <code class="literal">1116</code>, for the whole <code class="literal">hello world</code> string is called the <span class="strong"><strong>hash of the string</strong></span>. Consider the following diagram to see the ordinal value of each character in the string that results in the hash value <code class="literal">1116</code>: </p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/fcb3acc0-9b7d-4126-a922-11564bd0cdb5.png" /></div><p> </p><p> </p><p>The preceding approach is used to obtain the <span>hash</span><a id="id325860327" class="indexterm"></a> value for a given string and seems to work fine. However, note that we could change the order of the characters in the string and we would have got the same hash; see the following code snippet where we get the same hash value for the <code class="literal">world hello</code> string:</p><pre class="programlisting">&gt;&gt;&gt; sum(map(ord, 'world hello'))
1116</pre><p>Again, there would be the same hash value for the <code class="literal">gello xorld</code> string, as the sum of the ordinal values of the characters for this string would be the same since <code class="literal">g</code> has an ordinal value that is one less than that of <code class="literal">h</code>, and <code class="literal">x</code> has an ordinal value that is one greater than that of <code class="literal">w</code>. See the following code snippet:</p><pre class="programlisting">&gt;&gt;&gt; sum(map(ord, 'gello xorld'))
1116</pre><p>Look at the following diagram, where we can observe that the hash value for this string is again, <code class="literal">1116</code>:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/2ccd59d9-f6cd-4c9a-a70d-48526bbedfb1.png" /></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec47"></a>Perfect hashing functions</h3></div></div></div><p>A <span class="strong"><strong>perfect hashing function</strong></span> is the one by which we get a unique <span>hash</span><a id="id325896348" class="indexterm"></a> value for a given string (it can be any data type, here it is a string as we are limiting the discussion to strings for now). In practice, most of the hashing functions are imperfect and face collisions. This means that a hash function gives the same hash value to more than one string; that is undesirable because a perfect hash function should return a unique hash value to a string. Normally, hashing functions need to be very fast, so trying to create a function that gives us a unique hash value for each string is normally not possible. Hence, we accept this fact and we know that we may get some collisions, that is, two or more strings may have the same hash value. Therefore, we try to find a strategy to resolve the collisions rather than trying to find a perfect hash function.</p><p>To avoid the collisions of the previous example, we could, for example, add a multiplier, so that the ordinal value of each character is multiplied by a value that continuously increases as we progress in the string. Next, the hash value of the string is obtained by adding the multiplied ordinal value of each character. To better understand the concept, refer to the following diagram:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/a2383b6c-0c4c-400c-8c5f-c42a1eaa095e.png" /></div><p>In the preceding diagram, the ordinal value of each character is progressively multiplied by a number. Note that the last row is the result of multiplying the values; row two has the ordinal values of each character; row three shows the multiplier value; and, in row four, we get values by multiplying the values of row two and three so that <code class="literal">104 x 1</code> equals <code class="literal">104</code>. Finally, we add all of these multiplied values to get the hash value of the <code class="literal">hello world</code> string, that is, <code class="literal">6736</code>. </p><p>The implementation of this concept is shown in the following function:</p><pre class="programlisting">    def myhash(s): 
        mult = 1 
        hv = 0 
        for ch in s: 
            hv += mult * ord(ch) 
            mult += 1 
        return hv </pre><p>We can test this function on the strings that we used earlier, shown as follows:</p><pre class="programlisting">for item in ('hello world', 'world hello', 'gello xorld'): 
        print("{}: {}".format(item, myhash(item))) </pre><p>Running this program, we get the <span>following</span><a id="id325992237" class="indexterm"></a> output:</p><pre class="programlisting"><span class="strong"><strong>% python hashtest.py</strong></span>

<span class="strong"><strong>hello world: 6736</strong></span>
<span class="strong"><strong>world hello: 6616</strong></span>
<span class="strong"><strong>gello xorld: 6742</strong></span></pre><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p>We can see that, this time, we get different hash values for these three strings. Still, this is not a perfect hash. Let's try the strings, <code class="literal">ad</code> and <code class="literal">ga</code>:</p><pre class="programlisting"><span class="strong"><strong>% python hashtest.py</strong></span>

<span class="strong"><strong>ad: 297</strong></span>
<span class="strong"><strong>ga: 297</strong></span></pre><p>We still get the same hash value for two different strings. Therefore, we need to devise a strategy for resolving such collisions. We shall look at that shortly, but first, we will study an implementation of a hash table.</p></div></div>