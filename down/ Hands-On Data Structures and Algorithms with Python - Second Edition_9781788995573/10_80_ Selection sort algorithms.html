<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch10lvl1sec79"></a>Selection sort algorithms</h2></div></div><hr /></div><p>Another popular <span>sorting</span><a id="id326096181" class="indexterm"></a> algorithm is the selection sort. The selection <span>sorting</span><a id="id325989366" class="indexterm"></a> algorithm begins by finding the smallest element in the list, and interchanges it with the data stored at the first position in the list. Thus, it makes the sub-list sorted up to the first element. Next, the second smallest element, which is the smallest element in the remaining list, is identified and interchanged with the second position in the list. This makes the initial two elements sorted. The process is repeated, and the smallest element remaining in the list should be swapped with the element in the third index on the list. This means that the first three elements are now sorted. This process is repeated for <code class="literal">(n-1)</code> times to sort <code class="literal">n</code> items.</p><p>Let's look at an example to understand how the algorithm works. We'll sort the following list of 4 elements using the selection sort algorithm:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/a55c889c-4972-4390-9732-cf45d246afb3.png" /></div><p> </p><p>Starting at index <span class="strong"><strong>0</strong></span>, we search for the smallest item in the list that exists between index <span class="strong"><strong>1</strong></span>, and the index of the last element. When this element has been found, it is exchanged with the data found at index <span class="strong"><strong>0</strong></span>. We simply repeat this process until the list is fully sorted.</p><p>Searching for the smallest item within the list is an incremental process:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/1362ad03-f328-46fc-8137-583cb189526c.png" /></div><p>A comparison of elements <span class="strong"><strong>2</strong></span> and <span class="strong"><strong>5</strong></span> selects <span class="strong"><strong>2</strong></span>, as it is the lesser value among these <span>two</span><a id="id325967576" class="indexterm"></a> values, and thus, the two elements are swapped.</p><p>After the <span>swap</span><a id="id325855473" class="indexterm"></a> operation, the array looks like this:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/41a8e9ce-6e61-4f42-9a26-ae20fc9239d4.png" /></div><p>Further, at index <span class="strong"><strong>0</strong></span>, we compare <span class="strong"><strong>2</strong></span> with <span class="strong"><strong>65</strong></span>:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/6a281197-d4c7-41c4-8af1-70de4ac16ae7.png" /></div><p>Since <span class="strong"><strong>65</strong></span> is greater than <span class="strong"><strong>2</strong></span>, the two elements are not swapped. A further comparison is made between the element at index <span class="strong"><strong>0</strong></span>, which is <span class="strong"><strong>2</strong></span>, and the element at index <span class="strong"><strong>3</strong></span>, which is <span class="strong"><strong>10</strong></span>. No swap takes place in this case. When we get to the last element in the list, we will have the smallest element occupying index <span class="strong"><strong>0</strong></span>.</p><p>In the next iteration, we start comparing elements from position <span class="strong"><strong>1</strong></span> in the index. We repeat the whole process of comparing the element stored at index <span class="strong"><strong>1</strong></span> with all the elements, from index <span class="strong"><strong>2</strong></span> through to the last index. </p><p>The second iteration starts by comparing <span class="strong"><strong>5</strong></span> and <span class="strong"><strong>65</strong></span>, which will look like this:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/c02e5c3e-dd2e-4e47-af5a-9ab801653a15.png" /></div><p>Once we find out that the <span class="strong"><strong>5</strong></span> is the smallest value in the sub-list from indices <span class="strong"><strong>1</strong></span> to <span class="strong"><strong>3</strong></span>, we place it at index <span class="strong"><strong>1</strong></span>. Similarly, the next smallest element from the sub-lists <span class="strong"><strong>2</strong></span> and <span class="strong"><strong>3</strong></span> indices is placed at index <span class="strong"><strong>3</strong></span>.</p><p>The following is an <span>implementation</span><a id="id325896320" class="indexterm"></a> of the selection sort algorithm. The <span>argument</span><a id="id325896328" class="indexterm"></a> to the function is the unsorted list of items we want to put in ascending order of magnitude:</p><pre class="programlisting">    def selection_sort(unsorted_list): 

        size_of_list = len(unsorted_list) 

        for i in range(size_of_list): 
            for j in range(i+1, size_of_list): 

                if unsorted_list[j] &lt; unsorted_list[i]: 
                    temp = unsorted_list[i] 
                    unsorted_list[i] = unsorted_list[j] 
                    unsorted_list[j] = temp </pre><p>The algorithm begins by using the outer <code class="literal">for</code> loop to go through the list, <code class="literal">size_of_list</code>, a number of times. Because we pass <code class="literal">size_of_list</code> to the <code class="literal">range</code> method, it'll produce a sequence from <span class="strong"><strong>0</strong></span> through to <code class="literal">size_of_list-1</code>.</p><p> The inner loop is responsible for going through the list and swap elements if we encounter an element less than the element pointed to by <code class="literal">unsorted_list[i]</code>. Notice that the inner loop begins from <code class="literal">i+1</code> up to <code class="literal">size_of_list-1</code>.</p><p>The inner loop begins its search for the smallest element from <code class="literal">i+1</code>, but uses the <code class="literal">j</code> index:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/af944234-5ff5-4c6f-9406-4ef9699093e0.png" /></div><p>The preceding diagram shows the direction in which the algorithm searches for the next smallest item.</p><p>The selection sorting algorithm gives worst-case and best-case runtime complexities of <code class="literal">O(n2)</code>.</p></div>