<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec40"></a>Pointer structures</h2></div></div><hr /></div><p>Contrary to arrays, pointer structures are lists of items that can be <span>spread</span><a id="id326636275" class="indexterm"></a> out in memory. This is because each item contains one or more links to other items in the structure. The types of these links are dependent on the type of structures we have. If we are dealing with linked lists, then we will have links to the next (and possibly previous) items in the structure. In the case of a tree, we have parent-child links as well as sibling links. </p><p>There are several benefits to pointer structures. First of all, they don't require sequential storage space. Secondly, they can start small and grow arbitrarily as you add more nodes to the structure. However, this flexibility in pointers comes at a cost. We need additional space to store the address. For example, if you have a list of integers, each node is going to take up space by storing an integer, as well as an additional integer for storing the pointer to the next node.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec22"></a>Nodes</h3></div></div></div><p>At the <span>heart</span><a id="id326613542" class="indexterm"></a> of lists (and several other data structures) is the <span>concept</span><a id="id325895059" class="indexterm"></a> of a node. Before we go any further, let us consider this idea for a while.</p><p>To begin with, let us consider an example. We shall create a few strings:</p><pre class="programlisting">&gt;&gt;&gt; a = "eggs"
&gt;&gt;&gt; b = "ham"
&gt;&gt;&gt; c = "spam"</pre><p> </p><p>Now you have three variables, each with a unique name, a type, and a value. At the moment, there is no <span>way</span><a id="id325896325" class="indexterm"></a> to show the relationships between these variables. Nodes allow us to show how these variables relate to each other. A node is a container of data, together with <span>one</span><a id="id325896333" class="indexterm"></a> or more links to other nodes. A link is a pointer.</p><p>A simple type of node is one that has only a link to the next node. As we know about the pointers, the string is not actually stored in the node, but rather there is a pointer to the actual string. Consider the example in the following diagram, in which there are two nodes. The first node has a pointer to the string (<span class="strong"><strong>eggs</strong></span>) stored in the memory and another pointer that stores the address of another node:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/951d55e5-eff8-4926-a767-6fb3ab785ea1.png" /></div><p> </p><p>Thus, the storage requirement for this simple node is two memory addresses. The data attributes of the nodes are pointers to the strings <span class="strong"><strong>eggs</strong></span> and <span class="strong"><strong>ham</strong></span>.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec15"></a>Finding endpoints</h4></div></div></div><p>We have created three nodes—one containing <span class="strong"><strong>eggs</strong></span>, one <span class="strong"><strong>ham</strong></span>, and another <span class="strong"><strong>spam</strong></span>. The <span class="strong"><strong>eggs</strong></span>node points to the <span class="strong"><strong>ham</strong></span> node, which in turn points to the <span class="strong"><strong>spam</strong></span> node. But what does the <span class="strong"><strong>spam</strong></span> node point to? Since this is the last element in the list, we need to make sure its next member has a value that makes this clear.</p><p>If we make the last element <span>point</span><a id="id326168213" class="indexterm"></a> to nothing, then we make this fact clear. In Python, we will use the special value <span class="strong"><strong>None</strong></span> to denote nothing. Consider the following diagram. Node <span class="strong"><strong>B</strong></span> is the last element in the list, and thus it is pointing to <span class="strong"><strong>None</strong></span>:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/403f8374-5adc-474d-9516-f8167eccc77d.png" /></div><p>The last node has its next point pointing to <span class="strong"><strong>None</strong></span>. As such, it is the last node in the chain of nodes.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec23"></a>Node class</h3></div></div></div><p>Here is a simple node implementation of <span>what</span><a id="id326168380" class="indexterm"></a> we have discussed so far:</p><pre class="programlisting">class Node:

    def __init__ (self, data=None):
        self.data = data 
        self.next = None</pre><p>The <span class="strong"><strong>Next</strong></span> pointer is initialized to <code class="literal">None</code>, meaning that <span>unless</span><a id="id326366080" class="indexterm"></a> you change the value of <span class="strong"><strong>Next</strong></span>, the node is going to be an endpoint. This is a good idea, so that we do not forget to terminate the list properly.</p><p>You can add other things to the node class as you see fit. Just make sure that you keep in mind the distinction between nodes and data. If your node is going to contain customer data, then create a <code class="literal">Customer</code> class and put all the data there.</p><p>One thing you may want to do is implement the <code class="literal">_str_ </code> method so that it calls the <code class="literal">_str_</code> method of the contained object is called when the node object is passed to print:</p><pre class="programlisting">def _str_ (self):
   return str(data)</pre><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec16"></a>Other node types</h4></div></div></div><p>As we have already discussed a node that has a pointer to the <span>next</span><a id="id326366117" class="indexterm"></a> node to link the data items, however, it is probably the simplest type of node. Further, depending on our requirements, we can create a number of other types of nodes.</p><p>Sometimes we want to go from node <span class="strong"><strong>A</strong></span> to node <span class="strong"><strong>B</strong></span>, but at the same time we may need to go <span>from</span><a id="id326366134" class="indexterm"></a> node <span class="strong"><strong>B</strong></span> to node <span class="strong"><strong>A</strong></span>. In that case, we add a <span class="strong"><strong>Previous</strong></span> pointer in addition to the <span class="strong"><strong>Next</strong></span> pointer:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/3c73ca24-f429-4bab-8711-0a4be1ba382f.png" /></div><p>As you can see from the preceding diagram, we have created the<span class="emphasis"><em> </em></span><span class="strong"><strong>Previous</strong></span> pointer in addition to the data and the <span class="strong"><strong>Next</strong></span>pointer. It is also important to note that the <span class="strong"><strong>N</strong></span><span class="strong"><strong>ext</strong></span> pointer to <span class="strong"><strong>B</strong></span> is <span class="strong"><strong>None</strong></span>, and the <span class="strong"><strong>Previous</strong></span> pointer in node <span class="strong"><strong>A</strong></span> is also<span class="strong"><strong>None</strong></span>—that is to indicate that we have reached the boundary of our list at both endpoints. The first node <span class="strong"><strong>A</strong></span>'s previous pointer points to <span class="strong"><strong>None</strong></span> since it has no predecessor, just as the last item <span class="strong"><strong>B</strong></span>'s <span class="strong"><strong>Next</strong></span> pointer points to <span class="strong"><strong>None</strong></span> because it has no successor node.</p></div></div></div>