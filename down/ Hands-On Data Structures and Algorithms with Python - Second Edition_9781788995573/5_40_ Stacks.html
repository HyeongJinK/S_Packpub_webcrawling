<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec44"></a>Stacks</h2></div></div><hr /></div><p><span>A stack is a data structure th</span>at stores data, similar to a <span>stack</span><a id="id325985483" class="indexterm"></a> of plates in a kitchen. You can put a plate on the top of the stack, and when you need a plate, you take it from the top of the stack. The last plate that was added to the stack will be the first to be picked up from the stack. Similarly, a stack data structure allows us to store and read <span>data</span><a id="id326030640" class="indexterm"></a> from one end, and the element which is added last is picked up first. Thus, a stack is a <span class="strong"><strong>last in, first out</strong></span> (<span class="strong"><strong>LIFO</strong></span>) structure:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/c2f453f2-07e6-48c8-8585-7e92bb9fa585.png" /></div><p>The preceding diagram depicts a stack of plates. Adding a plate to the pile is only possible by leaving that plate on top of the pile. To remove a plate from the pile of plates means to remove the plate that is on top of the pile.</p><p>There are two primary operations that are performed on stacks—<code class="literal">push</code> and <code class="literal">pop</code>. When an element is added to the top of the stack, it is pushed onto the stack. When an element is to be picked up from the top of the stack, it is popped off the stack. Another operation that is used sometimes is <code class="literal">peek</code>, which makes it possible to see the element on top of the stack without popping it off.</p><p>Stacks are used for a number of things. One very common usage for stacks is to keep track of the return address during function calls. Let's imagine that we have the following program:</p><pre class="programlisting">def b(): 
    print('b') 

def a(): 
    b() 

a() 
print("done")</pre><p>When the program execution gets to the call to <code class="literal">a()</code>, the following happens:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>It first pushes the address of the current instruction onto the stack, then jumps to the definition of <code class="literal">a</code></li><li>Inside function <code class="literal">a()</code>, the function <code class="literal">b()</code>is called</li><li>And, the return address of the function <code class="literal">b()</code> is pushed onto the stack</li><li>Once the execution of the instructions in <code class="literal">b()</code>and the function are complete, the return address is popped off the stack, which takes us back to function <code class="literal">a()</code></li><li>When all the instructions in function <code class="literal">a</code> are completed, the return <span>address</span><a id="id326168222" class="indexterm"></a> is again popped off from the stack, which takes us back to the <code class="literal">main</code> function and the <code class="literal">print</code>statement</li></ol></div><p>Stacks are also used to pass data between functions. Consider the following example. Say you have the following function call somewhere in your code:</p><pre class="programlisting">   somefunc(14, 'eggs', 'ham', 'spam') </pre><p>What happens internally is that the values passed by the functions <code class="literal">14, 'eggs', 'ham'</code>, and <code class="literal">'spam'</code> will be pushed onto the stack, one at a time, as shown in the following diagram:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/be95fe48-cca4-47bc-bc8e-edcd47c5d002.png" /></div><p>When the code calls jump to the definition of the function, the values for <code class="literal">a, b, c, d</code> will be popped off the stack. The <code class="literal">spam</code> element will be popped off first and assigned to <code class="literal">d</code>, then <code class="literal">ham</code> will be assigned to <code class="literal">c</code>, and so on:</p><pre class="programlisting">    def somefunc(a, b, c, d): 
        print("function executed")</pre><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec27"></a>Stack implementation</h3></div></div></div><p>Stacks can be <span>implemented</span><a id="id326469174" class="indexterm"></a> in Python using node. We start off by creating a <code class="literal">node</code> class, as we did in the previous chapter with lists:</p><pre class="programlisting">class Node: 
    def __init__(self, data=None): 
        self.data = data 
        self.next = None </pre><p>As we discussed, a node holds data and a reference to the next item in a list. Here, we are going to implement a stack instead of a list; however, the same principle of nodes works here—nodes are linked together through references.</p><p>Now let us look at the <code class="literal">stack</code> class. It starts off in a similar way to a singly linked list. We will need two things to implement a stack using nodes:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>We first need to know the node which is at the top of the stack so that we will be able to apply the <code class="literal">push</code> and <code class="literal">pop</code> operations through this node.</li><li>We would also like to keep track of the number of nodes in the stack, so we add a <code class="literal">size</code> variable to the stack class. Consider the following code snippet for the stack class:</li></ol></div><pre class="programlisting">class Stack: 
    def __init__(self): 
        self.top = None 
        self.size = 0 </pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec28"></a>Push operation</h3></div></div></div><p>The <code class="literal">push</code> operation is an important operation on a stack; it is <span>used</span><a id="id326637660" class="indexterm"></a> to add an element at the top of the stack. We implement the push functionality in Python to understand how it works.  At first, we check if the stack already has some items in it or it is empty when we wish to add a new node in the stack.</p><p>If the stack already has some elements, then we have to do two things:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>The new node must have its next pointer pointing to the node that was at the top earlier.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>We put this new node at the top of the <span>stack</span><a id="id326637686" class="indexterm"></a> by pointing <code class="literal">self.top</code> to the newly added node. See the two instructions in the following diagram:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788995573/graphics/ed1801cf-7d57-4a4f-8189-371d80f9c008.png" /></div><p>If the existing stack is empty, and the new node to be added is the first element, we need to make this node the top node of the element. Thus, <code class="literal">self.top</code> will point to this new node. See the following diagram:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/9f2c2e5b-ce73-41db-9fd4-ebe1c707c4b8.png" /></div><p>The following is globally the complete implementation of the <code class="literal">push</code> operation in <code class="literal">stack</code>:</p><pre class="programlisting">   def push(self, data): 
       node = Node(data) 
       if self.top: 
           node.next = self.top 
           self.top = node                 
       else: 
           self.top = node 
       self.size += 1</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec29"></a>Pop operation</h3></div></div></div><p>Now, we need <span>another</span><a id="id326638812" class="indexterm"></a> important function of the stack, and that is the <code class="literal">pop</code> operation. It reads the topmost element of the stack and removes it from the stack. The <code class="literal">pop</code> operation returns the topmost element of the stack and returns <code class="literal">None</code> if the stack is empty. </p><p>To implement the <code class="literal">pop</code> operation on a stack:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>First, check if the stack is empty. The <code class="literal">pop</code> operation is not allowed on an empty stack.</li><li>If the stack is not empty, it can be checked if the top node has its <span class="strong"><strong>next</strong></span> attribute pointing to some other node. It means the stack has elements, and the topmost node is pointing to the next node in the stack. To apply the <code class="literal">pop</code> operation, we have to change the top pointer. The next node should be at the top. We do this by pointing <code class="literal">self.top</code> to <code class="literal">self.top.next</code>. See the following diagram to understand this:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788995573/graphics/90fe5a9b-c40e-400a-88d1-6fed0d4abd85.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>When there is only one node in the stack, the stack will be empty after the pop operation. We have to change the top pointer to <code class="literal">None</code>. See the following diagram:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788995573/graphics/216b397f-4d21-4411-8e3e-1ccbafb88075.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>Removing such a node results in <code class="literal">self.top</code> pointing to <code class="literal">None</code>:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788995573/graphics/1c482c21-1bf4-4060-a2d2-ad1bd2bb3c67.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>We also decrement the size of the <span>stack</span><a id="id326640985" class="indexterm"></a> by <code class="literal">1</code> if the stack is not empty. Here is the complete code for the <code class="literal">pop</code> operation for <code class="literal">stack</code> in Python:</li></ol></div><pre class="programlisting">    def pop(self): 
        if self.top: 
            data = self.top.data 
            self.size -= 1  
            if self.top.next: 
                self.top = self.top.next 
            else: 
                self.top = None 
            return data 
        else: 
            return None </pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec30"></a>Peek operation</h3></div></div></div><p>There is <span>another</span><a id="id326641014" class="indexterm"></a> important operation that can be applied on stacks—the <code class="literal">peek</code> method. This method returns the top element from the stack without deleting it from the stack. The only difference between <code class="literal">peek</code> and <code class="literal">pop</code> is that the <code class="literal">peek</code> method just returns the topmost element; however, in the case of a <code class="literal">pop</code> method, the topmost element is returned and also that element is deleted from the stack. </p><p>The pop operation allows us to look at the top element without changing the stack. This operation is very straightforward. If there is a top element, return its data; otherwise, return <code class="literal">None</code> (thus, the behavior of <code class="literal">peek</code> matches that of <code class="literal">pop</code>):</p><pre class="programlisting">    def peek(self): 
        if self.top 
            return self.top.data 
        else: 
            return None </pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec31"></a>Bracket-matching application</h3></div></div></div><p>Now let us look at an example application showing how we can use our stack implementation. We are going to write a little function that will verify whether a statement <span>containing</span><a id="id325609316" class="indexterm"></a> brackets—<code class="literal">(</code>, <code class="literal">[</code>,  or  <code class="literal">{</code>—is balanced, that is, whether the number of closing brackets matches the number of opening brackets. It will also ensure that one pair of brackets really is contained in another:</p><pre class="programlisting">    def check_brackets(statement): 
        stack = Stack() 
        for ch in statement: 
            if ch in ('{', '[', '('): 
                stack.push(ch) 
            if ch in ('}', ']', ')'): 
                last = stack.pop() 
            if last is '{' and ch is '}': 
                continue 
            elif last is '[' and ch is ']': 
                continue 
            elif last is '(' and ch is ')': 
                continue 
            else: 
                return False 
    if stack.size &gt; 0: 
        return False 
    else: 
        return True </pre><p>Our function parses each character in the statements passed to it. If it gets an open bracket, it pushes it onto the stack. If it gets a closing bracket, it pops the top element off the stack and compares the two brackets to make sure their types match, <code class="literal">(</code> should match <code class="literal">)</code>, <code class="literal">[</code> should match <code class="literal">]</code>, and <code class="literal">{</code> should match <code class="literal">}</code>. If they don't, we return <code class="literal">False</code>; otherwise, we continue parsing.</p><p>Once we reach the end of the statement, we need to do one last check. If the stack is empty, then it is fine and we can return <code class="literal">True</code>. But if the stack is not empty, then we have an opening bracket that does not have a matching closing bracket and we will return <code class="literal">False</code>. We can test the bracket-matcher with the following code:</p><pre class="programlisting">sl = ( 
   "{(foo)(bar)}[hello](((this)is)a)test", 
   "{(foo)(bar)}[hello](((this)is)atest", 
   "{(foo)(bar)}[hello](((this)is)a)test))" 
) 
for s in sl: 
   m = check_brackets(s) 
   print("{}: {}".format(s, m))</pre><p>Only the first of the three statements should match. And when we run the code, we get the following output:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/6e37a813-bfe1-4652-813c-547f61a4c3f5.png" /></div><p>The output of the preceding code is <code class="literal">True</code>, <code class="literal">False</code>, and <code class="literal">False</code>.   </p><p> In summary, the <code class="literal">push</code> and <code class="literal">pop</code> operations of the stack data structure attract a complexity of <span class="emphasis"><em>O(1)</em></span>. The stack data structure is simple; however, it is used to implement many functionalities in real-world applications. The back and forward buttons in the browser are implemented using the stacks. Stacks are also used to implement the undo and redo functionalities in word processors.</p></div></div>