<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec41"></a>Introducing lists</h2></div></div><hr /></div><p>The list is an important and <span>popular</span><a id="id325860337" class="indexterm"></a> data structure. There are three kinds of the list—singly linked list, doubly linked list, and circular linked list. We will discuss these data structures in more detail in this chapter. We will also be discussing various important operations such as the <code class="literal">append</code> operation, <code class="literal">delete</code> operation, and the <code class="literal">traversing</code> and <code class="literal">searching</code> operations that can be performed on these lists in subsequent subsections. </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec24"></a>Singly linked lists</h3></div></div></div><p>A singly linked list is a list with only one pointer between two successive nodes. It can only be <span>traversed</span><a id="id325855602" class="indexterm"></a> in a single direction; that is, you can go from the first node in the list to the last node, but you cannot move from the last node to the first node.</p><p>We can actually use the node class that we <span>created</span><a id="id325855587" class="indexterm"></a> earlier to implement a very simple singly linked list. For example, we create three nodes <code class="literal">n1</code>, <code class="literal">n2</code>, and <code class="literal">n3</code> that stores three strings:</p><pre class="programlisting">&gt;&gt;&gt; n1 = Node('eggs')
&gt;&gt;&gt; n2 = Node('ham')
&gt;&gt;&gt; n3 = Node('spam')</pre><p> </p><p>Next, we link the nodes together so that they form a chain:</p><pre class="programlisting">&gt;&gt;&gt; n1.next = n2
&gt;&gt;&gt; n2.next = n3</pre><p>To traverse the list, you could do something like the following. We start by setting the <code class="literal">current</code> variable to the first item in the list, and then we traverse the whole list through a loop as shown in the following code:</p><pre class="programlisting">current = n1  
while current:
     print(current.data)
     current = current.next</pre><p>In the loop, we print out the current <span>element</span><a id="id325578024" class="indexterm"></a> after which we set <code class="literal">current</code> to point to the next <span>element</span><a id="id325609271" class="indexterm"></a> in the list. We keep doing this until we have reached the end of the list.</p><p>There are, however, several problems with this simplistic list implementation:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">It requires too much manual work by the programmer</li><li style="list-style-type: disc">It is too error prone (this is a consequence of the first point)</li><li style="list-style-type: disc">Too much of the inner workings of the list is exposed to the programmer</li></ul></div><p>We are going to address all these issues in the following sections.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec17"></a>Singly linked list class</h4></div></div></div><p>A list is a separate concept from a node. We start by <span>creating</span><a id="id325609300" class="indexterm"></a> a very simple class to hold our list. We start with a constructor that holds a reference to the very first node in the list (that is <code class="literal">tail</code> in the following code). Since this list is initially empty, we will start by setting this reference to <code class="literal">None</code>:</p><pre class="programlisting">class SinglyLinkedList:
    def __init__ (self):
        self.tail = None</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec18"></a>The append operation</h4></div></div></div><p>The first operation that we need to perform is to <span>append</span><a id="id325609323" class="indexterm"></a> items to the list. This operation is sometimes called an insert operation. Here we get a chance to hide away the <code class="literal">Node</code> class. The user of our list class should really never have to interact with <code class="literal">Node</code> objects. These are purely for internal use.</p><p> </p><p>The first shot at an <code class="literal">append()</code> method may look like this:</p><pre class="programlisting">class SinglyLinkedList:
    # ...
    def append(self, data):
         # Encapsulate the data in a Node 
         node = Node(data)
         if self.tail == None:
             self.tail = node 
         else:
             current = self.tail 
             while current.next:
                 current = current.next 
             current.next = node</pre><p>We encapsulate data in a node so that it has the <span>next</span><a id="id325644854" class="indexterm"></a> pointer attribute. From here, we check if there are any existing nodes in the list (that is, whether <code class="literal">self.tail</code> points to a <code class="literal">Node</code> or not). If there is <code class="literal">None</code>, we make the new node the first node of the list; otherwise, we find the insertion point by traversing the list to the last node, updating the next pointer of the last node to the new node.</p><p>Consider the following example code to append three nodes:</p><pre class="programlisting">&gt;&gt;&gt; words = SinglyLinkedList()
&gt;&gt;&gt; words.append('egg')
&gt;&gt;&gt; words.append('ham')
&gt;&gt;&gt; words.append('spam')</pre><p>List traversal will work as we discussed before. You will get the first element of the list from the list itself, and then traverse the list through the <code class="literal">next</code> pointer:</p><pre class="programlisting">&gt;&gt;&gt; current = words.tail
&gt;&gt;&gt; while current:
        print(current.data)
        current = current.next</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec19"></a>A faster append operation</h4></div></div></div><p>There is a big problem with the <span>append</span><a id="id325837793" class="indexterm"></a> method in the previous section: it has to traverse the entire list to find the insertion point. This may not be a problem when there are just a few items in the list, but it will be a big problem when the list is long, as we would need to traverse the whole list to add an item every time. Each append will be slightly slower than the previous one. The current implementation for the append operation is slowed down by  <code class="literal">O(n)</code>, which is not desirable in the case of a long list.</p><p> </p><p>To fix this, we store not only a reference to the first node in the list but also a reference to the last node. That way, we can quickly append a new node at the end of the list. The worst-case running time of the append operation is now reduced from <code class="literal">O(n)</code> to <code class="literal">O(1)</code>. All we have to do is make sure the <span>previous</span><a id="id325837816" class="indexterm"></a> last node points to the new node that is about to be appended to the list. Here is our updated code:</p><pre class="programlisting">class SinglyLinkedList:
    def init (self):
        # ...
        self.tail = None

    def append(self, data):
        node = Node(data)
       if self.head:
            self.head.next = node 
            self.head = node
       else:
            self.tail = node 
            self.head = node</pre><p>Take note of the convention being used. The point at which we append new nodes is through <code class="literal">self.head</code>. The <code class="literal">self.tail</code> variable points to the first node in the list.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec20"></a>Getting the size of the list</h4></div></div></div><p>We would like to be able to get the <span>size</span><a id="id325837846" class="indexterm"></a> of the list by counting the number of nodes. One way we could do this is by traversing the entire list and increasing a counter as we go along:</p><pre class="programlisting">def size(self):
 count = 0
 current = self.tail
 while current:
     count += 1
     current = current.next 
 return count</pre><p>This works fine. However, list traversal is potentially an expensive operation that we should avoid wherever we can. So instead, we shall opt for another rewrite of the method. We add a size member to the <code class="literal">SinglyLinkedList</code> class, initializing it to <code class="literal">0</code> in the constructor. Then we increment the size by one in the append method:</p><pre class="programlisting">class SinglyLinkedList:
    def init (self):
        # ...</pre><p> </p><p> </p><pre class="programlisting">
        self.size = 0

    def append(self, data):
        # ...
        self.size += 1</pre><p>Because we are now only reading the size attribute of the node object, and not using a loop to count the number of nodes in the list, we reduce the worst-case running time from <code class="literal">O(n)</code> to <code class="literal">O(1)</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec21"></a>Improving list traversal</h4></div></div></div><p>If you will notice in the earlier of the list traversal, where <span>we</span><a id="id325855490" class="indexterm"></a> are exposing the node class to the client/user. However, it is desirable that the client node should not interact with the node object.  We need to use <code class="literal">node.data</code> to get the contents of the node and <code class="literal">node.next</code> to get the next node. We can access the data by creating a method that returns a generator. It looks as follows:</p><pre class="programlisting">def iter(self):
    current = self.tail 
    while current:
        val = current.data 
        current = current.next 
        yield val</pre><p>Now, list traversal is much simpler and looks a lot better as well. We can completely ignore the fact that there is anything called a node outside of the list:</p><pre class="programlisting">for word in words.iter():
    print(word)</pre><p>Notice that since the <code class="literal">iter()</code> method yields the data member of the node, our client code doesn't need to worry about that at all.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec22"></a>Deleting nodes</h4></div></div></div><p>Another common operation that you will <span>perform</span><a id="id326420958" class="indexterm"></a> on a list is to delete nodes. This may seem simple, but we first have to decide how to select a node for deletion. Is it going to be determined by the index number or by the data the node contains? Here, we will choose to delete a node depending on the data it contains.</p><p>The following is a diagram of a special case <span>considered</span><a id="id326420976" class="indexterm"></a> when deleting a node from the list:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/171528b6-ff82-46a9-bc13-3af7b1e3a398.png" /></div><p>When we want to delete a node that is between two other nodes, all we have to do is we make the previous node point to the successor of its next node that is to be deleted. That is, we simply cut the node to be deleted out of the chain and point directly to the next node as shown in the preceding diagram.</p><p>Here is what the implementation of the <code class="literal">delete()</code> method may look like:</p><pre class="programlisting">def delete(self, data): 
    current = self.tail 
    prev = self.tail 
    while current:
        if current.data == data:
            if current == self.tail:
                self.tail = current.next 
            else:
                prev.next = current.next 
            self.count -= 1
            return
        prev = current
        current = current.next</pre><p>The <code class="literal">delete</code> operation to remove a node has the time complexity <code class="literal">O(n).</code></p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec23"></a>List search</h4></div></div></div><p>We may also need a way to check whether a <span>list</span><a id="id325844858" class="indexterm"></a> contains an item. This method is fairly easy to implement thanks to the <code class="literal">iter()</code> method we previously wrote. Each pass of the loop compares the current data to the data being searched. If a match is found, <code class="literal">True</code> is returned, or else <code class="literal">False</code> is returned:</p><pre class="programlisting">def search(self, data):
    for node in self.iter():
        if data == node:
            return True 
    return False</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec24"></a>Clearing a list</h4></div></div></div><p>We may need to clear a <span>list</span><a id="id325844889" class="indexterm"></a> quickly; there is a very simple way to do it. We can clear a list by simply clearing the pointer head and tail by setting them to <code class="literal">None</code>:</p><pre class="programlisting">def clear(self):
    """ Clear the entire list. """
    self.tail = None
    self.head = None</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec25"></a>Doubly linked lists</h3></div></div></div><p>We have discussed the singly linked list and the important operation that can be performed on it. Now, we will be focusing on the topic of a doubly linked list in this section. </p><p> </p><p>A doubly linked list is quite similar to the <span>singly</span><a id="id325844917" class="indexterm"></a> linked list in the sense that we use the same <span>fundamental</span><a id="id325848203" class="indexterm"></a> concept of string nodes together, as we did in a singly linked list. The only difference between a singly linked list and a doubly linked list is that in a singly linked list, there is only one link between each successive node, whereas, in a doubly linked list, we have two pointers—a pointer to the next node and a pointer to the previous node. See the following diagram of a <span class="emphasis"><em>node</em></span>; there is a pointer to the next node and the previous node, which are set to <code class="literal">None</code> as there is no node attached to this node. Consider the following diagram:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/160f0a31-dd75-4b72-bb00-7319011fd721.png" /></div><p>A node in a singly linked list can only determine the next node associated with it. However, there is no way or link to go back from this referenced node. The direction of flow is only one way.</p><p>In a doubly linked list, we solve this issue and include the ability not only to reference the next node but also to reference the previous node. Consider the following example diagram to understand the nature of the linkages between two successive nodes. Here, node <span class="strong"><strong>A</strong></span> is referencing node <span class="strong"><strong>B</strong></span>; in addition, there is also a link back to node <span class="strong"><strong>A</strong></span>:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/f27e84d1-3ef3-4f57-a707-dd5669d1acac.png" /></div><p>With the existence of two pointers that point to the next and previous nodes, doubly linked lists become equipped with certain capabilities.</p><p>Doubly linked lists can be traversed in any direction. A node in a doubly linked list can be easily referred to its previous node whenever required without having a variable to keep track of that node. However, in a singly linked list, it may be difficult to move back to the start or beginning of the list in order to make some changes at the start of the list, which is very easy now in the case of a doubly linked list.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec25"></a>A doubly linked list node</h4></div></div></div><p>The Python code to create a doubly <span>linked</span><a id="id325848267" class="indexterm"></a> list node includes its initializing methods, the <code class="literal">prev</code> pointer, the <code class="literal">next</code> pointer, and the <code class="literal">data</code> instance variables. When a node is newly created, all these variables default to <code class="literal">None</code>:</p><pre class="programlisting">class Node(object):
    def __init__ (self, data=None, next=None, prev=None):
       self.data = data 
       self.next = next 
       self.prev = prev</pre><p>The <code class="literal">prev</code> variable has a reference to the previous node, while the <code class="literal">next</code> variable keeps the reference to the next node, and the <code class="literal">data</code> variable stores the data.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec26"></a>Doubly linked list class</h4></div></div></div><p>The doubly linked list class captures the data on which our functions will be operating. For the <code class="literal">size</code> method, we set the count instance variable to <code class="literal">0</code>; it can be used to keep track of the number of items in the <span>linked</span><a id="id325896276" class="indexterm"></a> list. <code class="literal">head</code> and <code class="literal">tail</code> will point to the head and tail of the list when we begin to insert nodes into the list. Consider the following Python code for creating a class:</p><pre class="programlisting">class DoublyLinkedList(object):
    def init (self): 
        self.head = None
        self.tail = None
        self.count = 0</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note5"></a>Note</h3><p>We adopt a new convention where <code class="literal">self.head</code> points to the beginner node of the list and <code class="literal">self.tail</code> points to the latest node added to the list. This is contrary to the convention we used in the singly linked list. There are no fixed rules as to the naming of the head and tail node pointers.</p></div><p> </p><p>Doubly linked lists also require functionalities that return the size of the list, insert items into the list, and also delete nodes from the list. We will be discussing and providing important functionalities and code on the doubly linked list in the following subsections. Let's start with the append operation.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec27"></a>Append operation</h4></div></div></div><p>The <code class="literal">append</code> operation is used to add an element at the end of a list. It is important to check whether the <code class="literal">head</code> of the list is <code class="literal">None</code>. If it is <code class="literal">None</code>, it means that the list is empty, or else the list has some nodes and a new node will be appended to the list. If a new node is to be added to the empty list, it should have the <code class="literal">head</code> pointing to the newly created node, and the tail of the list should also point at this newly created node through <code class="literal">head</code>. By the end of these series of steps, the head and tail will now be pointing to the same node. The following diagram illustrates the <code class="literal">head</code> and <code class="literal">tail</code> pointers of the doubly <span>linked</span><a id="id325910513" class="indexterm"></a> list when a new node is added to an empty list:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/aca81c1c-ec9c-4906-b34f-f52f765e6aaf.png" /></div><p>The following code is used to append an item to the doubly linked list:</p><pre class="programlisting">def append(self, data):
    """ Append an item to the list. """

    new_node = Node(data, None, None)
    if self.head is None:
        self.head = new_node
        self.tail = self.head
    else:
        new_node.prev = self.tail 
        self.tail.next = new_node 
        self.tail = new_node
        self.count += 1</pre><p> </p><p>The <code class="literal">If</code> part of the preceding program is for adding a node to the empty node; the <code class="literal">else</code> part of the preceding program will be executed if the list is not empty. If the new node is to be added to a list, the new node's previous variable is to be set to the tail of the list:</p><pre class="programlisting">new_node.prev = self.tail</pre><p>The tail's next pointer (or variable) has to be set to the new node:</p><pre class="programlisting">self.tail.next = new_node</pre><p>Lastly, we update the tail pointer to point to the new node:</p><pre class="programlisting">self.tail = new_node</pre><p>Since an append operation increases the number of nodes by one, we increase the counter by one:</p><pre class="programlisting">self.count += 1</pre><p>A visual representation of the append <span>operation</span><a id="id325914400" class="indexterm"></a> to an existing list is shown in the following diagram:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/3996c2a6-471d-4dc3-9f22-c7e2ce329f66.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec28"></a>The delete operation</h4></div></div></div><p>The deletion operation is easier in the doubly <span>linked</span><a id="id325920195" class="indexterm"></a> list compared to the singly linked list. </p><p>Unlike a singly linked list, where we needed to keep track of the previously encountered node any time we traverse the whole length of the list, the doubly linked list avoids that whole step. This is made possible by the use of the previous pointer.</p><p> </p><p>The <code class="literal">delete</code> operation in a doubly linked list can <span>encounter</span><a id="id325920214" class="indexterm"></a> the following four scenarios:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">The search item to be deleted is not found in the list</li><li style="list-style-type: disc">The search item to be deleted is located at the start of the list</li><li style="list-style-type: disc">The search item to be deleted is found at the tail end of the list</li><li style="list-style-type: disc">The search item to be deleted is located in the middle of the list</li></ul></div><p>The node to be deleted is identified by matching the data instance variable with the data that is passed to the method. If the data matches the data variable of a node, that matching node will be deleted. Following is the complete code to delete a node from the doubly linked list. We'll discuss each part of this code step by step:</p><pre class="programlisting">def delete(self, data):
    """ Delete a node from the list. """ 
    current = self.head 
    node_deleted = False 
    if current is None:       #Item to be deleted is not found in the list
        node_deleted = False 

    elif current.data == data:   #Item to be deleted is found at starting of list
        self.head = current.next  
        self.head.prev = None 
        node_deleted = True 

    elif self.tail.data == data:   #Item to be deleted is found at the end of list.
        self.tail = self.tail.prev  
        self.tail.next = None 
        node_deleted = True 
    else: 
        while current:          #search item to be deleted, and delete that node
            if current.data == data: 
                current.prev.next = current.next  
                current.next.prev = current.prev 
                node_deleted = True 
            current = current.next 

    if node_deleted: 
        self.count -= 1</pre><p> </p><p> </p><p>Initially, we create a <code class="literal">node_deleted</code> variable to denote the deleted node in the list and this is initialized to <code class="literal">False</code>.  The <code class="literal">node_deleted</code> variable is set to <code class="literal">True</code> if a matching node is found and subsequently removed. In the delete method, the <code class="literal">current</code> variable is initially set to the <code class="literal">head</code> of the list (that is, it points to the <code class="literal">self.head</code> of the list). See the following code fragment:</p><pre class="programlisting">def delete(self, data): 
    current = self.head 
    node_deleted = False
    ...</pre><p>Next, we use a set of <code class="literal">if...else</code> statements to search various parts of the list to find out the node with the specified data that is to be deleted.</p><p>First of all,  we search for the data to be deleted at the <code class="literal">head</code> node and if the data is matched at the <code class="literal">head</code> node, this node would be deleted. Since <code class="literal">current</code> is pointing at <code class="literal">head</code>, if <code class="literal">current</code> is <code class="literal">None</code>, it means that the list is empty and has no nodes to find the node to be deleted. The following is its code fragment:</p><pre class="programlisting">if current is None:
  node_deleted = False</pre><p>However, if <code class="literal">current</code> (which now points to head) <span>contains</span><a id="id325936496" class="indexterm"></a> the data being searched for, it means that we found the data to be deleted at the <code class="literal">head</code> node, then <code class="literal">self.head</code> is marked to point to the <code class="literal">current</code> node. Since there is no node behind <code class="literal">head</code> now, <code class="literal">self.head.prev</code> is set to <code class="literal">None</code>. Consider the following code snippet for this:</p><pre class="programlisting">elif current.data == data: 
    self.head = current.next 
    self.head.prev = None
    node_deleted = True</pre><p>Similarly, if the node that is to be deleted is found at the <code class="literal">tail</code> end of the list, we delete the last node by setting its previous node pointing to <code class="literal">None</code>. This is the third possible scenario in the <code class="literal">delete</code> operation in a doubly linked list that searches for the node to be deleted might be found at the end of the list. The <code class="literal">self.tail</code> is set to point to <code class="literal">self.tail.prev</code>, and <code class="literal">self.tail.next</code> is set to <code class="literal">None</code> as there is no node afterward. Consider the following code fragment for this:</p><pre class="programlisting">elif self.tail.data == data:
   self.tail = self.tail.prev 
   self.tail.next = None
   node_deleted = True</pre><p> </p><p>Lastly, we search for the node to be deleted by looping through the whole list of the nodes. If the data that is to be deleted is matched with a node, that node will be deleted. To delete a node, we make the previous node of the <code class="literal">current</code> node to point to the current's next node using the code  <code class="literal">current.prev.next = current.next</code>. After that step, we make the current's next node to point to the previous node of the <code class="literal">current</code> node using <code class="literal">current.next.prev = current.prev</code>. Consider the following code snippet for this:</p><pre class="programlisting">else
    while current:
       if current.data == data:
             current.prev.next = current.next 
             current.next.prev = current.prev 
             node_deleted = True
       current = current.next</pre><p> To better understand the concept of a delete operation in a doubly <span>linked</span><a id="id325951739" class="indexterm"></a> list, consider the following example diagram. In the following diagram, there are three nodes, <span class="strong"><strong>A</strong></span>, <span class="strong"><strong>B</strong></span>, and <span class="strong"><strong>C</strong></span>. To delete node <span class="strong"><strong>B</strong></span> in the middle of the list, we will essentially make <span class="strong"><strong>A</strong></span> point to node <span class="strong"><strong>C</strong></span> as its next node, while making <span class="strong"><strong>C</strong></span> point to <span class="strong"><strong>A</strong></span> as its previous node:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/3c111721-d7ff-45d7-8cbb-a4a21dc8d17f.png" /></div><p> </p><p>After such an operation, we end up with the following list:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/f2d2daab-fc26-4fe4-b955-3c41b42f9d95.png" /></div><p>Finally, the <code class="literal">node_delete</code> variable is then checked to find out if a node is actually deleted or not. If any node is deleted then we decrease the count variable by <code class="literal">1</code>, and this keeps track of the total number of nodes in the list. See the following code fragment that decrements the count variable by <code class="literal">1</code> in case any node is deleted:</p><pre class="programlisting">if node_deleted:
  self.count -= 1</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec29"></a>List search</h4></div></div></div><p>The search for an item in a doubly <span>linked</span><a id="id325979105" class="indexterm"></a> list is similar to the way we did it in the singly linked list. We use the <code class="literal">iter()</code> method to check the data in all the nodes. As we run a loop through all the data in the list, each node is matched with the data passed in the <code class="literal">contain</code> method. If we find the item in the list, <code class="literal">True</code> is returned, denoting that the item is found, otherwise <code class="literal">False</code> is returned, which means the item was not found in the list. The Python code for this is as follows:  </p><pre class="programlisting">def contain(self, data):
    for node_data in self.iter():
       if data == node_data:
       return True 
    return False</pre><p>The append operation in a doubly linked list has running time complexity <code class="literal">O(1)</code>and the delete operation has the complexity  <code class="literal">O(n)</code>.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec26"></a>Circular lists</h3></div></div></div><p>A circular linked list is a special case of a linked list. In a circular <span>linked</span><a id="id325990582" class="indexterm"></a> list, the endpoints are connected to each other. It means that the last node in the list points back to the first node. In other words, we can say that in circular linked lists all the nodes point to the next node (and the previous node in the case of a doubly linked list) and there is no end node, thus no node will point to <code class="literal">Null</code>. Circular lists can be based on both singly and doubly linked lists. In the case of a doubly linked circular list, the first node points to the last node and the last node points back to the first node. Consider the following diagram for the circular linked list, based on a <span>singly</span><a id="id325990594" class="indexterm"></a> linked list where the last node <span class="strong"><strong>C</strong></span> is again connected to the first node <span class="strong"><strong>A</strong></span>, thus making a circular list:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/4b61ae05-ff28-4d66-bf33-155aeb131067.png" /></div><p>The following diagram shows the concept of the circular linked list based on a doubly linked list where the last node <span class="strong"><strong>C</strong></span> is again connected to the first node <span class="strong"><strong>A</strong></span> through the <code class="literal">next</code> pointer. The node <span class="strong"><strong>A</strong></span> is also connected to the node <span class="strong"><strong>C</strong></span> through, <code class="literal">previous</code> pointer, thus making a circular list:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/f589b8d5-a376-4b72-bdda-fc645e34978b.png" /></div><p>Here, we are going to look at an implementation of a singly linked circular list. It should be straightforward to implement a doubly linked circular list once we understand the basic concepts.</p><p>We can reuse the node class that we created in the subsection—singly linked lists. As a matter of fact, we can reuse most parts of the <code class="literal">SinglyLinkedList</code> class as well. So we are going to focus on the methods where the circular list implementation differs from the normal singly linked list.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec30"></a>Appending elements</h4></div></div></div><p>To append an element to the circular list in a singly linked list, we have to just include a new functionality so that the newly added or appended node points back to the <code class="literal">tail</code> node. This is demonstrated in the following code. There is one extra line as compared to the singly <span>linked</span><a id="id325990677" class="indexterm"></a> list implementation, which is shown in bold font:</p><pre class="programlisting">def append(self, data): 
    node = Node(data)
    if self.head:
        self.head.next = node 
        self.head = node
    else:
       self.head = node
       self.tail = node

<span class="strong"><strong>self.head.next = self.tail</strong></span>
    self.size += 1</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec31"></a>Deleting an element in a circular list</h4></div></div></div><p>To delete a node in a circular list, it looks like we can do it similarly to how we did in the case of the append operation—simply make sure that <code class="literal">head</code> points to the <code class="literal">tail</code>. There is just a single line that needs to change in the delete operation. It is only when we remove the <code class="literal">tail</code> node that we need to make sure that the <code class="literal">head</code> node is updated to point to the new tail node. This would give us the following implementation (the bold font code line is an addition to the delete operation implementation in the singly <span>linked</span><a id="id326007098" class="indexterm"></a> list):</p><pre class="programlisting">def delete(self, data): 
     current = self.tail 
     prev = self.tail 
       while current:
           if current.data == data:
              if current == self.tail:
                  self.tail = current.next 
<span class="strong"><strong>self.head.next = self.tail</strong></span>
              else:
                  prev.next = current.next
              self.size -= 1 
              return
           prev = current
           current = current.next</pre><p>However, there is a serious problem with this code. In the case of a circular list, we cannot loop until <code class="literal">current</code> becomes <code class="literal">None</code>, since the current node will never point to the <code class="literal">None</code> in case of circular linked lists. If you delete an existing node, you won't see this, but try deleting a nonexistent node and you will get stuck in an indefinite loop.</p><p>We thus need to find a different way to control the <code class="literal">while</code> loop. We cannot check whether <code class="literal">current</code> has reached <code class="literal">head</code>, because then it will never check the last node. But we could use <code class="literal">prev</code>, since it lags behind <code class="literal">current</code> by one node. However, there is a special case. The very first loop iteration, <code class="literal">current</code>, and <code class="literal">prev</code>, will point to the same node, namely the tail node. We want to ensure that the loop runs here since we need to take the one node list into consideration. The updated delete method now looks as follows:</p><pre class="programlisting">def delete(self, data): 
    current = self.tail 
    prev = self.tail
    while prev == current or prev != self.head:
        if current.data == data:
            if current == self.tail: 
                self.tail = current.next 
                self.head.next = self.tail
            else:
                prev.next = current.next 
                self.size -= 1
    return
    prev = current
    current = current.next</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec32"></a>Iterating through a circular list</h4></div></div></div><p>To traverse the circular <span>linked</span><a id="id326019554" class="indexterm"></a> list, it is very convenient as we don't need to look for the starting point. We can start anywhere, and we just need to carefully stop traversing when we reach the same node again. We can use the same <code class="literal">iter()</code> method, which we discussed at the start of this chapter. It should work for our circular list; the only difference is that we have to mention an exit condition when we are iterating through the circular list, or otherwise the program will get stuck in a loop and it will run indefinitely. We can make an exit condition by using a counter variable. Consider the following example code:</p><pre class="programlisting">words = CircularList() 
words.append('eggs') 
words.append('ham') 
words.append('spam')
counter = 0

for word in words.iter():
    print(word)
    counter += 1
    if counter &gt; 1000:
        break</pre><p>Once we have printed out 1,000 elements, we break out of the loop.</p></div></div></div>