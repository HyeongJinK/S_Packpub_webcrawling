<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec21"></a>Numeric types</h2></div></div><hr /></div><p>Number types include integers (<code class="literal">int</code>), that is, whole numbers of unlimited range, floating-point numbers (<code class="literal">float</code>), complex numbers (<code class="literal">complex</code>), which are represented by two float numbers, and Boolean (<code class="literal">bool</code>) in Python. Python provides the <code class="literal">int</code> data type that <span>allows</span><a id="id325585008" class="indexterm"></a> standard arithmetic operators (<code class="literal">+</code>, <code class="literal">-</code>, <code class="literal">*</code> and <code class="literal">/</code> ) to work on them, similar to other programming languages. A Boolean data type has two possible values, <code class="literal">True</code> and <code class="literal">False</code>. These values are mapped to <code class="literal">1</code> and <code class="literal">0</code>, respectively. Let's consider an example:</p><pre class="programlisting">&gt;&gt;&gt; a=4; b=5   # Operator (=) assigns the value to variable
&gt;&gt;&gt;print(a, "is of type", type(a))
4 is of type 
&lt;class 'int'&gt;
&gt;&gt;&gt; 9/5  
1.8
&gt;&gt;&gt;c= b/a  <span class="emphasis"><em># division returns a floating point number
</em></span><span class="emphasis"><em>&gt;&gt;&gt;</em></span> print(c, "is of type", type(c))
1.25 is of type &lt;class 'float'&gt;
&gt;&gt;&gt; c   # No need to explicitly declare the datatype
1.25</pre><p>The <code class="literal">a</code> and <code class="literal">b</code> variables are of the <code class="literal">int</code> type and <code class="literal">c</code> is a floating-point type. The division operator (<code class="literal">/</code>) always returns a <code class="literal">float</code> type; however, if you wish to get the <code class="literal">int</code> type after division, you can use the floor division operator (<code class="literal">//</code>), which discards any fractional part and will return the largest integer value that is less than or equal to <code class="literal">x</code>. Consider the following example:</p><pre class="programlisting">&gt;&gt;&gt; a=4; b=5   
&gt;&gt;&gt;d= b//a
<span class="emphasis"><em>&gt;&gt;&gt;</em></span> print(d, "is of type", type(d))<span class="strong"><strong>
</strong></span>1 is of type &lt;class 'int'&gt;
&gt;&gt;&gt;7/5  # true division
1.4
&gt;&gt;&gt; -7//5  # floor division operator
-2</pre><p>It is advised that readers use the division operator carefully, as its function differs according to the Python version. In Python 2, the division operator returns only <code class="literal">integer</code>, not <code class="literal">float</code>.</p><p> </p><p>The exponent operator (<code class="literal">**</code>) can be used to <span>get</span><a id="id325979090" class="indexterm"></a> the power of a number (for example, <code class="literal">x ** y</code>), and the modulus operator (<code class="literal">%</code>) returns the remainder of the division (for example,<code class="literal">a% b</code> returns the remainder of <code class="literal">a/b</code>):</p><pre class="programlisting">&gt;&gt;&gt; a=7; b=5<span class="strong"><strong></strong></span>
&gt;&gt;&gt; e= b**a  # The operator (**)calculates power 
&gt;&gt;&gt;e
78125
&gt;&gt;&gt;a%b
2</pre><p>Complex numbers are <span>represented</span><a id="id325979158" class="indexterm"></a> by two floating-point numbers. They are <span>assigned</span><a id="id325979164" class="indexterm"></a> using the <code class="literal">j</code> operator to signify the imaginary part of the complex number. We can access the real and imaginary parts with <code class="literal">f.real</code> and <code class="literal">f.imag</code>, respectively, as shown in the following code snippet. Complex numbers are generally used for scientific computations. Python supports addition, subtraction, multiplication, power, conjugates, and so forth on complex numbers, as shown in the following:</p><pre class="programlisting">&gt;&gt;&gt; f=3+5j
&gt;&gt;&gt;print(f, "is of type", type(f))<span class="strong"><strong>
</strong></span>(3+5j) is of type &lt;class 'complex'&gt;
&gt;&gt;&gt; f.real
3.0
&gt;&gt;&gt; f.imag
5.0
&gt;&gt;&gt; f*2   # multiplication
(6+10j)
&gt;&gt;&gt; f+3  # addition
(6+5j)
&gt;&gt;&gt; f -1  # subtraction
(2+5j)  </pre><p><span>In</span> Python, Boolean types are <span>represented</span><a id="id325979197" class="indexterm"></a> using  truth values, that is, <code class="literal">True</code> and <code class="literal">False</code>; it's similar to <code class="literal">0</code> and <code class="literal">1</code><span class="emphasis"><em>.</em></span> There is a <code class="literal">bool</code> class in Python, which returns <code class="literal">True</code> or <code class="literal">False</code>. Boolean values can be combined with logical operators such as <code class="literal">and</code>, <code class="literal">or</code>, and <code class="literal">not</code>:</p><pre class="programlisting">&gt;&gt;&gt;bool(2)
True
&gt;&gt;&gt;bool(-2)
True
&gt;&gt;&gt;bool(0)
False</pre><p> </p><p><span>A</span> Boolean operation returns either <code class="literal">True</code> or <code class="literal">False</code>. Boolean operations are <span>ordered</span><a id="id326030435" class="indexterm"></a> in priority, so if more than one Boolean operation occurs in an expression, the operation <span>with</span><a id="id326096194" class="indexterm"></a> the highest priority will occur first. The following table outlines the three Boolean operators in descending order of <span>priority</span>:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Operator</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Example</strong></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">not x</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>It returns <code class="literal">False</code> if <code class="literal">x</code> is <code class="literal">True</code>, and returns <code class="literal">True</code> if <code class="literal">x</code> is <code class="literal">False</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">x and y</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>It returns <code class="literal">True</code> if <code class="literal">x</code> and <code class="literal">y</code>are both <code class="literal">True</code>; otherwise, it returns <code class="literal">False</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">x or</code> <code class="literal">y</code></p></td><td style=""><p>It returns <code class="literal">True</code> if either <code class="literal">x</code> or <code class="literal">y</code> is <code class="literal">True</code>; otherwise, it returns <code class="literal">False</code>.</p></td></tr></tbody></table></div><p> </p><p>Python is very efficient when evaluating Boolean expressions as it will only evaluate an operator if it needs to. For example, if <code class="literal">x</code> is <code class="literal">True</code> in an expression <code class="literal">x <span>or</span> y</code>, then there is no need to evaluate <code class="literal">y</code> since the expression is <code class="literal">True</code> anyway—that is why in Python the <code class="literal">y</code> is not evaluated. Similarly, in an expression <code class="literal">x and y</code><span class="emphasis"><em>,</em></span> if <code class="literal">x</code> is <code class="literal">False</code>, the interpreter will simply evaluate <code class="literal">x</code> and return <code class="literal">False</code>, without evaluating <code class="literal">y</code>.</p><p>The comparison operators (<code class="literal">&lt;</code>, <code class="literal">&lt;=</code>, <code class="literal">&gt;</code>, <code class="literal">&gt;=</code>, <code class="literal">==</code>, and <code class="literal">!=</code>) work with numbers, lists, and other <span>collection</span><a id="id326180770" class="indexterm"></a> objects and return <code class="literal">True</code> if the condition holds. For collection objects, comparison operators compare the number of elements and the equivalence operator ( <code class="literal">==</code>) returns <code class="literal">True</code> if each collection object is structurally equivalent, and the value of each element is identical. Let's see an example:</p><pre class="programlisting">&gt;&gt;&gt;See_boolean = (4 * 3 &gt; 10) and (6 + 5 &gt;= 11)
&gt;&gt;&gt;print(See_boolean)
True
&gt;&gt;&gt;if (See_boolean):
...    print("Boolean expression returned True")
   else:
...  print("Boolean expression returned False")
...

Boolean expression returned True</pre></div>