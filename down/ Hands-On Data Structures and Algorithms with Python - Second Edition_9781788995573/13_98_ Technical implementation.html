<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch13lvl1sec94"></a>Technical implementation</h2></div></div><hr /></div><p>Let's dig into the implementation of some of the theoretical programming techniques we have discussed. We start with dynamic programming.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl2sec81"></a>Implementation using dynamic programming</h3></div></div></div><p>As we have already described, in this approach, we divide a given <span>problem</span><a id="id326096194" class="indexterm"></a> into smaller subproblems. In finding the solution, care is taken not to recompute any of the previously encountered subproblems.</p><p> </p><p>This sounds a bit like recursion, but things are a little different here. A problem may lend itself to being solved by using dynamic programming, but will not necessarily take the form of making recursive calls.</p><p>One property that makes a problem an ideal candidate for being solved with dynamic programming is that it has an <span class="strong"><strong>overlapping set of subproblems</strong></span>.</p><p>Once we realize that <span>the form of subproblems has repeated itself during computation</span>, we need not compute it again. Instead, we return a pre-computed result for that previously encountered subproblem.</p><p>To ensure that we never have to re-evaluate a subproblem, we need an efficient way to store the results of each subproblem. The following two techniques are readily available.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch13lvl3sec64"></a>Memoization</h4></div></div></div><p>This technique starts from the initial problem set, and divides it into <span>small</span><a id="id325896337" class="indexterm"></a> subproblems. After the solution to a subprogram has been determined, we store the result to that particular subproblem. In the future, when this subproblem is encountered, we only return its pre-computed result.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch13lvl3sec65"></a>Tabulation</h4></div></div></div><p>In tabulation, we fill a table with solutions to subproblems, and then combine them to <span>solve</span><a id="id325896321" class="indexterm"></a> bigger problems.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl2sec82"></a>The Fibonacci series</h3></div></div></div><p>Let's consider an example to understand how dynamic programming works. We use the <span>Fibonacci</span><a id="id325895058" class="indexterm"></a> series to illustrate both the memoization and tabulation techniques.</p><p>The Fibonacci series can be demonstrated using a recurrence relation. Recurrence relations are recursive functions that are used to define mathematical functions or sequences. For example, the following recurrence relation defines the Fibonacci sequence [1, 1, 2, 3, 5, 8 ...]: </p><pre class="programlisting">func(1) = 1
func(0) = 1 
func(n) = func(n-1) + func(n-2)</pre><p> </p><p> </p><p>Note that the Fibonacci sequence can be generated by putting the values of <span class="emphasis"><em>n</em></span> in sequence [1, 2, 3, 4, ...].</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch13lvl3sec66"></a>The memoization technique</h4></div></div></div><p>Let's generate the <span>Fibonacci</span><a id="id325578034" class="indexterm"></a> series to the fifth term:</p><pre class="programlisting">    1 1 2 3 5</pre><p>A recursive-style program to generate the sequence would be as follows:</p><pre class="programlisting"> def fib(n): 
    if n &lt;= 2: 
       return 1 
    else: 
       return fib(n-1) + fib(n-2) </pre><p>The code is very simple, but a little tricky to read because of the recursive calls being made that end up solving the problem.</p><p>When the base case is met, the <code class="literal">fib()</code> function returns 1. If <span class="emphasis"><em>n</em></span> is equal to or less than 2, the base case is met.</p><p>If the base case is not met, we will call the <code class="literal">fib()</code> function again, and this time supply the first call with <code class="literal">n-1</code>, and the second with <code class="literal">n-2</code>:</p><pre class="programlisting">    return fib(n-1) + fib(n-2) </pre><p>The layout of the strategy to <span>solve</span><a id="id325644883" class="indexterm"></a> the <code class="literal">i<sup>th</sup></code> term in the Fibonacci sequence is as follows:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/7ee0115e-0f6f-43b6-afb7-a8517aa3bd65.png" /></div><p>Careful observation of the tree diagram shows some interesting patterns. The call to <span class="strong"><strong>fib(1)</strong></span> happens twice. The call to <span class="strong"><strong>fib(2)</strong></span> happens thrice. Also, the call to <span class="strong"><strong>fib(3)</strong></span> happens twice.</p><p>The return values of the same function call never change; for example, the return value for <span class="strong"><strong>fib(2)</strong></span> will always be the same whenever we call it. It will also be the same for <span class="strong"><strong>fib(1)</strong></span> and <span class="strong"><strong>fib(3)</strong></span>. Thus, computational time will be wasted if we compute again whenever we encounter the same function, since the same result is returned.</p><p>These repeated calls to a function with the same parameters and output suggest that there is an overlap. Certain computations reoccur down in the smaller subproblems.</p><p>A better approach is to store the results of the computation of <span class="strong"><strong>fib(1)</strong></span> the first time it is encountered. Similarly, we should store return values for <span class="strong"><strong>fib(2)</strong></span> and <span class="strong"><strong>fib(3)</strong></span>. Later, anytime we encounter a call to <span class="strong"><strong>fib(1)</strong></span>, <span class="strong"><strong>fib(2)</strong></span>, or <span class="strong"><strong>fib(3)</strong></span>, we simply return their respective results.</p><p>The diagram of our <code class="literal">fib</code> calls will <span>now</span><a id="id325851502" class="indexterm"></a> look like this:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/da04dee4-acb7-423a-9cc1-36625f66203d.png" /></div><p>We have eliminated the need to compute <span class="strong"><strong>fib(3)</strong></span>, fib(2), and <span class="strong"><strong>fib(1)</strong></span> if they are encountered multiple times. This typifies the memoization technique, wherein there is no recomputation of overlapping calls to functions when breaking a problem into its subproblems.</p><p>The overlapping function calls in our Fibonacci example are <span class="strong"><strong>fib(1)</strong></span>, <span class="strong"><strong>fib(2)</strong></span>, and <span class="strong"><strong>fib(3)</strong></span>:</p><pre class="programlisting">    def dyna_fib(n, lookup): 
        if n &lt;= 2: 
            lookup[n] = 1 

        if lookup[n] is None: 
            lookup[n] = dyna_fib(n-1, lookup) + dyna_fib(n-2, lookup) 

        return lookup[n]</pre><p>To create a list of 1,000 elements, we do the following and pass it to the lookup parameter of the <code class="literal">dyna_fib</code> function:</p><pre class="programlisting">    map_set = [None]*(1000)</pre><p> </p><p> </p><p>This list will store the value of the <span>computation</span><a id="id325855565" class="indexterm"></a> of the various calls to the <code class="literal">dyna_fib()</code> function:</p><pre class="programlisting">    if n &lt;= 2: 
        lookup[n] = 1 </pre><p>Any call to the <code class="literal">dyna_fib()</code> function with <span class="emphasis"><em>n</em></span> being less than or equal to 2 will return 1. When <code class="literal">dyna_fib(1)</code> is evaluated, we store the value at index 1 of <code class="literal">map_set</code>.</p><p>Write the condition for <code class="literal">lookup[n]</code> as the following:</p><pre class="programlisting">if lookup[n] is None:
    lookup[n] = dyna_fib(n-1, lookup) + dyna_fib(n-2, lookup)</pre><p>We pass lookup so that it can be referenced when evaluating the subproblems. The calls to <code class="literal">dyna_fib(n-1, lookup)</code> and <code class="literal">dyna_fib(n-2, lookup)</code> are stored in <code class="literal">lookup[n]</code>.</p><p>When we run our updated implementation of the function to find the <code class="literal"><span class="emphasis"><em>i</em></span><sup>th</sup></code> term of the Fibonacci series, we can see a considerable improvement. This implementation runs much faster than our initial implementation. Supply the value 20 to both implementations, and witness the difference in the execution speed.</p><p>However, the updated algorithm has sacrificed space complexity to achieve this, because of the use of additional memory in storing the results of the function calls.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch13lvl3sec67"></a>The tabulation technique</h4></div></div></div><p>A second technique in dynamic <span>programming</span><a id="id326175902" class="indexterm"></a> involves the use of a table of results, or matrix in some cases, to store the results of computations for later use.</p><p>This approach solves the bigger problem by first working out a route to the final solution. In the case of the <code class="literal">fib()</code> function, we develop a table with the values of <code class="literal">fib(1)</code> and <code class="literal">fib(2)</code> predetermined. Based on these two values, we will work our way up to <code class="literal">fib(n)</code>:</p><pre class="programlisting">    def fib(n): 

        results = [1, 1] 

        for i in range(2, n): 
            results.append(results[i-1] + results[i-2]) 

        return results[-1]</pre><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p>The <code class="literal">results</code> variable stores the values 1 and 1 at indices 0 and 1. This represents the return values of <code class="literal">fib(1)</code> and <code class="literal">fib(2)</code>. To calculate the values of the <code class="literal">fib()</code> function for values higher than 2, we simply call the <code class="literal">for</code> loop, which appends the sum of the <code class="literal">results[i-1] + results[i-2]</code> to the list of results.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl2sec83"></a>Implementation using divide and conquer</h3></div></div></div><p>This programming approach to problem-solving <span>emphasizes</span><a id="id326185101" class="indexterm"></a> the need to break down a problem into smaller subproblems of the same type or form of the original problem. These subproblems are solved and combined to obtain the solution of the original problem.</p><p>The following three steps are associated with this kind of programming.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch13lvl3sec68"></a>Divide</h4></div></div></div><p>To divide means to break down an entity or problem. Here, we devise the <span>means</span><a id="id326185118" class="indexterm"></a> to break down the original problem into subproblems. We can achieve this through iterative or recursive calls.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch13lvl3sec69"></a>Conquer</h4></div></div></div><p>It is impossible to continue breaking the problems into <span>subproblems</span><a id="id326185133" class="indexterm"></a> indefinitely. At some point, the smallest indivisible problem will return a solution. Once this happens, we can reverse our thought process and say that if we know the solution to the smallest subproblem, we can obtain the final solution to the original problem.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch13lvl3sec70"></a>Merge</h4></div></div></div><p>To obtain the final solution, we need to combine the <span>solutions</span><a id="id326185148" class="indexterm"></a> to the smaller problems in order to solve the bigger problem.</p><p>There are other variants to the divide and conquer algorithms, such as merge and combine, and conquer and solve. Many algorithms make use of the divide and conquer principle, such as merge sorting, quick sort, and Strassen's matrix multiplication.</p><p> </p><p>We will now describe implementation of a merge sort algorithm, as we saw earlier in Chapter 3, <span class="emphasis"><em>Principles of Algorithm Design</em></span>.</p><p> </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch13lvl3sec71"></a>Merge sort</h4></div></div></div><p>Merge sort algorithms are based on the divide and conquer rule. Given a list of unsorted elements, we split the list into two approximate halves. We continue to divide the list into two halves recursively.</p><p>After a while, the sublists created as a result of the recursive call will contain only one element. At that point, we begin to merge the <span>solutions</span><a id="id326185185" class="indexterm"></a> in the conquer or merge step:</p><pre class="programlisting">    def merge_sort(unsorted_list): 
        if len(unsorted_list) == 1: 
            return unsorted_list 

        mid_point = int((len(unsorted_list))//2) 

        first_half = unsorted_list[:mid_point] 
        second_half = unsorted_list[mid_point:] 

        half_a = merge_sort(first_half) 
        half_b = merge_sort(second_half) 

        return merge(half_a, half_b) </pre><p>Our implementation starts by accepting the list of unsorted elements into the <code class="literal">merge_sort</code> function. The <code class="literal">if</code> statement is used to establish the base case, where, if there is only one element in the <code class="literal">unsorted_list</code>, we simply return that list again. If there is more than one element in the list, we find the approximate middle using <code class="literal">mid_point = int((len(unsorted_list)) // 2)</code>.</p><p>Using this <code class="literal">mid_point</code>, we divide the list into two sublists, namely, <code class="literal">first_half</code> and <code class="literal">second_half</code>:</p><pre class="programlisting">    first_half = unsorted_list[:mid_point] 
    second_half = unsorted_list[mid_point:] </pre><p>A recursive call is made by passing the two sublists to the <code class="literal">merge_sort</code> function again:</p><pre class="programlisting">    half_a = merge_sort(first_half)  
    half_b = merge_sort(second_half)</pre><p> </p><p> </p><p> </p><p> </p><p>Now for the merge step. When <code class="literal">half_a</code> and <code class="literal">half_b</code> have been passed their values, we call the <code class="literal">merge</code> function, which will merge or combine the two <span>solutions</span><a id="id326185265" class="indexterm"></a> stored in <code class="literal">half_a</code> and <code class="literal">half_b</code>, which are lists:</p><pre class="programlisting"> def merge(first_sublist, second_sublist): 
     i = j = 0 
     merged_list = [] 

     while i &lt; len(first_sublist) and j &lt; len(second_sublist): 
         if first_sublist[i] &lt; second_sublist[j]: 
             merged_list.append(first_sublist[i]) 
             i += 1 
         else: 
             merged_list.append(second_sublist[j]) 
             j += 1 

     while i &lt; len(first_sublist): 
         merged_list.append(first_sublist[i]) 
         i += 1 

     while j &lt; len(second_sublist): 
         merged_list.append(second_sublist[j]) 
         j += 1 

     return merged_list </pre><p>The <code class="literal">merge</code> function takes the two lists we want to merge together, <code class="literal">first_sublist</code> and <code class="literal">second_sublist</code>. The <code class="literal">i</code> and <code class="literal">j</code> variables are initialized to 0, and are used as pointers to tell us where we are in the two lists with respect to the merging process.</p><p>The final <code class="literal">merged_list</code> will contain the merged list:</p><pre class="programlisting">    while i &lt; len(first_sublist) and j &lt; len(second_sublist): 
        if first_sublist[i] &lt; second_sublist[j]: 
            merged_list.append(first_sublist[i]) 
            i += 1 
        else: 
            merged_list.append(second_sublist[j]) 
            j += 1 </pre><p>The <code class="literal">while</code> loop starts comparing the elements in <code class="literal">first_sublist</code> and <code class="literal">second_sublist</code>. The <code class="literal">if</code> statement selects the smaller of the two, <code class="literal">first_sublist[i]</code> or <code class="literal">second_sublist[j]</code>, and appends it to <code class="literal">merged_list</code>. The <code class="literal">i</code> or <code class="literal">j</code> index is incremented to reflect where we are with the merging step. The <code class="literal">while</code> loop stops when either sublist is empty.</p><p> </p><p> </p><p>There may be elements left behind in either <code class="literal">first_sublist</code> or <code class="literal">second_sublist</code>. The last two <code class="literal">while</code> loops make sure that those elements are added to <code class="literal">merged_list</code> before it is returned.</p><p>The last call to <code class="literal">merge(half_a, half_b)</code> will return the sorted list.</p><p>Let's give the algorithm a dry run by merging the two sublists <code class="literal">[4, 6, 8]</code> and <code class="literal">[5, 7, 11, 40]</code>:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Step</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">first_sublist</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">second_sublist</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">merged_list</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Step 0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">[4 6 8]</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">[5 7 11 40]</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">[]</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Step 1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">[ 6 8]</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">[5 7 11 40]</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">[4]</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Step 2</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">[ 6 8]</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">[ 7 11 40]</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">[4 5]</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Step 3</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">[ 8]</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">[ 7 11 40]</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">[4 5 6]</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Step 4</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">[ 8]</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">[ 11 40]</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">[4 5 6 7]</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Step 5</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">[ ]</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">[ 11 40]</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">[4 5 6 7 8]</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Step 6</p></td><td style="border-right: 0.5pt solid ; "><p><code class="literal">[]</code></p></td><td style="border-right: 0.5pt solid ; "><p><code class="literal">[ ]</code></p></td><td style=""><p><code class="literal">[4 5 6 7 8 11 40]</code></p></td></tr></tbody></table></div><p> </p><p>Note that the text in bold represents the current item <span>referenced</span><a id="id326309955" class="indexterm"></a> in the loops <code class="literal">first_sublist</code> (which uses the <code class="literal">i</code><span class="emphasis"><em>index</em></span>) and <code class="literal">second_sublist</code> (which uses the <code class="literal">j</code> index).</p><p>At this point in the execution, the third <code class="literal">while</code> loop in the merge function kicks in to move 11 and 40 into <code class="literal">merged_list</code>. The returned <code class="literal">merged_list</code> will contain the fully sorted list.</p><p>Note that while the merge algorithm takes <code class="literal">O(n)</code> time, the merge sort algorithm has a running time complexity of <code class="literal">O(log n) T(n) = O(n)*O(log n) = O(n log n)</code>.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl2sec84"></a>Implementation using greedy algorithms</h3></div></div></div><p>As we discussed earlier, <span>greedy</span><a id="id326310245" class="indexterm"></a> algorithms make decisions to yield the best possible local solution, which in turn provides the optimal solution. It is the hope of this technique that by making the best possible choices at each step, the total path will lead to an overall optimal solution or end.</p><p>Examples of greedy algorithms include <span class="strong"><strong>Prim's algorithm</strong></span> for finding a minimum spanning tree, the <span class="strong"><strong>Knapsack problem</strong></span>, and the <span class="strong"><strong>Traveling Salesman problem</strong></span>, to mention just a few.</p><p> </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch13lvl3sec72"></a>Coin-counting problem</h4></div></div></div><p>To demonstrate how the greedy <span>technique</span><a id="id326321475" class="indexterm"></a> works, let's look at an example. Consider a <span>problem</span><a id="id326321481" class="indexterm"></a> in which we wish to compute the minimum number of coin required to make a given amount A, where we have an infinite supply of the given coins' values.</p><p>For example, in some arbitrary country, we have the following coin denominations: 1, 5, and 8 GHC. Given an amount (for example, 12 GHC), we want to find the smallest possible number of coins needed to provide this amount.</p><p>The algorithm to obtain the minimum number of coins to provide a given amount <span class="emphasis"><em>A</em></span> using denominations <code class="literal">{a<sub>1</sub>,a<sub>2</sub>,a<sub>3</sub>...a<sub>n</sub>}</code> is as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><span> We sort</span> the list of denominations <code class="literal">{a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub> ...a<sub>n</sub>}</code>.</li><li> We get the largest denomination in <code class="literal">{a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub>...a<sub>n</sub>}</code> which is smaller than A.</li><li>We obtain the division by dividing A by the largest denomination.</li><li>We get the remaining amount A by getting the remainder using (A % largest denominator).</li><li> If the value of A becomes 0, then we return the result.</li><li>Else If the value of A is greater than 0, we append the largest denominator and division variable in the result variable. And repeat the steps 2-5.</li></ol></div><p>Using the greedy approach, we first pick the largest value from the available denominations<span>—</span>which is 8<span>—</span>to divide into 12. The remainder, 4, cannot be divided by either 8 or the next lowest denomination, 5. So, we try the 1 GHC denomination coin, of which we need four. In the end, using this greedy algorithm, we return an answer of one 8 GHC coin and four 1 GHC coins.</p><p>So far, our greedy algorithm seems to be doing pretty well. A function that returns the respective denominations is as follows:</p><pre class="programlisting">    def basic_small_change(denom, total_amount): 
        sorted_denominations = sorted(denom, reverse=True) 

        number_of_denoms = [] 

        for i in sorted_denominations: 
            div = total_amount // i 
            total_amount = total_amount % i 
            if div &gt; 0: 
                number_of_denoms.append((i, div)) 

        return number_of_denoms</pre><p> </p><p> </p><p> </p><p> </p><p>This greedy algorithm always starts by using the largest denomination possible. Note that <code class="literal">denom</code> is a list of denominations, and that <code class="literal">sorted(denom, reverse=True)</code> will sort the list in reverse so that we can obtain the largest denomination at index <span class="emphasis"><em><code class="literal">0</code></em></span>. Now, starting from index <code class="literal"><span class="emphasis"><em>0</em></span></code> of the sorted list of denominations, <code class="literal">sorted_denominations</code>, we iterate and apply the greedy technique:</p><pre class="programlisting">    for i in sorted_denominations: 
        div = total_amount // i 
        total_amount = total_amount % i 
        if div &gt; 0: 
            number_of_denoms.append((i, div)) </pre><p>The loop will run through the list of denominations. Each time the loop runs, it obtains the quotient, <code class="literal">div</code>, by dividing the <code class="literal">total_amount</code> by the current denomination, <span class="emphasis"><em>i</em></span>. The <code class="literal">total_amount</code> variable is updated to store the remainder for further processing. If the quotient is greater than 0, we store it in <code class="literal">number_of_denoms</code>.</p><p>However, there are some possible instances where this algorithm may fail. For instance, when passed 12 GHC, our algorithm returned one 8 GHC and four 1 GHC coins. This output is, however, not the optimal solution. The best solution is to use two 5 GHC and two 1 GHC coins.</p><p>A better greedy algorithm is <span>presented</span><a id="id326379776" class="indexterm"></a> here. This time, the function returns a list of <span>tuples</span><a id="id326379784" class="indexterm"></a> that allow us to investigate the best results:</p><pre class="programlisting">    def optimal_small_change(denom, total_amount): 

        sorted_denominations = sorted(denom, reverse=True) 

        series = [] 
        for j in range(len(sorted_denominations)): 
            term = sorted_denominations[j:] 

            number_of_denoms = [] 
            local_total = total_amount 
            for i in term: 
                div = local_total // i 
                local_total = local_total % i 
                if div &gt; 0: 
                    number_of_denoms.append((i, div)) 

            series.append(number_of_denoms) 

        return series</pre><p> </p><p> </p><p>The outer <code class="literal">for</code> loop enables us to limit the denominations from which we find our solution:</p><pre class="programlisting">    for j in range(len(sorted_denominations)): 
        term = sorted_denominations[j:] 
        ...     </pre><p>Assuming that we have the list [5, 4, 3] in <code class="literal">sorted_denominations</code>, slicing it with <code class="literal">[j:]</code> helps us obtain the sublists [5, 4, 3], [4, 3], and [3], from which we try to find the right combination.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch13lvl3sec73"></a>Shortest path algorithm</h4></div></div></div><p>The shortest path <span>problem</span><a id="id326380305" class="indexterm"></a> requires us to find out the shortest possible route <span>between</span><a id="id326380311" class="indexterm"></a> nodes in a graph. It has important applications for mapping and route planning, when plotting the most efficient way to get from point <span class="strong"><strong>A</strong></span> to point <span class="strong"><strong>B</strong></span>.</p><p>Dijkstra's algorithm is a very popular method of solving this problem. This algorithm is used to find the shortest distance from a source to all other nodes or vertices in a graph. Here we explain how we can use the greedy approach to solve this problem.</p><p>Dijkstra's algorithm works for weighted directed and undirected graphs. The algorithm produces the output of a list of the shortest path from a given source node A in a weighted graph. The algorithm works as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Initially, mark all the nodes as unvisited, and set their distance from the given source node to infinity (the source node is set to zero).</li><li>Set the source node as current.</li><li>For the current node, look for all the unvisited adjacent nodes; compute the distance to that node from the source node through the current node. Compare the newly computed distance to the currently assigned distance, and if it is smaller, set this as the new value.</li><li>Once we have considered all the unvisited adjacent nodes of the current node, we mark it as visited.</li><li>We next consider the next unvisited node which has the shortest distance from the source node. Repeat steps 2 to 4.</li><li>We stop when the list of unvisited nodes is empty, meaning we have considered all the unvisited nodes.</li></ol></div><p>Consider the following example of a weighted graph with six nodes [A, B, C, D, E, F] to understand how Dijkstra's algorithm works:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/ebd89c42-7360-4dd1-b7fb-2872ae4ff551.png" /></div><p>By manual inspection, the shortest path between node <span class="strong"><strong>A</strong></span> and node <span class="strong"><strong>D</strong></span> at first glance seems to be the direct line with a distance of 9. However, the shortest route means the lowest total distance, even if this comprises several parts. By comparison, traveling from node<span class="strong"><strong>A</strong></span> to node<span class="strong"><strong>E</strong></span>to node<span class="strong"><strong>F</strong></span> and finally to node <span class="strong"><strong>D </strong></span>will incur a total distance of 7, making it a shorter route.</p><p>We would implement the shortest path algorithm with a single source. It would determine the shortest path from the origin, which in this case is <span class="strong"><strong>A</strong></span>, to any other node in the graph. </p><p>In <a class="link" href="#" linkend="ch08">Chapter 8</a>, <span class="emphasis"><em>Graphs and Other Algorithms</em></span>, we discussed how to represent a graph with an adjacency list. We use an adjacency list along with the weight/cost/distance on every edge to <span>represent</span><a id="id326392290" class="indexterm"></a> the graph, as shown in the following Python code. A table is <span>used</span><a id="id326392298" class="indexterm"></a> to keep track of the shortest distance from the source in the graph to any other node. A Python dictionary will be used to implement this table.</p><p>Here is the starting table:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Node</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Shortest distance from source</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Previous node</strong></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>A</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-bottom: 0.5pt solid ; "><p>None</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>B</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>∞</p></td><td style="border-bottom: 0.5pt solid ; "><p>None</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>C</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>∞</p></td><td style="border-bottom: 0.5pt solid ; "><p>None</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>D</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>∞</p></td><td style="border-bottom: 0.5pt solid ; "><p>None</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>E</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>∞</p></td><td style="border-bottom: 0.5pt solid ; "><p>None</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><span class="strong"><strong>F</strong></span></p></td><td style="border-right: 0.5pt solid ; "><p>∞</p></td><td style=""><p>None</p></td></tr></tbody></table></div><p>The adjacency list for the diagram and table is as follows:</p><pre class="programlisting">    graph = dict() 
    graph['A'] = {'B': 5, 'D': 9, 'E': 2} 
    graph['B'] = {'A': 5, 'C': 2} 
    graph['C'] = {'B': 2, 'D': 3} 
    graph['D'] = {'A': 9, 'F': 2, 'C': 3} 
    graph['E'] = {'A': 2, 'F': 3} 
    graph['F'] = {'E': 3, 'D': 2} </pre><p>The nested dictionary holds the distance and adjacent nodes.</p><p>When the algorithm starts, the shortest distance from the given source node (<span class="strong"><strong>A</strong></span>) to any of the nodes is unknown. Thus, we initially set the distance to all other nodes to infinity, with the exception of node<span class="strong"><strong>A</strong></span>, as the distance from node<span class="strong"><strong>A</strong></span>to node<span class="strong"><strong>A</strong></span>is 0.</p><p>No prior nodes have been visited when the algorithm begins. Therefore, we mark the previous node column of the node <span class="strong"><strong>A</strong></span> as None.</p><p>In step 1 of the algorithm, we start by examining the adjacent nodes to node <span class="strong"><strong>A</strong></span>. To find the shortest distance from node <span class="strong"><strong>A</strong></span> to node <span class="strong"><strong>B</strong></span>, we need to find the distance from the start node to the previous node of node B, which happens to be node <span class="strong"><strong>A</strong></span>, and add it to the distance from node <span class="strong"><strong>A</strong></span> to node <span class="strong"><strong>B</strong></span>. We do this for other adjacent nodes of <span class="strong"><strong>A</strong></span>, which are <span class="strong"><strong>B</strong></span>, <span class="strong"><strong>E</strong></span>, and <span class="strong"><strong>D</strong></span>. This is shown in the following diagram:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/c9cf463e-0307-41f1-94e6-a3ca8a4261d2.png" /></div><p>We <span>take the adjacent node</span><span class="strong"><strong>B</strong></span> as <span>its distance from node <span class="strong"><strong>A</strong></span> is minimum;</span> the distance from the start node (<span class="strong"><strong>A</strong></span>) to the previous node (None) is 0, and the distance from the previous node to the current node (<span class="strong"><strong>B</strong></span>) is <span class="strong"><strong>5</strong></span>. This sum is compared with the data in the shortest distance column of node <span class="strong"><strong>B</strong></span>. Since <span class="strong"><strong>5</strong></span> is less than infinity(<span class="strong"><strong>∞</strong></span>), we replace <span class="strong"><strong>∞</strong></span> with the smaller of the two, which is <span class="strong"><strong>5</strong></span>.</p><p>Any <span>time</span><a id="id326409163" class="indexterm"></a> the shortest distance of a node is replaced by a <span>smaller</span><a id="id326409170" class="indexterm"></a> value, we need to update the previous node column too for all the adjacent nodes of the current node. After this, we mark node <span class="strong"><strong>A</strong></span> as visited:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/bcdbedbb-c54f-4ead-8f30-d3bed39de051.png" /></div><p>At the end of the first step, our table looks as follows:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Node</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Shortest distance from source</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Previous node</strong></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>A*</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-bottom: 0.5pt solid ; "><p>None</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>B</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>5</p></td><td style="border-bottom: 0.5pt solid ; "><p>A</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>C</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>∞</p></td><td style="border-bottom: 0.5pt solid ; "><p>None</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>D</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>9</p></td><td style="border-bottom: 0.5pt solid ; "><p>A</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>E</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>A</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>F</p></td><td style="border-right: 0.5pt solid ; "><p>∞</p></td><td style=""><p>None</p></td></tr></tbody></table></div><p> </p><p>At this point, node <span class="strong"><strong>A</strong></span> is considered visited. As such, we add node <span class="strong"><strong>A</strong></span> to the list of visited nodes. In the table, we show that node <span class="strong"><strong>A</strong></span> has been visited by making the text bold and appending an asterisk sign to it.</p><p>In the second step, we find the node with the shortest distance using our table as a guide. Node <span class="strong"><strong>E</strong></span>, with its value of 2, has the shortest distance. This is what we can infer from the table about node <span class="strong"><strong>E</strong></span>. To get to node <span class="strong"><strong>E</strong></span>, we must visit node <span class="strong"><strong>A</strong></span> and cover a distance of <span class="strong"><strong>2.</strong></span> From node A, we cover a distance of 0 to get to the starting node, which is node <span class="strong"><strong>A</strong></span> itself.</p><p>The adjacent nodes to node <span class="strong"><strong>E</strong></span> are <span class="strong"><strong>A</strong></span> and <span class="strong"><strong>F</strong></span>. But node <span class="strong"><strong>A</strong></span> has already been visited, so we will only consider node <span class="strong"><strong>F</strong></span>. To find the shortest route or distance to node <span class="strong"><strong>F</strong></span>, we must find the distance from the starting node to node <span class="strong"><strong>E</strong></span> and add it to the distance between node <span class="strong"><strong>E</strong></span> and <span class="strong"><strong>F</strong></span>. We can find the distance from the starting node to node <span class="strong"><strong>E</strong></span> by looking at the shortest distance column of node <span class="strong"><strong>E</strong></span>, which has the value <span class="strong"><strong>2</strong></span>. The distance from node <span class="strong"><strong>E</strong></span> to <span class="strong"><strong>F</strong></span> can be obtained from the adjacency list we developed in Python earlier in this section.</p><p> </p><p>This distance is <span class="strong"><strong>3</strong></span>. These two <span>sum</span><a id="id326480327" class="indexterm"></a> up to 5, which is less than infinity. Remember we are <span>examining</span><a id="id326480333" class="indexterm"></a> the adjacent node <span class="strong"><strong>F</strong></span>. Since there are no more adjacent nodes to node <span class="strong"><strong>E</strong></span>, we mark node <span class="strong"><strong>E</strong></span> as visited. Our updated table and the figure will have the following values:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Node</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Shortest distance from source</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Previous node</strong></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>A*</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-bottom: 0.5pt solid ; "><p>None</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>B</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>5</p></td><td style="border-bottom: 0.5pt solid ; "><p>A</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>C</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>∞</p></td><td style="border-bottom: 0.5pt solid ; "><p>None</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>D</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>9</p></td><td style="border-bottom: 0.5pt solid ; "><p>A</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>E*</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>A</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>F</p></td><td style="border-right: 0.5pt solid ; "><p>5</p></td><td style=""><p>E</p></td></tr></tbody></table></div><p> </p><p>After visiting node <span class="strong"><strong>E</strong></span>, we find the smallest value in the shortest distance column of the table, which is 5 for nodes <span class="strong"><strong>B</strong></span> and <span class="strong"><strong>F</strong></span>. Let us choose <span class="strong"><strong>B</strong></span> instead of <span class="strong"><strong>F</strong></span> purely on an alphabetical basis (we could equally have chosen <span class="strong"><strong>F</strong></span>).</p><p>The adjacent nodes to <span class="strong"><strong>B</strong></span> are <span class="strong"><strong>A</strong></span> and <span class="strong"><strong>C</strong></span>, but node <span class="strong"><strong>A</strong></span> has already been visited. Using the rule we established earlier, the shortest distance from <span class="strong"><strong>A</strong></span> to <span class="strong"><strong>C</strong></span> is 7. We arrive at this number because the distance from the starting node to node <span class="strong"><strong>B</strong></span> is 5, while the distance from node <span class="strong"><strong>B</strong></span> to <span class="strong"><strong>C</strong></span> is 2.</p><p>Since 7 is less <span>than</span><a id="id326494919" class="indexterm"></a> infinity, we update the s<span>hortest distance to 7 and update th</span>e <span>previous</span><a id="id326497526" class="indexterm"></a> node column with node <span class="strong"><strong>B</strong></span>:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/ffc554d2-7123-49e2-91a4-99ca16d0342c.png" /></div><p>Now, <span class="strong"><strong>B</strong></span> is also marked as visited. The new state of the table and the figure is as follows:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Node</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Shortest distance from source</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Previous node</strong></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>A*</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-bottom: 0.5pt solid ; "><p>None</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>B*</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>5</p></td><td style="border-bottom: 0.5pt solid ; "><p>A</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>C</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>7</p></td><td style="border-bottom: 0.5pt solid ; "><p>B</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>D</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>9</p></td><td style="border-bottom: 0.5pt solid ; "><p>A</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>E*</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>A</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>F</p></td><td style="border-right: 0.5pt solid ; "><p>5</p></td><td style=""><p>E</p></td></tr></tbody></table></div><p> </p><p>The node with the shortest distance yet unvisited is node<span class="strong"><strong>F</strong></span>. The adjacent nodes to<span class="strong"><strong>F</strong></span>are nodes <span class="strong"><strong>D</strong></span>and<span class="strong"><strong>E</strong></span>. But node<span class="strong"><strong>E</strong></span>has already been visited. As such, we focus on finding the shortest distance from the starting node to node<span class="strong"><strong>D</strong></span>.</p><p>We calculate this distance by <span>adding</span><a id="id326558536" class="indexterm"></a> the distance from node<span class="strong"><strong>A</strong></span>to<span class="strong"><strong>F</strong></span>to the distance from node<span class="strong"><strong>F</strong></span>to<span class="strong"><strong>D</strong></span>. This sums up to 7, which is less than <span class="strong"><strong>9</strong></span>. Thus, we update the <span class="strong"><strong>9</strong></span> with <span class="strong"><strong>7</strong></span> and replace<span class="strong"><strong>A</strong></span>with<span class="strong"><strong>F</strong></span>in node<span class="strong"><strong>D</strong></span>'s <span>previous</span><a id="id326566166" class="indexterm"></a> node column:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/5b38bd47-f001-44dc-8404-cd9d1df34cf1.png" /></div><p>Node <span class="strong"><strong>F</strong></span> is now marked as visited. Here is the updated table and the figure up to this point:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Node</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Shortest distance from source</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Previous node</strong></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>A*</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-bottom: 0.5pt solid ; "><p>None</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>B*</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>5</p></td><td style="border-bottom: 0.5pt solid ; "><p>A</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>C</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>7</p></td><td style="border-bottom: 0.5pt solid ; "><p>B</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>D</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>7</p></td><td style="border-bottom: 0.5pt solid ; "><p>F</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>E*</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>A</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><span class="strong"><strong>F*</strong></span></p></td><td style="border-right: 0.5pt solid ; "><p>5</p></td><td style=""><p>E</p></td></tr></tbody></table></div><p> </p><p> </p><p>Now, only two unvisited nodes are left,<span class="strong"><strong>C</strong></span> and <span class="strong"><strong>D</strong></span>, both with adistance cost of <span class="strong"><strong>7</strong></span>. In alphabetical order, we choose to examine <span class="strong"><strong>C</strong></span> because both nodes have the same shortest distance from the starting node <span class="strong"><strong>A</strong></span>:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/df46dc6c-0089-4cf7-90a2-6488a02917bc.png" /></div><p>However, all the <span>adjacent</span><a id="id326582092" class="indexterm"></a> nodes to<span class="strong"><strong>C</strong></span> have been visited. Thus, we have <span>nothing</span><a id="id326582103" class="indexterm"></a> to do but mark node <span class="strong"><strong>C</strong></span> as visited. The table remains unchanged at this point:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/93570d76-cf70-4ed6-8942-c4eea78f5cb7.png" /></div><p>Lastly, we take node <span class="strong"><strong>D</strong></span>, and find out that all its adjacent nodes have been visited too. We only mark it as visited. The table remains unchanged:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Node</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Shortest distance from source</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Previous node</strong></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>A*</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-bottom: 0.5pt solid ; "><p>None</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>B*</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>5</p></td><td style="border-bottom: 0.5pt solid ; "><p>A</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>C*</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>7</p></td><td style="border-bottom: 0.5pt solid ; "><p>B</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>D*</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>7</p></td><td style="border-bottom: 0.5pt solid ; "><p>F</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>E*</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>A</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><span class="strong"><strong>F*</strong></span></p></td><td style="border-right: 0.5pt solid ; "><p>5</p></td><td style=""><p>E</p></td></tr></tbody></table></div><p> </p><p>Let's verify this table with our initial graph. From the graph, we know that the shortest distance from <span class="strong"><strong>A</strong></span> to <span class="strong"><strong>F</strong></span> is <span class="strong"><strong>5</strong></span>. We will need to go through <span class="strong"><strong>E</strong></span> to get to node <span class="strong"><strong>F</strong></span>:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/02e8b39c-0a7c-43be-8461-3b736a6bbb1e.png" /></div><p>According to the table, the shortest distance from the source column for node <span class="strong"><strong>F</strong></span> is 5. This is true. It also tells us that to get to node <span class="strong"><strong>F</strong></span>, we need to visit node <span class="strong"><strong>E</strong></span>, and from <span class="strong"><strong>E</strong></span> to node <span class="strong"><strong>A</strong></span>, which is our starting node. This is actually the shortest path.</p><p>To implement Dijkstra's <span>algorithm</span><a id="id326599256" class="indexterm"></a> to find the shortest path, we begin the program for finding the shortest distance by representing the table that enables us to track the changes in our graph. For <span>the</span><a id="id326599262" class="indexterm"></a> diagram we used, here is a dictionary representation of the table:</p><pre class="programlisting">    table = dict() 
    table = { 
        'A': [0, None], 
        'B': [float("inf"), None], 
        'C': [float("inf"), None], 
        'D': [float("inf"), None], 
        'E': [float("inf"), None], 
        'F': [float("inf"), None], 
    } </pre><p>The initial state of the table uses <code class="literal">float("inf")</code> to represent infinity. Each key in the dictionary maps to a list. At the first index of the list, the shortest distance from the source A is stored. At the second index, the previous node is stored:</p><pre class="programlisting">    DISTANCE = 0 
    PREVIOUS_NODE = 1 
    INFINITY = float('inf') </pre><p>To avoid the use of magic numbers, we use the preceding constants. The shortest path column's index is referenced by <code class="literal">DISTANCE</code>. The previous node column's index is referenced by <code class="literal">PREVIOUS_NODE</code>.</p><p>Now all is set for the main function of the algorithm. It will take the graph, represented by the adjacency list, the table, and the starting node as parameters:</p><pre class="programlisting">    def find_shortest_path(graph, table, origin): 
        visited_nodes = [] 
        current_node = origin 
        starting_node = origin </pre><p>We keep the list of visited nodes in the <code class="literal">visited_nodes</code> list. The <code class="literal">current_node</code> and <code class="literal">starting_node</code> variables will both point to the node in the graph we choose to make our starting node. The <code class="literal">origin</code> value is the reference point for all other nodes with respect to finding the shortest path.</p><p>The heavy lifting of <span>the</span><a id="id326599592" class="indexterm"></a> whole process is accomplished by <span>the</span><a id="id326599598" class="indexterm"></a> use of a <code class="literal">while</code> loop:</p><pre class="programlisting">    while True: 
        adjacent_nodes = graph[current_node] 
        if set(adjacent_nodes).issubset(set(visited_nodes)): 
            # Nothing here to do. All adjacent nodes have been visited. 
            pass 
        else: 
            unvisited_nodes = 
                set(adjacent_nodes).difference(set(visited_nodes)) 
            for vertex in unvisited_nodes: 
                distance_from_starting_node = 
                    get_shortest_distance(table, vertex) 
                if distance_from_starting_node == INFINITY and 
                   current_node == starting_node: 
                    total_distance = get_distance(graph, vertex, 
                                                  current_node) 
                else: 
                    total_distance = get_shortest_distance (table, 
                    current_node) + get_distance(graph, current_node, 
                                                 vertex) 

                if total_distance &lt; distance_from_starting_node: 
                    set_shortest_distance(table, vertex, 
                                          total_distance) 
                    set_previous_node(table, vertex, current_node) 

        visited_nodes.append(current_node) 

        if len(visited_nodes) == len(table.keys()): 
            break 

        current_node = get_next_node(table,visited_nodes) </pre><p>Let's break down what the <code class="literal">while</code> loop is doing. In the body of the <code class="literal">while</code> loop, we obtain the current node in the graph we want to investigate with <code class="literal">adjacent_nodes = graph[current_node]</code>. Now, <code class="literal">current_node</code> should have been set prior. The <code class="literal">if</code> statement is used to find out whether all the adjacent nodes of <code class="literal">current_node</code> have been visited.</p><p>When the <code class="literal">while</code> loop is executed for the fir<span class="emphasis"><em>s</em></span>t time, <code class="literal">current_node</code> will contain A and <code class="literal">adjacent_nodes</code> will contain nodes B, D, and E. Furthermore, <code class="literal">visited_nodes</code> will be empty too. If all nodes have been visited, we only move on to the statements further down the program. Otherwise, we begin a whole new step.</p><p>The <code class="literal">set(adjacent_nodes).difference(set(visited_nodes))</code> statement returns the nodes that have not been visited. The loop iterates over this list of unvisited nodes:</p><pre class="programlisting">    distance_from_starting_node = get_shortest_distance(table, vertex) </pre><p>The <code class="literal">get_shortest_distance(table, vertex)</code> helper method will return the value stored in the shortest distance column of our table, using one of the unvisited nodes referenced by <code class="literal">vertex</code>:</p><pre class="programlisting">    if distance_from_starting_node == INFINITY and current_node == starting_node: 
         total_distance = get_distance(graph, vertex, current_node) </pre><p>When we are examining the adjacent nodes of the starting node, <code class="literal">distance_from_starting_node == INFINITY and current_node == starting_node</code> will evaluate to <code class="literal">True</code>, in which case we only have to find the distance between the starting node and vertex by referencing the graph:</p><pre class="programlisting">    total_distance = get_distance(graph, vertex, current_node)</pre><p>The <code class="literal">get_distance</code> method is another helper method we use to obtain the value (distance) of the edge between <code class="literal">vertex</code> and <code class="literal">current_node</code>.</p><p>If the condition fails, then we assign to <code class="literal">total_distance</code> the sum of the distance from the starting node to <code class="literal">current_node</code>, and the distance between <code class="literal">current_node</code> and <code class="literal">vertex</code>.</p><p>Once we have our total distance, we need to check whether <code class="literal">total_distance</code> is less than the existing data in the shortest distance column of our table. If it is less, then we use the two helper methods to update that row:</p><pre class="programlisting">    if total_distance &lt; distance_from_starting_node: 
        set_shortest_distance(table, vertex, total_distance) 
    set_previous_node(table, vertex, current_node) </pre><p>At this point, we add <code class="literal">current_node</code> to the list of visited nodes:</p><pre class="programlisting">    visited_nodes.append(current_node) </pre><p>If all nodes have been visited, then we must exit the <code class="literal">while</code> loop. To check whether all <span>the</span><a id="id326639645" class="indexterm"></a> nodes have been visited, we compare the length of the <code class="literal">visited_nodes</code> list to <span>the</span><a id="id326648942" class="indexterm"></a> number of keys in our table. If they have become equal, we simply exit the <code class="literal">while</code> loop.</p><p>The <code class="literal">get_next_node</code> helper method is used to fetch the next node to visit. It is this method that helps us find the minimum value in the shortest distance column from the starting nodes using our table.</p><p>The whole method ends by returning the updated table. To print the table, we use the following statements:</p><pre class="programlisting"> shortest_distance_table = find_shortest_path(graph, table, 'A') 
 for k in sorted(shortest_distance_table): 
     print("{} - {}".format(k,shortest_distance_table[k])) <span class="strong"><strong>
</strong></span></pre><p>This is the output for the preceding statement:</p><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; 
</strong></span><span class="strong"><strong>A - [0, None]
</strong></span><span class="strong"><strong>B - [5, 'A']
</strong></span><span class="strong"><strong>C - [7, 'B']
</strong></span><span class="strong"><strong>D - [7, 'F']
</strong></span><span class="strong"><strong>E - [2, 'A']
</strong></span><span class="strong"><strong>F - [5, 'E']</strong></span></pre><p> </p><p> </p><p>For the sake of completeness, let's find out what the helper methods are doing:</p><pre class="programlisting">    def get_shortest_distance(table, vertex): 
        shortest_distance = table[vertex][DISTANCE] 
        return shortest_distance </pre><p>The <code class="literal">get_shortest_distance</code> function returns the value stored in index 0 of our table. At that index, we always store the shortest distance from the starting node up to <code class="literal">vertex</code>. The <code class="literal">set_shortest_distance</code> function only sets this value as follows:</p><pre class="programlisting">    def set_shortest_distance(table, vertex, new_distance): 
        table[vertex][DISTANCE] = new_distance </pre><p>When we update the shortest distance of a node, we update its previous node using the following method:</p><pre class="programlisting">    def set_previous_node(table, vertex, previous_node): 
        table[vertex][PREVIOUS_NODE] = previous_node </pre><p>Remember that the, <code class="literal">PREVIOUS_NODE</code> constant equals 1. In the table, we store the value of <code class="literal">previous_node</code> at <code class="literal">table[vertex][PREVIOUS_NODE]</code>.</p><p>To find the distance between any two nodes, we use the <code class="literal">get_distance</code> function:</p><pre class="programlisting">    def get_distance(graph, first_vertex, second_vertex): 
        return graph[first_vertex][second_vertex] </pre><p>The last helper method is the <code class="literal">get_next_node</code> function:</p><pre class="programlisting">    def get_next_node(table, visited_nodes): 
        unvisited_nodes = 
            list(set(table.keys()).difference(set(visited_nodes))) 
        assumed_min = table[unvisited_nodes[0]][DISTANCE] 
        min_vertex = unvisited_nodes[0] 
        for node in unvisited_nodes: 
            if table[node][DISTANCE] &lt; assumed_min: 
                assumed_min = table[node][DISTANCE] 
                min_vertex = node 

        return min_vertex </pre><p>The <code class="literal">get_next_node</code> function resembles a function to find the smallest item in a list.</p><p> </p><p> </p><p>The function starts off by finding the unvisited nodes in our table by using <code class="literal">visited_nodes</code> to obtain the difference between the two sets of lists. The very first item in the list of <code class="literal">unvisited_nodes</code> is assumed to be the smallest in the shortest distance column of <code class="literal">table</code>.</p><p>If a lesser value is found while the <code class="literal">for</code> loop runs, the <code class="literal">min_vertex</code> will be updated. The function then returns <code class="literal">min_vertex</code> as <span>the</span><a id="id326256804" class="indexterm"></a> unvisited vertex or node with the smallest shortest distance from <span>the</span><a id="id326256810" class="indexterm"></a> source.</p><p>The worst-case running time of Dijkstra's algorithm is <span class="strong"><strong>O</strong></span>(<span class="emphasis"><em>|E| + |V| log |V|</em></span>), where <span class="emphasis"><em>|V|</em></span> is the number of vertices and <span class="emphasis"><em>|E|</em></span> is the number of edges.</p></div></div></div>