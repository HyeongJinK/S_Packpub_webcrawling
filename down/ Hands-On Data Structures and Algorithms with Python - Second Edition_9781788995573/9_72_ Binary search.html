<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec72"></a>Binary search</h2></div></div><hr /></div><p>A <span>binary</span><a id="id325851480" class="indexterm"></a> search is a search strategy used to find elements within a <span class="strong"><strong>sorted</strong></span> array or list; thus, the binary search algorithm finds a given item from the given sorted list of items. It is a very fast and efficient algorithm to search an element, and the only drawback is that we need a sorted list. The worst-case running time complexity of a binary search algorithm is <code class="literal">O(log n)</code> whereas the linear search has <code class="literal">O(n)</code>.</p><p>A binary search algorithm works as follows. It starts searching the item by dividing the given list by half. If the search item is smaller than the middle value then it will look for the searched item only in the first half of the list, and if the search item is greater than the middle value it will only look at the second half of the list. We repeat the same process every time until we find the search item or we have checked the whole list.</p><p>Let's understand the binary search using an example. Suppose we have a book of 1,000 pages, and we want to reach the page number 250. We know that every book has its pages numbered sequentially from <code class="literal">1</code> upwards. So, according to the binary search analogy, we first check the search item 250 which is less than the 500 (which is the midpoint of the book). Thus, we search the required page only in the first half of the book. We again see the midpoint of the first half of the book, that is, using page 500 as a reference we find the midpoint, that is, 250. That brings us closer to finding the 250th page. And then we find the required page in the book. </p><p>Let's consider another example to understand the workings of binary search. We want to search for an item <span class="strong"><strong>43</strong></span> from a list of 12 items, as shown in the following diagram:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/a9650f96-4b60-411d-b567-dbdffe6129af.png" /></div><p>We start searching the item by comparing it to the middle item of the list, which is <span class="strong"><strong>37</strong></span> in the example. If the search item is less than the middle value we only look at the first half of the list; otherwise, we will look in the other half. So we only need to search for the item in the second half. We follow the same concept until we find the search item <span class="strong"><strong>43</strong></span> in the list as shown in the preceding diagram.</p><p>The following is the implementation of the binary search algorithm on an ordered list of items:</p><pre class="programlisting">def binary_search(ordered_list, term): 

    size_of_list = len(ordered_list) - 1 
    index_of_first_element = 0 
    index_of_last_element = size_of_list 
    while index_of_first_element &lt;= index_of_last_element: 
        mid_point = (index_of_first_element + index_of_last_element)//2 
        if ordered_list[mid_point] == term: 
            return mid_point 
        if term &gt; ordered_list[mid_point]: 
            index_of_first_element = mid_point + 1 
        else: 
            index_of_last_element = mid_point - 1 
    if index_of_first_element &gt; index_of_last_element: 
        return None</pre><p>Let's assume we have to find the position where item <span class="strong"><strong>10</strong></span> is located in the list as follows:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/bcbd741e-8251-4fc6-aa2b-ce6a2be391d2.png" /></div><p>The algorithm uses a <code class="literal">while</code> loop to iteratively adjust the limits in the list within which we have to find a search item. The terminating condition to stop the <code class="literal">while</code> loop is that the difference between the starting index, <code class="literal">index_of_first_element</code>, and the <code class="literal">index_of_last_element</code> index should be positive.</p><p>The algorithm first finds the midpoint of the list by adding the index of the first element (<span class="strong"><strong>0</strong></span>) to that of the last (<span class="strong"><strong>4</strong></span>) and dividing it by <span class="strong"><strong>2</strong></span> to find the middle index, <code class="literal">mid_point</code>:</p><pre class="programlisting">mid_point = (index_of_first_element + index_of_last_element)//2 </pre><p>In this case, the <span>midpoint</span><a id="id325578021" class="indexterm"></a> is <code class="literal">100</code>, and the value <span class="strong"><strong>10</strong></span> is not found at the middle position in the list. Since we are searching for the item <span class="strong"><strong>10</strong></span>, that is less than the midpoint, so it lies on the first half of the list, thus, we adjust the index range to be <code class="literal">index_of_first_element</code> to <code class="literal">mid_point-1</code> as shown in the following diagram, However, if we were searching for <span class="strong"><strong>120</strong></span>, in that case, as 120 is greater than the middle value (100), we would search the item in the second half of the list, and we need to change the list index range to be <code class="literal">mid_point +1 </code>to  <code class="literal">index_of_last_element</code>. It is shown in the following diagram: </p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/0c53084c-7c17-495e-ba2c-b7df75aec6b0.png" /></div><p>With our new indexes of <code class="literal">index_of_first_element</code> and <code class="literal">index_of_last_element</code> now being <span class="strong"><strong>0</strong></span> and <span class="strong"><strong>1</strong></span> respectively, we compute the midpoint <code class="literal">(0 + 1)/2</code>, which equals <code class="literal">0</code>. The new midpoint is <span class="strong"><strong>0</strong></span>, so we find the middle item and compare it with the search item, <code class="literal">ordered_list[0]</code>, which yields the value <span class="strong"><strong>10</strong></span>. Now, our search item is found, and the index position is returned.</p><p> </p><p>This reduction of our list size by half, by readjusting the index of <code class="literal">index_of_first_element</code> and <code class="literal">index_of_last_element</code>, continues as long as <code class="literal">index_of_first_element</code> is less than <code class="literal">index_of_last_element</code>. When this fails to be the case, it is most likely that our search term is not in the list.</p><p>The implementation we discussed is an iterative one. We can also <span>develop</span><a id="id325896339" class="indexterm"></a> a recursive variant of the algorithm by applying the same principle and shifting the pointers that mark the beginning and end of the search list. Consider the following code for it:</p><pre class="programlisting">def binary_search(ordered_list, first_element_index, last_element_index, term): 

    if (last_element_index &lt; first_element_index): 
        return None 
    else: 
        mid_point = first_element_index + ((last_element_index - first_element_index) // 2) 

        if ordered_list[mid_point] &gt; term: 
            return binary_search(ordered_list, first_element_index, mid_point-1,term) 
        elif ordered_list[mid_point] &lt; term: 
            return binary_search(ordered_list, mid_point+1, last_element_index, term) 
        else: 
            return mid_point </pre><p>A call to this recursive implementation of the binary search algorithm and its output is as follows:</p><pre class="programlisting">    store = [2, 4, 5, 12, 43, 54, 60, 77]
    print(binary_search(store, 0, 7, 2))   

Output:
<span class="strong"><strong>&gt;&gt; 0</strong></span></pre><p>Here, the only distinction between the recursive binary search and the iterative binary search is the function definition and also the way in which <code class="literal">mid_point</code> is calculated. The calculation for <code class="literal">mid_point</code> after the <code class="literal">((last_element_index - first_element_index) // 2)</code> operation must add its result to <code class="literal">first_element_index</code>. That way, we define the portion of the list to attempt the search.</p><p>The binary search algorithm has the worst-case time complexity of <code class="literal">O(log n)</code>. The half of the list on each iteration follows <code class="literal">log(n)</code> of the number of elements and their progression.</p><p> </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note11"></a>Note</h3><p>It goes without saying that <code class="literal">log x</code> is assumed to be referring to log base two.</p></div></div>