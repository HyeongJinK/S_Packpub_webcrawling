<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec67"></a>Priority queues and heaps</h2></div></div><hr /></div><p>A priority queue is a data structure which is <span>similar</span> to the queue and stack data structures that stores data along with the priority associated with it. In the <span>priority</span><a id="id326506676" class="indexterm"></a> queue, the item with the highest priority is served first. Priority queues are often implemented using a heap, since it is very efficient for this purpose; however, it can be implemented using other data structures. It is a modified queue that returns the items in the order of highest priority, whereas the queue returns the items in the order that the items were added. The priority queue is used in many applications, such as CPU scheduling.</p><p> </p><p> </p><p>Let's consider an example to demonstrate the importance of priority queues over regular queues. Assume that, in a store, customers queue in a line where service is rendered only at the front of the queue. Each customer will spend some time in the queue before getting served. If the units of time spent by four customers in the queue are 4, 30, 2, and 1 respectively, then the average time spent in the queue becomes<code class="literal">(4 + 34 + 36 + 37)/4</code>, which is<code class="literal">27.75</code>. However, if we associate the priority condition with the data stored in the queue, then we can give more priority to the customer that spends the least time. In this situation, the customers will be served in the order of time spent by the customers, that is, in the order of 1, 2, 4, then 30. Thus, the average waiting time would be <code class="literal">(1 + 3 + 7 + 37)/4</code>, which now equals<code class="literal">12</code>—a better average waiting time. Clearly, there is merit to serving the customers by the least time spent. This method of selecting the next item by priority, or some other criterion, is the basis for creating priority queues. Priority queues are mostly implemented using heaps. </p><p>A heap is a data <span>structure</span><a id="id326168203" class="indexterm"></a> that satisfies a heap property. A heap property states that there must be a certain relationship between a parent node and its child nodes. This property must apply throughout the entire heap.</p><p>In a min heap, the relationship between parent and children is that the value at the parent must always be less than or equal to its children. As a consequence of this, the lowest element in the heap must be the root node.</p><p><span>In a max heap, on the other hand, the</span> parent is greater than or equal to its child or its children. It follows from this that the largest value makes up the root node.</p><p>The heaps are binary trees, and although we are going to use a binary tree, we will actually use a list to represent it. The heap stores a complete binary tree. A complete binary tree is one in which each row must be fully filled before starting to fill the next row, as shown in the following diagram:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/c3d081fb-2e51-4f8a-bcd6-c4a7a5dda724.png" /></div><p>To make the math with indexes easier, we are going to leave the first item in the list (index 0) empty. After that, we place the tree nodes into the list, from top to bottom and left to right, as shown in the following diagram:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/a1ecf3dd-d7c7-4607-a924-8d1ef2c61a33.png" /></div><p>If you observe carefully, you will notice that you can retrieve the children of any node at the <code class="literal">n</code>index very easily. The left child is located at <code class="literal">2n</code>, and the right child is located at <code class="literal">2n + 1</code>. This will always hold true. For example, the C node would be at the <code class="literal">3</code> index, as <span class="strong"><strong>C</strong></span> is a right child of the <span class="strong"><strong>A</strong></span> node, whose index is <code class="literal">1</code>, so it becomes <code class="literal">2n+1 = 2*1 + 1 = 3</code>.</p><p>Let's discuss the implementation of the min heap using Python, as implementing the max heap will be more straightforward once we understand the min heap. We start with the heap class, as follows: </p><pre class="programlisting">     class Heap: 
        def __init__(self): 
            self.heap = [0] 
            self.size = 0 </pre><p>We initialize our heap list with a zero to represent the dummy first element (remember that we are only doing this to make the math simpler). We <span>also</span><a id="id326506650" class="indexterm"></a> create a variable to hold the size of the heap. This would not be necessary as such, since we could check the <span>size</span><a id="id326506657" class="indexterm"></a> of the list, but we would always have to remember to reduce it by one. So, we choose to keep a separate variable instead.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec60"></a>Insert operation</h3></div></div></div><p>Inserting an item to the min heap works in two steps. First, we add the new element to the end of the list (which we understand to be the bottom of the tree), and we increment the <span>size</span><a id="id326506673" class="indexterm"></a> of the heap by one. Secondly, after each insertion operation, we need to arrange the new element up in the heap tree, to organize all the nodes in such a way that it satisfies the heap property. This is to remind us that the lowest element in the min-heap needs to be the root element. </p><p>We first create a helper method, called <code class="literal">arrange</code>, that takes care of arranging all the nodes after insertion. Let's consider an example of adding an element in the min heap. We provide an example heap in the following diagram, and want to insert the value of <code class="literal">2</code> in it:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/db32ce0c-3773-43b3-8bae-8c8280551620.png" /></div><p>The new element has occupied the last slot in the third row or level. Its index value is <span class="strong"><strong>7</strong></span>. Now we compare that value with its parent. The parent is at index <code class="literal">7/2 = 3</code> (integer division). That element holds <span class="strong"><strong>6</strong></span>, so we swap the <span class="strong"><strong>2</strong></span>, as follows:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/b0e1a754-9024-443f-b9d4-631616cb04f7.png" /></div><p>Our new element has been swapped and moved up to the <span class="strong"><strong>3 </strong></span>index. We have not reached the top of the heap yet (<span class="emphasis"><em>3/2 &gt; 0</em></span>), so we continue. The new parent of our element is at index <span class="emphasis"><em>3/2=1</em></span>. So we compare and, if necessary, swap again:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/fed9bd70-457e-4e39-92e1-e4cc7543b26d.png" /></div><p>After the final swap, we <span>are</span><a id="id326514371" class="indexterm"></a> left with a heap that looks as follows. Notice that it adheres to the definition of a heap:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/04e56b1a-d773-4eb5-8745-0ddae376a8dc.png" /></div><p>Here is the implementation of <code class="literal">arrange()</code> method after we insert an element into the min-heap:</p><pre class="programlisting">    def arrange(self, k): </pre><p>We are going to loop until we have reached the root node, so that we can keep arranging the element up as high as it needs to go. Since we are using integer division, as soon as we get below <code class="literal">2</code>, the loop will break out:</p><pre class="programlisting">        while k // 2 &gt; 0: </pre><p>Compare between the parent and child. If the parent is greater than the child, swap the two values:</p><pre class="programlisting">        if self.heap[k] &lt; self.heap[k//2]: 
            self.heap[k], self.heap[k//2] = self.heap[k//2], 
            self.heap[k] </pre><p>Finally, let's not forget to move up the tree:</p><pre class="programlisting">        k //= 2 </pre><p>This method ensures that the elements are ordered properly.</p><p> </p><p>Now, we just need to call this from our <code class="literal">insert</code> method:</p><pre class="programlisting">    def insert(self, item): 
        self.heap.append(item) 
        self.size += 1 
        self.arrange(self.size) </pre><p>Notice that the last line in <code class="literal">insert</code> calls the <code class="literal">arrange()</code> method to reorganize the <span>heap</span><a id="id326604733" class="indexterm"></a> as necessary.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec61"></a>Pop operation</h3></div></div></div><p>The <code class="literal">pop</code> operation removes an <span>element</span><a id="id326604763" class="indexterm"></a> from the heap. The reason for removing an element from the min-heap is, first, to find out the index of the item to be deleted, and then organize the heap so that it satisfies the heap property. However, it is more common to pop off the minimum value from the min-heap, and as per the property of the min-heap, we can get the minimum value by its root value. Therefore, to obtain and remove the minimum value from the min-heap, we remove the root node and re-organize all the nodes of the heap. We also decrement the size of the heap by one.</p><p>However, once the root has been popped off, we need a new root node. For this, we just take the last item from the list and make it the new root. That is, we move it to the beginning of the list. However, the selected last node might not be the lowest element of the heap, so we have to reorganize the nodes of the heap. To structure all the nodes according to the min-heap property, we follow a strategy that is opposite to the <code class="literal">arrange()</code> method that we used while inserting an element into the heap. We make the last node a new root, and then we let it move down (or sink down) as required.</p><p>Let's consider an example to help understand this concept in the following heap. First, we pop off the <code class="literal">root</code> element:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/581e8586-67de-4cb0-9a1e-f7c34a1d44d2.png" /></div><p>If we choose to move up one of the children of the root, we will have to figure out how to rebalance the entire tree structure, which would have been more complex. So, instead, we do something really interesting. We move up the very last element in the list to fill the position of the <code class="literal">root</code> element; for example, the last element, <span class="strong"><strong>6</strong></span>, is placed at the root position in the following heap example:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/b1752d17-60dc-4074-88a3-eb99001b4fc1.png" /></div><p>Now, this element is clearly not the lowest in the heap. So, we have to sink it down in the heap. Firstly, we need to determine whether to sink it down toward either the left or right child. We compare the two children, so that the lowest element will be the one to move up as the root sinks down. In the example, we compare the two children of the root, that is, <span class="strong"><strong>5</strong></span> and<span class="strong"><strong>3</strong></span>:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/e63db81e-5e38-48b4-a676-1a08ffbd22b1.png" /></div><p>The right child is <span>clearly</span><a id="id326604857" class="indexterm"></a> smaller: its index is <span class="strong"><strong>3</strong></span>, which represents <span class="emphasis"><em>root index * 2 + 1</em></span>. We go ahead and compare our new root node with the value at this index, as follows:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/db001cc8-572e-4998-acb0-eeb5eab20e6f.png" /></div><p> </p><p>Now our node has moved down to index <span class="strong"><strong>3</strong></span>. We need to compare it to the lesser of its children. However, now we only have one child, so we don't need to worry about which child to compare it against (for a min heap, it is always the lesser child):</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/a7b05b36-c0de-4cac-a372-cc111de804b2.png" /></div><p>There is no need to swap here. Since there are no more rows, we don't need to do anything else. Notice here that, after the <code class="literal">sink()</code> operation is completed, the heap adheres to our definition of a heap.</p><p>Now we can begin implementing this. But before we implement the <code class="literal">sink()</code> method, we need to note how we determine which of the children to compare against the parent node. Let's put that selection in its own little method, just to make the code look a little simpler:</p><pre class="programlisting">    def minindex(self, k): </pre><p>We may get beyond the end of the list—if we do, then we return the index of the left child:</p><pre class="programlisting">        if k * 2 + 1 &gt; self.size: 
            return k * 2 </pre><p>Otherwise, we simply return the index of the lesser of the two children:</p><pre class="programlisting">        elif self.heap[k*2] &lt; self.heap[k*2+1]: 
            return k * 2 
        else: 
            return k * 2 + 1</pre><p>Now we can create the <code class="literal">sink</code> function. As we did before, we are going to loop so that we can sink our element down as far as is needed:</p><pre class="programlisting">    def sink(self, k): 
          while k*2 &lt;- self.size: </pre><p>Next, we need to know which of <span>the</span><a id="id326613702" class="indexterm"></a> left or the right children to compare against. This is where we make use of the <code class="literal">minindex()</code> function:</p><pre class="programlisting">            mi = self.minindex(k)</pre><p>As we did in the <code class="literal">arrange()</code> method during the insertion operation, we compare parent and child to see whether we need to make the swap:</p><pre class="programlisting">            if self.heap[k] &gt; self.heap[mi]: 
                self.heap[k], self.heap[mi] = self.heap[mi], 
                self.heap[k] </pre><p>And we need to make sure that we move down the tree, so that we don't get stuck in a loop, as follows:</p><pre class="programlisting">            k = mi </pre><p>The only thing remaining now is to implement the main <code class="literal">pop()</code> method itself. This is very straightforward, as the grunt work is performed by the <code class="literal">sink()</code> method:</p><pre class="programlisting">    def pop(self): 
        item = self.heap[1] 
        self.heap[1] = self.heap[self.size] 
        self.size -= 1 
        self.heap.pop() 
        self.sink(1) 
        return item</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec62"></a>Testing the heap</h3></div></div></div><p>Now, let's test <span>the</span><a id="id326613824" class="indexterm"></a> implementation of the heap, and discuss this with an example. We start with the construction of a heap by inserting 10 elements, one by one. Let the elements be <code class="literal">{4, 8, 7, 2, 9, 10, 5, 1, 3, 6}</code>. First, we manually create a heap with these elements, and then we will implement it and verify if we are doing it correctly or not:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/d543281f-1596-41f0-8ed9-69d6424563c8.png" /></div><p>We show, in the preceding diagram, a step-by-step <span>process</span><a id="id326613872" class="indexterm"></a> to insert elements in the heap. Here, we continue adding elements as shown:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/bf13d322-25ab-4a75-babb-e8a3f2ca1192.png" /></div><p>Finally, we insert an element, <span class="strong"><strong>6</strong></span>, to the heap:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/8aefd2c1-6a92-4a8f-a7ee-3e1bbef00e2d.png" /></div><p>Now, let's begin by creating the heap and inserting that data, as shown in <span>the</span><a id="id326640947" class="indexterm"></a> following code:</p><pre class="programlisting">    h = Heap() 
    for i in (4, 8, 7, 2, 9, 10, 5, 1, 3, 6): 
        h.insert(i) </pre><p>We can print the heap list, just to inspect how the elements are ordered. If you redraw this as a tree structure, you would notice that it meets the required properties of a heap, similar to what we created manually:</p><pre class="programlisting">    print(h.heap) </pre><p>Now we will pop off the items, one at a time. Notice how the items come out in a sorted order, from lowest to highest. Also, notice how the heap list changes after each <code class="literal">pop</code>. The <code class="literal">sink()</code> method will reorganize all the items in the heap:</p><pre class="programlisting">    for i in range(10): 
        n = h.pop() 
        print(n) 
        print(h.heap) </pre><p>We have discussed, in the preceding section, the concepts around using the min-heap, so it should be a simple task to implement a max-heap by simply reversing the logic.</p><p> </p><p>We will use the min-heap that we discussed here again in <a class="link" href="#" linkend="ch10">Chapter 10</a>, <span class="emphasis"><em>Sorting</em></span>, on sorting algorithms, and will rewrite the code for sorting the elements in the list. These algorithms are called heap sort algorithms.</p></div></div>