<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch10lvl1sec77"></a>Bubble sort algorithms</h2></div></div><hr /></div><p>The idea behind the bubble sort <span>algorithm</span><a id="id325990115" class="indexterm"></a> is very simple. Given an <span>unordered</span><a id="id325989350" class="indexterm"></a> list, we compare adjacent elements in the list, and after each comparison, place them in the right order of magnitude. This works by swapping adjacent items if they are not in the correct order. The process is repeated <code class="literal">n-1</code> times for a list of <code class="literal">n</code> items. In each such iteration, the largest element is arranged in the end. For example, in the first iteration, the largest element would be placed in the last position of the list, and again, the same process will be followed for the remaining <code class="literal">n-1</code> items. In the second iteration, the second largest element will be placed at the second-to-last position in the list, and the process will then be repeated until the list is sorted.</p><p>Let's take a list with only two elements, {<span class="strong"><strong>5</strong></span>, <span class="strong"><strong>2</strong></span>}, to understand the concept of the bubble sort, as shown in the following diagram:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/f11d1d8a-7bf2-4945-abe5-eda2d0982d65.png" /></div><p>To sort this list, we simply swap the values into the right positions, with <span class="strong"><strong>2</strong></span> occupying index <span class="strong"><strong>0</strong></span> and <span class="strong"><strong>5</strong></span> occupying index <span class="strong"><strong>1</strong></span>. To effectively swap these elements, we need to have a temporary storage area:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/faf042dd-6b60-48db-aa1e-86dafe10ff52.png" /></div><p>Implementation of the bubble sort <span>algorithm</span><a id="id325855573" class="indexterm"></a> starts with the swap method, <span>illustrated</span><a id="id325855579" class="indexterm"></a> in the preceding diagram. First, element <span class="strong"><strong>5</strong></span> will be copied to a temporary location, <code class="literal">temp</code>. Then, element <span class="strong"><strong>2</strong></span> will be moved to index <span class="strong"><strong>0</strong></span>. Finally, <span class="strong"><strong>5</strong></span> will be moved from temp to index <span class="strong"><strong>1</strong></span>. At the end of it all, the elements will have been swapped. The list will now contain the elements as <code class="literal">[2, 5]</code>. The following code will swap the elements of <code class="literal">unordered_list[j]</code> with <code class="literal">unordered_list[j+1]</code> if they are not in the right order:</p><pre class="programlisting">    temp = unordered_list[j] 
    unordered_list[j] = unordered_list[j+1] 
    unordered_list[j+1] = temp </pre><p>Now that we have been able to swap a two-element array, it should be simple to use this same idea to sort a whole list.</p><p>Let's consider another example to understand the working of <span>bubble</span><a id="id325895053" class="indexterm"></a> sort algorithm to sort an unordered list of <span class="strong"><strong>6</strong></span> elements, such as {<span class="strong"><strong>45</strong></span>, <span class="strong"><strong>23</strong></span>, <span class="strong"><strong>87</strong></span>, <span class="strong"><strong>12</strong></span>, <span class="strong"><strong>32</strong></span>, <span class="strong"><strong>4</strong></span>}. In the first iteration, we start comparing the first two elements, <span class="strong"><strong>45</strong></span> and <span class="strong"><strong>23</strong></span>, and we swap them, as <span class="strong"><strong>45</strong></span> should be placed after <span class="strong"><strong>23</strong></span>. Then, we compare the next adjacent values, <span class="strong"><strong>45</strong></span> and <span class="strong"><strong>87</strong></span>, to see whether they are in the correct order. Swap them if they are not in the correct order. We can see, in the following diagram, that after the first iteration of the <span>bubble</span><a id="id325898382" class="indexterm"></a> sort, the largest element, <span class="strong"><strong>87</strong></span>, is placed in the last position of the list:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/63f8ad71-6c54-46fe-b150-28ca0266aea8.png" /></div><p>After the first iteration, we just need to arrange the remaining <code class="literal">(n-1)</code> elements; we repeat the same process by comparing the adjacent elements for the remaining five elements. After the second iteration, the second largest element, <span class="strong"><strong>45</strong></span>, is placed at the second-to-last position in the list, as shown in the following diagram:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/be7d84e8-bc6b-431f-847f-c4f00817583c.png" /></div><p> </p><p>Next, we have to <span>compare</span><a id="id325967581" class="indexterm"></a> the remaining <code class="literal">(n-2)</code> elements to arrange them as <span>shown</span><a id="id325967593" class="indexterm"></a> in the following diagram:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/450b7da2-5518-4841-a8c8-4dea2ce76421.png" /></div><p>Similarly, we compare the remaining elements to sort them, as well:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/e0565a85-f87e-4602-bdd2-4aeba6f68158.png" /></div><p>Finally, in the last two remaining elements, we place them in the correct order to obtain the final sorted list, as shown in the following diagram:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/820186dd-03da-4b99-a4ef-15ac1210afce.png" /></div><p>The implementation of the bubble sort algorithm would work in a double-nested loop, where the inner loop repeatedly compares and swaps the adjacent elements in each iteration for a given list, and the outer loop keeps track of how many times the inner loop should be repeated. The implementation of the inner loop is as follows:</p><pre class="programlisting">    for j in range(iteration_number): 
        if unordered_list[j] &gt; unordered_list[j+1]: 
            temp = unordered_list[j] 
            unordered_list[j] = unordered_list[j+1] 
            unordered_list[j+1] = temp</pre><p>It is important to know, when implementing a bubble sort algorithm, how many times the loop will need to run to complete all swaps. To sort a list of three numbers, for example, <code class="literal">[3, 2, 1]</code>, we need to swap the elements a maximum of two times. This is equal to the length of the list minus 1, and could be written as <code class="literal">iteration_number = len(unordered_list)-1</code>. We subtract 1 because it gives us exactly the maximum number of iterations to run. Let's show this with the following example, where, in a list of 3 numbers, by swapping the adjacent elements in exactly two iterations, the largest number ends up at the last position in the list:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/af7917c0-3fa4-4e1f-9e48-e4eeb887b861.png" /></div><p>The <code class="literal">if</code> statement makes sure that no unnecessary swaps occur if two adjacent elements are already in the right order. The inner <code class="literal">for</code> loop only causes the swapping of adjacent elements to occur exactly twice in our list.</p><p> How many times does this <span>swapping</span><a id="id325990132" class="indexterm"></a> operation have to occur in order for the entire list to be sorted? We know that, if we repeat the whole process of swapping the adjacent elements a <span>number</span><a id="id325990140" class="indexterm"></a> of times, the list will be sorted. An outer loop is used to make this happen. The swapping of elements in the list results in the following dynamics:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/40701fed-2f32-4aa4-a0bd-38fd35e52e05.png" /></div><p>We recognize that a total of four comparisons at most were needed to get our list sorted. Therefore, both inner and outer loops have to run <code class="literal">len(unordered_list)-1</code> times for all elements to be sorted, as shown:</p><pre class="programlisting">iteration_number = len(unordered_list)-1 
    for i in range(iteration_number): 
        for j in range(iteration_number): 
            if unordered_list[j] &gt; unordered_list[j+1]: 
                temp = unordered_list[j] 
                unordered_list[j] = unordered_list[j+1] 
                unordered_list[j+1] = temp</pre><p>The same principle is used even if the list contains many elements. There are a lot of variations of the bubble sort, too, that minimize the number of iterations and comparisons.</p><p>For example, there is a variant of the bubble sort algorithm where, if there is no <span>swapping</span><a id="id326096236" class="indexterm"></a> within the inner loop, we simply quit the entire sorting process, because the absence of any <span>swapping</span><a id="id326096245" class="indexterm"></a> operation in the inner loop suggests that the list has already been sorted. In a way, this can help speed up the algorithm.</p><p>The bubble sort is an inefficient sorting algorithm that provides worst-case and average-case runtime complexity of <code class="literal">O(n<sup>2</sup>)</code>, and a best-case complexity of <code class="literal">O(n)</code>. Generally, the bubble sort algorithm should not be used to sort large lists. However, on relatively small lists, it performs fairly well.</p></div>