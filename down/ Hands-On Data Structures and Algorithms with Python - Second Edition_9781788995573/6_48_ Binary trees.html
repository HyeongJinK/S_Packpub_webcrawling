<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec51"></a>Binary trees</h2></div></div><hr /></div><p>A binary tree is one in which each node has a maximum of two children. The nodes in the binary tree are organized in the form of left sub-tree and right sub-tree. If the <span>tree</span><a id="id325896256" class="indexterm"></a> has a root, R, and two sub-trees, that is, left sub-tree <code class="literal">T1</code>, and right sub-tree <code class="literal">T2</code>, then their roots are called <code class="literal">left successor</code> and <code class="literal">right successor</code>, respectively. </p><p>The following diagram is an example of a binary tree with five nodes:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/3c78b22f-ba86-44e1-ba76-4b896b7ff2fb.png" /></div><p>Here are the following observations that we have made regarding the preceding diagram: </p><p> </p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Each node holds a reference to a right and left node if the nodes do not exist</li><li style="list-style-type: disc">The root node is denoted with <span class="strong"><strong>5</strong></span></li><li style="list-style-type: disc">The root node has two sub-trees, where the left sub-tree has one node, that is, a node with a value of <span class="strong"><strong>3</strong></span>, and the right sub-tree has three nodes with the values <span class="strong"><strong>7</strong></span>, <span class="strong"><strong>6</strong></span>, and <span class="strong"><strong>9</strong></span></li><li style="list-style-type: disc">The node with a value of <span class="strong"><strong>3</strong></span> is a left successor node, whereas the node with a value of <span class="strong"><strong>7</strong></span> is the right successor</li></ul></div><p>A regular binary tree has no other rules as to how elements are arranged in the tree. It should only satisfy the condition that each node should have a maximum of two children.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec38"></a>Binary search trees</h3></div></div></div><p>A <span class="strong"><strong>binary search tree</strong></span> (<span class="strong"><strong>BST</strong></span>) is a special kind of binary tree. It is one of the most important and commonly used data structures in computer science applications. A binary search <span>tree</span><a id="id326410136" class="indexterm"></a> is a tree that is structurally a binary tree, and stores data in its nodes very efficiently. It provides very fast search operations, and other operations such as insertion and deletion are also very easy and convenient.</p><p>A binary tree is called a binary search tree if the value at any node in the tree is greater than the values in all the nodes of its left sub-tree, and less than or equal to the values of all the nodes of the right sub-tree. For example, if <span class="strong"><strong>K1</strong></span>, <span class="strong"><strong>K2</strong></span>, and <span class="strong"><strong>K3</strong></span> are key values in a tree of three nodes (as shown in the following diagram), then it should satisfy the following conditions:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>The key values of <span class="emphasis"><em>K2&lt;=K1</em></span></li><li>The key values <span class="emphasis"><em>K3&gt;K1</em></span></li></ol></div><p>The following diagram depicts this:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/4d20f3c7-7324-447b-a1c2-53f161a51768.png" /></div><p>Let's consider another example so that we have a better understanding of binary search trees. Consider the following tree:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/81463842-3ccf-482c-b924-cfaa7980e30c.png" /></div><p>This is an example of a BST. In this tree, all of the nodes in the left sub-tree are less than or equal to the value of that node. Also, all of the nodes in the right sub-tree of this node are greater than that of the parent node. </p><p>Testing our tree for the properties of a BST, we notice that all of the nodes in the left sub-tree of the root node have a value less than 5. Likewise, all the nodes in the right sub-tree have a value that is greater than 5. This property applies to all the nodes in a BST, with no exceptions.</p><p>Considering another example of a binary tree, let's see if it is a <span>binary</span><a id="id325644877" class="indexterm"></a> search tree or not. Despite the fact that the following diagram looks similar to the previous diagram, it does not qualify as a BST as node <span class="strong"><strong>7</strong></span> is greater than the root node <span class="strong"><strong>5</strong></span>; however, it is located to the left of the root node. Node <span class="strong"><strong>4</strong></span> is to the right sub-tree of its parent node <span class="strong"><strong>7</strong></span>, which is incorrect. Thus, the following diagram is not a binary search tree:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/490d8d36-ecb9-4df2-8004-a702efb88650.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec39"></a>Binary search tree implementation</h3></div></div></div><p>Let's begin the implementation of a <span>BST</span><a id="id325837818" class="indexterm"></a> in Python. We need to keep track of the root node of the tree, so we start by creating a <code class="literal">Tree</code> class that holds a reference to the root node:</p><pre class="programlisting">    class Tree: 
        def __init__(self): 
            self.root_node = None </pre><p>That's all that is needed to maintain the state of a tree. Let's examine the main operations on the tree in the next section.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec40"></a>Binary search tree operations</h3></div></div></div><p>The operations that can be performed on a <span>binary</span><a id="id325855476" class="indexterm"></a> search tree are <code class="literal">insert</code>, <code class="literal">delete</code>, <code class="literal">finding min</code>, <code class="literal">finding max</code>, <code class="literal">searching</code>, and so on. We will discuss them in subsequent subsections.</p><p> </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec44"></a>Finding the minimum and maximum nodes</h4></div></div></div><p>The structure of the binary search tree makes <span>searching</span><a id="id325855510" class="indexterm"></a> a node that has a maximum or a minimum value very easy. </p><p>To find a node that has the smallest value in the tree, we start traversal from the root of the tree and visit the left node each time until we reach the end of the tree. Similarly, we traverse the right sub-tree recursively until we reach the end to find the node with the biggest value in the tree.</p><p>For example, consider the <span>following</span><a id="id325855557" class="indexterm"></a> diagram; we move down from node <span class="strong"><strong>6</strong></span> to <span class="strong"><strong>3</strong></span> and then from node <span class="strong"><strong>3</strong></span> to <span class="strong"><strong>1</strong></span> to find the node with the smallest value. Similarly, to find the maximum value node from the tree, we go down from the root to the right-hand side of the tree, then go from node <span class="strong"><strong>6</strong></span> to node <span class="strong"><strong>8</strong></span> and then node <span class="strong"><strong>8</strong></span> to node <span class="strong"><strong>10</strong></span> to find the node with the largest value. Here is an example BST tree:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/4ccfe2a8-e944-4bb1-9a57-4aa580e8b6e7.png" /></div><p>This concept of finding the minimum and maximum nodes applies to sub-trees, too. Thus, the minimum node in the sub-tree with root node<span class="strong"><strong>8</strong></span> is node<span class="strong"><strong>7</strong></span>. Similarly, the node that has the maximum value within that sub-tree is<span class="strong"><strong>10</strong></span>.</p><p>The Python implementation of the method that returns the minimum node is as follows:</p><pre class="programlisting">    def find_min(self): 
        current = self.root_node 
        while current.left_child: 
            current = current.left_child 

        return current </pre><p>The <code class="literal">while</code> loop continues to get the left node and visits it until the last left node points to <code class="literal">None</code>. It is a very simple method.</p><p> </p><p>Similarly, the following is the code of the method that returns the maximum node:</p><pre class="programlisting">    def find_max(self): 
        current = self.root_node 
        while current.right_child: 
            current = current.right_child 

        return current </pre><p>The running time complexity to find the minimum or maximum value in a BST is O(<span class="emphasis"><em>h</em></span>), where <code class="literal">h</code> is the height of the tree.</p><p>There are essentially two other operations, that is, <code class="literal">insert</code> and <code class="literal">delete</code>, and they are very important for BST. It is important to ensure that we maintain the property of the BST tree while applying these operations on the tree.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec41"></a>Inserting nodes</h3></div></div></div><p>One of the most important operations to implement on a <span>binary</span><a id="id325896341" class="indexterm"></a> search tree is to insert data items in the tree. As we have already discussed, regarding the properties of the binary search tree, for each node in the tree, the left child nodes should contain the data less than their own value and the right child nodes should have data greater than their value. So, we have to ensure that the property of the binary search tree satisfies whenever we insert an item in the tree.</p><p>For example, let's create a binary search tree by inserting data items <span class="strong"><strong>5</strong></span>, <span class="strong"><strong>3</strong></span>, <span class="strong"><strong>7</strong></span>, and <span class="strong"><strong>1</strong></span> in the tree. Consider the following:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><span class="strong"><strong>Insert 5:</strong></span> We start with the first data item, <span class="strong"><strong>5</strong></span>. To do this, we will create a node with its data attribute set to <span class="strong"><strong>5</strong></span>, since it is the first node.</li><li><span class="strong"><strong>Insert 3:</strong></span>Now, we want to add the second node with value <span class="strong"><strong>3</strong></span> so that data value <span class="strong"><strong>3</strong></span> is compared with the existing node value, <span class="strong"><strong>5</strong></span>, of the root node:</li></ol></div><p> </p><p>Since the node value <span class="strong"><strong>3</strong></span> is less than <span class="strong"><strong>5</strong></span>, it will be placed in the left sub-tree of node <span class="strong"><strong>5</strong></span>. Our BST will look as follows:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/57aeb4e8-342d-4155-aaa8-a4233ffdcf9d.png" /></div><p>The tree satisfies the BST rule, where all the nodes in the left sub-tree are less than the parent.</p><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li><span class="strong"><strong>Insert 7:</strong></span> To add another node of value <span class="strong"><strong>7</strong></span> to the tree, we start from the root node with value <span class="strong"><strong>5</strong></span> and make a comparison:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788995573/graphics/610f226f-5e02-43d6-a7fa-f0c60671e1bd.png" /></div><p>Since <span class="strong"><strong>7</strong></span> is greater than <span class="strong"><strong>5</strong></span>, the node with value <span class="strong"><strong>7</strong></span> is placed to the right of this root. </p><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li><span class="strong"><strong>Insert 1:</strong></span> Let's add <span>another</span><a id="id326168233" class="indexterm"></a> node with value <span class="strong"><strong>1</strong></span>. Starting from the root of the tree, we make a comparison between <span class="strong"><strong>1</strong></span> and <span class="strong"><strong>5</strong></span>:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788995573/graphics/a5053f3f-fdb1-4e8c-a2d2-29fb58943b44.png" /></div><p>This comparison shows that <span class="strong"><strong>1</strong></span> is less than <span class="strong"><strong>5</strong></span>, so we go to the left node of <span class="strong"><strong>5</strong></span>, which is the node with a value of <span class="strong"><strong>3</strong></span>:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/776df6d2-fccd-45d8-80b0-9da830fd4ac0.png" /></div><p>When we compare <span class="strong"><strong>1</strong></span> with <span class="strong"><strong>3</strong></span>, since <span class="strong"><strong>1</strong></span> is less than <span class="strong"><strong>3</strong></span>, we move a level below node <span class="strong"><strong>3</strong></span> and to its left. However, there is no node there. Therefore, we create a node with the value <span class="strong"><strong>1</strong></span> and associate it with the left pointer of node <span class="strong"><strong>3</strong></span> to obtain the following structure. Here, we have the final binary search tree of <span class="strong"><strong>4</strong></span> nodes:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/431e2abc-bde5-48bd-99ff-f0cfba86c2bb.png" /></div><p> </p><p>We can see that this example contains only integers or numbers. So, if we need to store the string data in the binary search tree, in this case strings would be compared alphabetically. And, if we want to store our own custom data types inside a BST, we will have to make sure that our class supports ordering.</p><p>The Python implementation of the <code class="literal">insert</code> method to add the nodes in the BST is given as follows:</p><pre class="programlisting">def insert(self, data):
    node = Node(data) 
    if self.root_node is None: 
        self.root_node = node 
    else: 
        current = self.root_node 
        parent = None  
    while True: 
        parent = current 
        if node.data &lt; parent.data: 
            current = current.left_child 
            if current is None: 
                    parent.left_child = node 
                    return 
            else: 
                    current = current.right_child 
                    if current is None: 
                        parent.right_child = node 
                        return</pre><p>Now, let's understand each of the <span>instructions</span><a id="id326214777" class="indexterm"></a> of this <code class="literal">insert</code> function, step by step. We will begin with a function declaration:</p><pre class="programlisting">    def insert(self, data):</pre><p> </p><p>By now, you will be used to the fact that we encapsulate the data in a node. This way, we hide away the <code class="literal">node</code> class from the client code, who only needs to deal with the tree:</p><pre class="programlisting">        node = Node(data) </pre><p>A first check will be done to find out whether we have a root node. If we don't, the new node becomes the root node (we cannot have a tree without a root node):</p><pre class="programlisting">        if self.root_node is None: 
            self.root_node = node 
        else: </pre><p>As we walk down the tree, we need to keep track of the current node we are working on, as well as its parent. The <code class="literal">current</code> variable is always used for this purpose:</p><pre class="programlisting">        current = self.root_node 
        parent = None 
        while True: 
            parent = current </pre><p>Here, we must perform a comparison. If the data held in the new node is less than the data held in the current node, then we check whether the current node has a left child node. If it doesn't, this is where we insert the new node. Otherwise, we keep traversing:</p><pre class="programlisting">        if node.data &lt; current.data: 
            current = current.left_child 
            if current is None: 
                parent.left_child = node 
                return </pre><p>Now, we need to take care of the greater than or equal case. If the current node doesn't have a right child node, then the new node is inserted as the right <span>child</span><a id="id326409672" class="indexterm"></a> node. Otherwise, we move down and continue looking for an insertion point:</p><pre class="programlisting">        else: 
            current = current.right_child 
            if current is None: 
                parent.right_child = node 
                return </pre><p>Insertion of a node in a BST takes <code class="literal">O(h)</code>, where <code class="literal">h</code> is the height of the tree.</p><p> </p><p> </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec42"></a>Deleting nodes</h3></div></div></div><p>Another important operation on a BST is the <code class="literal">deletion</code> or <code class="literal">removal</code> of nodes. There are three scenarios that we need to cater for during this process. The node that we want to remove might have the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>No children</strong></span>: If there is no leaf node, directly remove the node</li><li style="list-style-type: disc"><span class="strong"><strong>One child</strong></span>: In this case, we swap the <span>value</span><a id="id325987779" class="indexterm"></a> of that node with its child, and then delete the node</li><li style="list-style-type: disc"><span class="strong"><strong>Two children</strong></span>: In this case, we first find the in-order successor or predecessor, swap the value with it, and then delete that node</li></ul></div><p>The first scenario is the easiest to handle. If the node about to be removed has no children, we simply remove it from its parent:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/9d186716-481a-4334-833c-6368ecaa914d.png" /></div><p>In the preceding example, node <span class="strong"><strong>A</strong></span> has no children, so we will simply delete it from its parent, that is, node <span class="strong"><strong>Z</strong></span>.</p><p>On the other hand, when the node we want to remove has one child, the parent of that node is made to point to the child of that particular node. Let's take a look at the following diagram, where we want to delete node <span class="strong"><strong>6</strong></span> who has one child, that is, node <span class="strong"><strong>5</strong></span>:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/06dd54b6-cf45-4f5d-8e87-fdf9f727d729.png" /></div><p>In order to delete node <span class="strong"><strong>6</strong></span>, which has node <span class="strong"><strong>5</strong></span> as its only child, we point the left pointer of node <span class="strong"><strong>9</strong></span> to node <span class="strong"><strong>5</strong></span>. Here, we need to ensure that the child and parent relationship follows the properties of a binary search tree.</p><p>A more complex scenario arises when the node we want to delete has two children. Consider the following example tree, where we want to delete node <span class="strong"><strong>9</strong></span>, which has two children:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/a5757eca-80a1-4494-a474-6538bf2ec217.png" /></div><p>We cannot simply replace node <span class="strong"><strong>9</strong></span> with either node <span class="strong"><strong>6</strong></span> or <span class="strong"><strong>13</strong></span>. What we need to do is find the next biggest descendant of node <span class="strong"><strong>9</strong></span>. This is node <span class="strong"><strong>12</strong></span>. To get to node <span class="strong"><strong>12</strong></span>, we move to the right node of node <span class="strong"><strong>9</strong></span>. Then, we move left to find the leftmost node. Node <span class="strong"><strong>12</strong></span> is called the in-order successor of node <span class="strong"><strong>9</strong></span>. The second step resembles the move to find the maximum node in a sub-tree.</p><p>We replace the <span>value</span><a id="id325999319" class="indexterm"></a> of node <span class="strong"><strong>9</strong></span> with the value <span class="strong"><strong>12</strong></span> and remove node <span class="strong"><strong>12</strong></span>. Upon removing node <span class="strong"><strong>12</strong></span>, we end up with a simpler form of node removal that was addressed previously. Node 12 has no children, so we apply the rule for removing nodes without children accordingly.</p><p>Our <code class="literal">node</code> class does not have a reference to a parent. As such, we need to use a helper method to <code class="literal">search</code> and return the node with its parent node. This method is similar to the <code class="literal">search</code> method:</p><pre class="programlisting">    def get_node_with_parent(self, data): 
        parent = None 
        current = self.root_node 
        if current is None: 
            return (parent, None) 
        while True: 
            if current.data == data: 
                return (parent, current) 
            elif current.data &gt; data: 
                parent = current 
                current = current.left_child 
            else: 
                parent = current 
                current = current.right_child 

        return (parent, current) </pre><p>The only difference is that before we update the current variable inside the loop, we store its parent with <code class="literal">parent = current</code>. The method to do the actual removal of a node begins with this search:</p><pre class="programlisting">    def remove(self, data): 
        parent, node = self.get_node_with_parent(data) 

        if parent is None and node is None: 
            return False 

        # Get children count 
        children_count = 0 

        if node.left_child and node.right_child: 
            children_count = 2 
        elif (node.left_child is None) and (node.right_child is None): 
            children_count = 0 
        else: 
            children_count = 1 </pre><p>We pass the parent and the found nodes to <code class="literal">parent</code> and <code class="literal">node</code>, respectively with the <code class="literal">parent, node = self.get_node_with_parent(data)</code> line. It is important to know the number of children that the node has that we want to delete, and we do so in the <code class="literal">if</code> statement.</p><p>After we know the number of children a node has that we want to delete, we need to handle various conditions in which a node can be deleted. The first part of the <code class="literal">if</code> statement handles the case where the node has no children:</p><pre class="programlisting">        if children_count == 0: 
            if parent: 
                if parent.right_child is node: 
                    parent.right_child = None 
                else: 
                    parent.left_child = None 
            else: 
                self.root_node = None</pre><p> </p><p> </p><p> </p><p> </p><p>In cases <span>where</span><a id="id326006171" class="indexterm"></a> the node to be deleted has only one child, the<code class="literal">elif</code>part of the<code class="literal">if</code>statement does the following:</p><pre class="programlisting">        elif children_count == 1: 
            next_node = None 
            if node.left_child: 
                next_node = node.left_child 
            else: 
                next_node = node.right_child 

            if parent: 
                if parent.left_child is node: 
                    parent.left_child = next_node 
                else: 
                    parent.right_child = next_node 
            else: 
                self.root_node = next_node </pre><p>The <code class="literal">next_node</code> is used to keep track of that single node. which is the child of the node that is to be deleted. We then connect <code class="literal">parent.left_child</code> or <code class="literal">parent.right_child</code> to <code class="literal">next_node</code>.</p><p>Lastly, we handle the condition where the node we want to delete has two children:</p><pre class="programlisting">        ... 
        else: 
            parent_of_leftmost_node = node 
            leftmost_node = node.right_child 
            while leftmost_node.left_child: 
                parent_of_leftmost_node = leftmost_node 
                leftmost_node = leftmost_node.left_child 

            node.data = leftmost_node.data </pre><p>In finding the in-order successor, we move to the right node with <code class="literal">leftmost_node = node.right_child</code>. As long as a left node exists, <code class="literal">leftmost_node.left_child</code> will evaluate to <code class="literal">True</code> and the <code class="literal">while</code> loop will run. When we get to the leftmost node, it will either be a leaf node (meaning that it will have no child node) or have a right child.</p><p>We update the node that's about to be removed with the value of the in-order successor with <code class="literal">node.data = leftmost_node.data</code>:</p><pre class="programlisting">    if parent_of_leftmost_node.left_child == leftmost_node: 
       parent_of_leftmost_node.left_child = leftmost_node.right_child 
    else: 
       parent_of_leftmost_node.right_child = leftmost_node.right_child</pre><p> </p><p>The preceding statement allows us to properly attach the parent of the leftmost node with any child node. Observe how the right-hand side of the equals sign stays unchanged. This is because the in-order successor can only have a right child as its only child.</p><p>The <code class="literal">remove</code> operation takes <code class="literal">O(<span class="emphasis"><em>h</em></span>)</code>, where <code class="literal">h</code> is the height of the tree.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec43"></a>Searching the tree</h3></div></div></div><p>A binary <span>search</span><a id="id326011249" class="indexterm"></a> tree is a tree data structure in which all the nodes follow the property that all the nodes in the left sub-tree of a node have lower key values, and have greater key values in its right sub-tree. Thus, searching for an element with a given key value is quite easy. Let's consider an example binary search tree that has nodes <span class="strong"><strong>1</strong></span>, <span class="strong"><strong>2</strong></span>, <span class="strong"><strong>3</strong></span>, <span class="strong"><strong>4</strong></span>, <span class="strong"><strong>8</strong></span>, <span class="strong"><strong>5</strong></span>, and <span class="strong"><strong>10</strong></span>, as shown in the following diagram:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/f198127a-b44d-4106-963f-aa7575770475.png" /></div><p>In the preceding tree, if we wish to search for a node with a value of <span class="strong"><strong>5</strong></span>, then we start from the root node and compare it with the root. As node <span class="strong"><strong>5</strong></span> is a greater value compared to root node value <span class="strong"><strong>4</strong></span>, we move to the right sub-tree. In the right sub-tree, we have node <span class="strong"><strong>8</strong></span> as the root node; we compare node <span class="strong"><strong>5</strong></span> with node <span class="strong"><strong>8</strong></span>. As the node to be searched has a smaller value than node <span class="strong"><strong>8</strong></span>, we move to the left sub-tree. When we move to the left sub-tree, we compare the left sub-tree node <span class="strong"><strong>5</strong></span> with the required node with value <span class="strong"><strong>5</strong></span>. This is a match, so we return <code class="literal">"item found"</code>.</p><p>Here is the implementation of the <code class="literal">searching</code> method in a binary <span>search</span><a id="id326024934" class="indexterm"></a> tree: </p><pre class="programlisting">  def search(self, data):
        current = self.root_node
        while True:
            if current is None:
                return None
            elif current.data is data:
                return data
            elif current.data &gt; data:
                current = current.left_child
            else:
                current = current.right_child

</pre><p>In the preceding code, we will return the data if it was found, or <code class="literal">None</code> if the data wasn't found. We start searching from the root node. Next, if the data item to be searched for doesn't exist in the tree, we return <code class="literal">None</code> to the client code. We might also have found the data—in that case, we return the data.</p><p>If the data we are searching for is less than that of the current node, we go down the tree to the left. Furthermore, in the <code class="literal">else</code> part of the code, we check if the data we are looking for is greater than the data held in the current node, which means that we go down the tree to the right. </p><p>Finally, we can write some client code to test how theBSTworks. We must create a tree and insert a few numbers between <code class="literal">1</code> and <code class="literal">10</code>. Then, we search for all the numbers in that range. The ones that exist in the tree get printed:</p><pre class="programlisting">    tree = Tree() 
    tree.insert(5) 
    tree.insert(2) 
    tree.insert(7) 
    tree.insert(9) 
    tree.insert(1) 

    for i in range(1, 10): 
        found = tree.search(i) 
        print("{}: {}".format(i, found)) </pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec44"></a>Benefits of a binary search tree</h3></div></div></div><p>A <span>binary</span><a id="id326041674" class="indexterm"></a> search tree is a better choice compared to arrays and linked lists. A BST is fast for most operations such as searching, insertion, and deletion, whereas arrays provide fast searching, but are comparatively slow in insertion and deletion operations. In a similar fashion, linked lists are efficient in performing insertion and deletion operations, but are slower when performing the search operation. The <code class="literal">best-case</code> running time complexity for searching an element from a binary search tree is <code class="literal">O(log n)</code>, and the <code class="literal">worst-case</code> time complexity is <code class="literal">O(n)</code>, whereas both <code class="literal">best-case</code> and <code class="literal">worst-case</code> time complexity for searching in lists is <code class="literal">O(n)</code>.</p><p> </p><p> </p><p>The following table provides a comparison of the array, linked list, and binary search tree data structures:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Properties</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Array</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Linked list</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>BST</strong></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Data structure</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Linear.</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Linear.</p></td><td style="border-bottom: 0.5pt solid ; "><p>Non-linear.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Ease of use</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Easy to create and use. Average-case complexity for search, insert, and delete is <code class="literal">O(n)</code>.</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Insertion and deletion is fast, especially with the doubly linked list.</p></td><td style="border-bottom: 0.5pt solid ; "><p>Access of elements, insertion, and deletion is fast with the average-case complexity of <code class="literal">O(log n)</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Access Complexity</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Easy to access elements. Complexity is <code class="literal">O(1)</code>.</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Only sequential access is possible, so slow. Average and worst-case complexity is <code class="literal">O(n)</code>.</p></td><td style="border-bottom: 0.5pt solid ; "><p>Access is fast, but slow when the tree is unbalanced, with the worst-case complexity of <code class="literal">O(n)</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Search complexity</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Average and worst-case complexity is <code class="literal">O(n)</code>.</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>It is slow due to sequential searching. Average and worst-case complexity is <code class="literal">O(n)</code>.</p></td><td style="border-bottom: 0.5pt solid ; "><p>Worst-case complexity for searching is <code class="literal">O(n)</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Insertion complexity</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Insertion is slow. Average and worst-case complexity is <code class="literal">O(n)</code>.</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Average and worst-case complexity is <code class="literal">O(1)</code>.</p></td><td style="border-bottom: 0.5pt solid ; "><p>The worst-case complexity for insertion is <code class="literal">O(n)</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><span class="strong"><strong>Deletion complexity</strong></span></p></td><td style="border-right: 0.5pt solid ; "><p>Deletion is slow. Average and worst-case complexity is <code class="literal">O(n)</code>.</p></td><td style="border-right: 0.5pt solid ; "><p>Average and worst-case complexity is <code class="literal">O(1)</code>.</p></td><td style=""><p>The worst-case complexity for deletion is <code class="literal">O(n)</code>.</p></td></tr></tbody></table></div><p> </p><p>Let's consider an example to understand when the binary search tree is a good choice to store the data. Let's assume that we have the following data nodes—<span class="strong"><strong>5</strong></span>, <span class="strong"><strong>3</strong></span>, <span class="strong"><strong>7</strong></span>, <span class="strong"><strong>1</strong></span>, <span class="strong"><strong>4</strong></span><span class="strong"><strong>,</strong></span><span class="strong"><strong>6</strong></span>, and <span class="strong"><strong>9</strong></span>. If we use a list to store this data, the worst-case scenario will require us to search through the entire list of seven elements for finding the item. So, it will require seven comparisons to search for item <span class="strong"><strong>9</strong></span> in this data node:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/ed5641d3-83c4-4b8a-85ed-ba822e29aa02.png" /></div><p>However, if we use a <span>binary</span><a id="id326060579" class="indexterm"></a> search tree to store these values, as shown in the following diagram, in the worst-case scenario, we would require three comparisons to search for item <span class="strong"><strong>9</strong></span>:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/8d7ba71c-1d76-4672-8861-21bcf41b6fed.png" /></div><p> </p><p>However, it is important to note that the efficiency of searching also depends on how we built the binary search tree. If the tree hasn't been constructed properly, it can be slow. For example, if we had inserted the elements into the tree in the order {<span class="strong"><strong>1</strong></span>, <span class="strong"><strong>3</strong></span>, <span class="strong"><strong>4</strong></span>, <span class="strong"><strong>5</strong></span>, <span class="strong"><strong>6</strong></span>, <span class="strong"><strong>7</strong></span>,<span class="strong"><strong>9</strong></span>}, as shown in the following diagram, then the tree would not be more efficient than the list: </p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/ebd31443-f2ec-4941-9141-7228eae57d5c.png" /></div><p>Thus, choosing a self-balancing tree helps to improve the <code class="literal">search</code> operation. Here, we should note that the binary search tree is a better choice in most of the cases; however, we should try to balance the tree. </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec45"></a>Balancing trees</h3></div></div></div><p>We have seen in the previous section that if nodes are inserted into a tree in a sequential order, it becomes slow and behaves more or less like a list; that is, each node has exactly one child node. To improve the performance of the tree data structure, we generally like to reduce the height of the tree as much as possible to <span>balance</span><a id="id326076600" class="indexterm"></a> the tree by filling up each row in the tree. This process is called <span class="strong"><strong>balancing the tree</strong></span>.</p><p>There are different types of self-balancing trees, such as red-black trees, AA trees, and scapegoat trees. These balance the tree during each operation that modifies the tree, such as insert or delete. There are also external algorithms that balance a tree. The benefits of these are that you don't need to balance the tree on every single operation and can leave balancing to the point where you need it.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec46"></a>Expression trees</h3></div></div></div><p>An arithmetic <span>expression</span><a id="id326079182" class="indexterm"></a> is represented by a combination of operators and operands where the operators can be unary or binary. An arithmetic expression can also be represented using a <span class="strong"><strong>binary tree</strong></span>, which is called an expression tree. This tree structure can also be used to parse arithmetic and boolean expressions. In an expression tree, all the leaf nodes contain the operands and non-leaf nodes contain the operators. We should also note that the expression tree will have one of its sub-trees (right sub-tree or left sub-tree) empty in the case of a unary operator. </p><p>For example, the expression tree for <code class="literal">3 + 4</code> would look as follows:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/889e691d-c172-48bd-89e0-75f3dcfbea86.png" /></div><p> </p><p>For a slightly more complex expression, <code class="literal">(4 + 5) * (5-3)</code>, we would get the following:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/2fbb8294-4351-4d55-a8af-748262d4d4ab.png" /></div><p>The arithmetic expression can be expressed using three notations (that is, infix, postfix, and prefix), as discussed in the previous section on tree traversal. Due to this, it becomes easy to evaluate an expression tree for the given arithmetic expression. The reverse Polish notation provides faster calculations. We will show you how to construct the expression tree for the given postfix notation in the following subsection.</p><p> </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec45"></a>Parsing a reverse Polish expression</h4></div></div></div><p>Now, we are going to build up a tree for an <span>expression</span><a id="id326079239" class="indexterm"></a> written in postfix notation. Then, we will calculate the result. We will use a simple tree implementation. To keep it simple, since we are going to grow the tree by merging smaller trees, we only need a tree node implementation:</p><pre class="programlisting">    class TreeNode: 
        def __init__(self, data=None): 
            self.data = data 
            self.right = None 
            self.left = None </pre><p>In order to build the tree, we are going to enlist the items with the help of a stack. Let's just create an arithmetic expression and set up our stack:</p><pre class="programlisting">        expr = "4 5 + 5 3 - *".split() 
        stack = Stack() </pre><p>Since Python is a language that tries hard to have sensible defaults, its <code class="literal">split()</code> method splits on whitespace by default. (If you think about it, this is most likely what you would expect.) The result is going to be that <code class="literal">expr</code> is a list with the values <code class="literal">4</code>, <code class="literal">5</code>, <code class="literal">+</code>, <code class="literal">5</code>, <code class="literal">3</code>, <code class="literal">-</code>, and <code class="literal">*</code>.</p><p>Each element of the <code class="literal">expr</code> list is going to be either an operator or an operand. If we get an operand, then we embed it in a tree node and push it onto the stack. If we get an operator, on the other hand, then we embed the operator into a tree node and pop its two operands into the node's left and right children. Here, we have to take care to ensure that the first pop goes into the right child; otherwise, we will have problems with subtraction and division.</p><p>Here is the code to build the tree:</p><pre class="programlisting">    for term in expr: 
        if term in "+-*/": 
            node = TreeNode(term) 
            node.right = stack.pop() 
            node.left = stack.pop() 
        else: 
            node = TreeNode(int(term)) 
        stack.push(node) </pre><p>Notice that we perform a conversion from <code class="literal">string</code> to <code class="literal">int</code> in the case of an operand. You could use <code class="literal">float()</code> instead, if you wish to support floating point operands.</p><p> </p><p>At the end of this operation, we <span>should</span><a id="id326096318" class="indexterm"></a> have one single element in the stack, and that holds the full tree. If we want to evaluate the expression, we would build the following little function:</p><pre class="programlisting">    def calc(node): 
        if node.data is "+": 
            return calc(node.left) + calc(node.right) 
        elif node.data is "-": 
            return calc(node.left) - calc(node.right) 
        elif node.data is "*": 
            return calc(node.left) * calc(node.right) 
        elif node.data is "/": 
            return calc(node.left) / calc(node.right) 
        else: 
            return node.data </pre><p>In the preceding code, we pass in a node to the function. If the node contains an operand, then we simply return that value. If we get an operator, then we perform the operation that the operator represents on the node's two children. However, since one or more of the children could also contain either operators or operands, we call the <code class="literal">calc()</code> function recursively on the two child nodes (bearing in mind that all the children of every node are also nodes).</p><p>Now, we just need to pop the root node off the stack and pass it into the <code class="literal">calc()</code> function. Then, we should have the result of the calculation:</p><pre class="programlisting">    root = stack.pop() 
    result = calc(root) 
    print(result) </pre><p>Running this program should yield the result <code class="literal">18</code>, which is the result of <code class="literal">(4 + 5) * (5 - 3)</code>.</p></div></div></div>