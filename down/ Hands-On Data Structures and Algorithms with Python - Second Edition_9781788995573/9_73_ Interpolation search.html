<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec73"></a>Interpolation search</h2></div></div><hr /></div><p>The interpolation searching algorithm is an <span>improved</span><a id="id325896235" class="indexterm"></a> version of the binary search algorithm. It performs very efficiently when there are uniformly distributed elements in the sorted list. In a binary search, we always start searching from the middle of the list, whereas in the interpolation search we determine the starting position depending on the item to be searched. In the interpolation search algorithm, the starting search position is most likely to be the closest to the start or end of the list depending on the search item. If the search item is near to the first element in the list, then the starting search position is likely to be near the start of the list.</p><p>The interpolation search is another variant of the binary search algorithm that is quite similar to how humans perform the search on any list of items. It is based on trying to make a good guess of the index position where a search item is likely to be found in a sorted list of items. It works in a similar way to the binary search algorithm except for the method to determine the splitting criteria to divide the data in order to reduce the number of comparisons. In the case of a binary search, we divide the data into equal halves and in the case of an interpolation search, we divide the data using the following formula:</p><pre class="programlisting">mid_point = lower_bound_index + (( upper_bound_index - lower_bound_index)// (input_list[upper_bound_index] - input_list[lower_bound_index])) * (search_value - input_list[lower_bound_index]) </pre><p>In the preceding formula, the <code class="literal">lower_bound_index</code> variable is the lower-bound index, which is the index of the smallest value in the, <code class="literal">upper_bound_index</code> list, denoting the index position of the highest value in the list. The <code class="literal">input_list[lower_bound_index] </code> and <code class="literal">input_list[lower_bound_index]</code> variables are the lowest and highest values respectively in the list. The <code class="literal">search_term</code> variable contains the value of the item that is to be searched.</p><p>Let's consider an example to understand how the <span>interpolation</span><a id="id325860326" class="indexterm"></a> searching algorithm works using the following list of <code class="literal">7</code> items:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/9050e676-4e13-4bb7-a415-3d25a00ac73c.png" /></div><p>To find <span class="strong"><strong>120</strong></span>, we know that we should look at the right-hand portion of the list. Our initial treatment of binary search would typically examine the middle element first in order to determine if it matches the search term.</p><p>A more human-like method would be to pick a middle element in such a way as to not only split the array in half but to get as close as possible to the search term. The middle position was calculated using the following rule:</p><pre class="programlisting">mid_point = (index_of_first_element + index_of_last_element)//2 </pre><p>We shall replace this formula with a better one that brings us closer to the search term in the case of the interpolation search algorithm. The <code class="literal">mid_point</code> will receive the return value of the <code class="literal">nearest_mid</code> function, which is computed using the following method:</p><pre class="programlisting">def nearest_mid(input_list, lower_bound_index, upper_bound_index, search_value):

    return lower_bound_index + (( upper_bound_index -lower_bound_index)// (input_list[upper_bound_index] -input_list[lower_bound_index])) * (search_value -input_list[lower_bound_index]) </pre><p>The <code class="literal">nearest_mid</code> function takes, as arguments, the lists on which to perform the search. The <code class="literal">lower_bound_index</code> and <code class="literal">upper_bound_index</code> parameters represent the bounds in the list within which we are hoping to find the search term. Furthermore, <code class="literal">search_value</code> represents the value being searched for.</p><p>Given our search list, <span class="strong"><strong>44</strong></span>, <span class="strong"><strong>60</strong></span>, <span class="strong"><strong>75</strong></span>, <span class="strong"><strong>100</strong></span>, <span class="strong"><strong>120</strong></span>, <span class="strong"><strong>230</strong></span>, and <span class="strong"><strong>250</strong></span>, <code class="literal">nearest_mid</code> will be computed with the following values:</p><pre class="programlisting">lower_bound_index = 0
upper_bound_index = 6
input_list[upper_bound_index] = 250
input_list[lower_bound_index] = 44
search_value = 230</pre><p> </p><p>Let's compute the <code class="literal">mid_point</code> value:</p><pre class="programlisting">mid_point= 0 + [(6-0)//(250-44) * (230-44)
         = 5 </pre><p>It can now be seen that the <code class="literal">mid_point</code> value will receive the value <code class="literal">5</code>. So in the case of an interpolation search, the algorithm will start searching from the index position <code class="literal">5</code>,<span class="strong"><strong> </strong></span>which is the index of the location of our search term. Thus, the item to be searched will be found in the first comparison, whereas in the case of a binary search, we would have chosen <span class="strong"><strong>100</strong></span> as <code class="literal">mid_point</code>, which would have required another run of the algorithm.</p><p>A more visual illustration of how a typical binary search differs from an <span>interpolation</span><a id="id326367883" class="indexterm"></a> is given as follows. In a typical binary search, it finds the <span class="strong"><strong>midpoint</strong></span> that looks like it's in the middle of the list:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/32e7db6c-ba14-4a7e-abad-23085932b9f5.png" /></div><p>One can see that the <span class="strong"><strong>midpoint </strong></span>is actually standing approximately in the middle of the preceding list. This is as a result of dividing by list two.</p><p>In the case of an interpolation search, on the other hand, the <span class="strong"><strong>midpoint</strong></span> is moved to the most likely position where the item can be matched:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/75adc6b6-ebf6-4b81-961d-f85a1b3709be.png" /></div><p>In an interpolation search, the <span class="strong"><strong>midpoint</strong></span> is generally more to the left or right. This is caused by the effect of the multiplier being used when dividing to obtain the <span class="strong"><strong>midpoint</strong></span>. In the preceding diagram, our <span class="strong"><strong>midpoint</strong></span> has been skewed to the right.</p><p>The implementation of the interpolation algorithm remains the same as that of the binary search except for the way we compute the <span class="strong"><strong>midpoint</strong></span>.</p><p> </p><p>Here, we provide the implementation of the <span>interpolation</span><a id="id326368042" class="indexterm"></a> search algorithm, as shown in the following code:</p><pre class="programlisting">def interpolation_search(ordered_list, term): 

    size_of_list = len(ordered_list) - 1 

    index_of_first_element = 0 
    index_of_last_element = size_of_list 

    while index_of_first_element &lt;= index_of_last_element: 
        mid_point = nearest_mid(ordered_list, index_of_first_element, index_of_last_element, term) 

        if mid_point &gt; index_of_last_element or mid_point &lt; index_of_first_element: 
            return None 

        if ordered_list[mid_point] == term: 
            return mid_point 

        if term &gt; ordered_list[mid_point]: 
            index_of_first_element = mid_point + 1 
        else: 
            index_of_last_element = mid_point - 1 

    if index_of_first_element &gt; index_of_last_element: 
        return None </pre><p>The <code class="literal">nearest_mid</code> function makes use of a multiplication operation. This can produce values that are greater than <code class="literal">upper_bound_index</code> or lower than <code class="literal">lower_bound_index</code>. When this occurs, it means the search term, <code class="literal">term</code>, is not in the list. <code class="literal">None</code> is, therefore, returned to represent this.</p><p>So what happens when <code class="literal">ordered_list[mid_point]</code> does not equal the search term? Well, we must now readjust <code class="literal">index_of_first_element</code> and <code class="literal">index_of_last_element</code> so that the algorithm will focus on the part of the array that is likely to contain the search term. This is exactly like what we did in the binary search:</p><pre class="programlisting">if term &gt; ordered_list[mid_point]: 
    index_of_first_element = mid_point + 1 </pre><p>If the search term is greater than the value stored at <code class="literal">ordered_list[mid_point]</code>, then we only adjust the <code class="literal">index_of_first_element</code> variable to point to the <code class="literal">mid_point + 1</code> index.</p><p>The following diagram shows how the adjustment occurs. The <code class="literal">index_of_first_element</code> is adjusted and pointed to the <code class="literal">mid_point+1</code> index:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/900d4187-e42c-4250-acc9-9429a585c16d.png" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip12"></a>Note</h3><p>The diagram only illustrates the adjustment of the midpoint. In interpolation, the midpoint rarely divide the list into two equal halves.</p></div><p>On the other hand, if the search term is less than the value stored at <code class="literal">ordered_list[mid_point]</code>, then we only adjust the <code class="literal">index_of_last_element</code> variable to point to the index <code class="literal">mid_point - 1</code>. This logic is captured in the else part of the if statement <code class="literal">index_of_last_element = mid_point - 1</code>:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/42897632-3e3b-4181-a450-57d08112268c.png" /></div><p>The diagram shows the effect of the recalculation of <span class="strong"><strong>index_of_last_element</strong></span> on the position of the <span class="strong"><strong>midpoint</strong></span>.</p><p>Let's use a more practical example to understand the inner workings of both the binary search and <span>interpolation</span><a id="id325609588" class="indexterm"></a> algorithms.</p><p>Consider for example the following list of elements:</p><pre class="programlisting">[ 2, 4, 5, 12, 43, 54, 60, 77] </pre><p>At index 0, the value 2 is stored, and at index 7, the value 77 is stored. Now, assume that we want to find the element 2 in the list. How will the two different algorithms go about it?</p><p>If we pass this list to the <code class="literal">interpolation search</code> function, then the <code class="literal">nearest_mid</code> function will return a value equal to <code class="literal">0</code> using the formula of <code class="literal">mid_point</code> computation which is as follows:</p><pre class="programlisting">mid_point= 0 + [(7-0)//(77-2) * (2-2)
         = 0 </pre><p>As we get the <code class="literal">mid_point</code> value <code class="literal">0</code>, we start the <span>interpolation</span><a id="id325609630" class="indexterm"></a> search with the value at index <code class="literal">0</code>. Just with one comparison, we have found the search term.</p><p>On the other hand, the binary search algorithm needs three comparisons to arrive at the search term, as illustrated in the following diagram:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/e8aaa34e-bdba-4d9d-b0d6-412fad8bdb34.png" /></div><p>The first <code class="literal">mid_point</code> value calculated is <code class="literal">3</code>. The second <code class="literal">mid_point</code> value is <code class="literal">1</code> and the last <code class="literal">mid_point</code> value where the search term is found is <code class="literal">0</code>.</p><p>Therefore, it is clear that the interpolation search algorithm performs better than binary search in most cases. </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec66"></a>Choosing a search algorithm</h3></div></div></div><p>The binary search and <span>interpolation</span><a id="id325616204" class="indexterm"></a> search algorithms are better in performance compared to both ordered and unordered linear search functions. Because of the sequential probing of elements in the list to find the search term, ordered and unordered linear searches have a time complexity of <code class="literal">O(n)</code>. This gives a very poor performance when the list is large.</p><p> </p><p>The binary search operation, on the other hand, slices the list in two anytime a search is attempted. On each iteration, we approach the search term much faster than in a linear strategy. The time complexity yields <code class="literal">O(log n)</code>. Despite the speed gain in using a binary search, the main disadvantage of it is that it cannot be applied on an unsorted list of items, neither is it advised to be used for a list of small size due to an overhead of sorting. </p><p>The ability to get to the portion of the list that holds a search term determines, to a large extent, how well a search algorithm will perform. In the interpolation search algorithm, the midpoint is computed in such as way that it gives a higher probability of obtaining our search term faster. The average-case time complexity of the interpolation search is <code class="literal">O( log ( log n))</code>, whereas the worst-case time complexity of the <span>interpolation</span><a id="id325844993" class="indexterm"></a> search algorithm is <code class="literal">O(n)</code>. This shows that interpolation search is better than binary search and provides faster searching in most cases. </p></div></div>