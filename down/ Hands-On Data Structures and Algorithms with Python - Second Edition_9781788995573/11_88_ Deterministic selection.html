<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch11lvl1sec86"></a>Deterministic selection</h2></div></div><hr /></div><p>The worst-case performance of a <span>randomized</span><a id="id325896341" class="indexterm"></a> selection algorithm is <code class="literal">O(n<sup>2</sup>)</code>. It is possible to improve the section of an element of the randomized selection algorithm to obtain a worst-case performance of <code class="literal">O(n)</code>. We can obtain the performance of <code class="literal">O(n)</code> by using an algorithm, that is, <span class="strong"><strong>deterministic selection</strong></span>.</p><p> </p><p>Median of the median is an algorithm that provides us with the approximate median value, that is, a value close to the actual median for a given unsorted list of elements. This approximate median is often used as a pivot point in the quickselect algorithm for selecting the <code class="literal">i<sup>th</sup></code> smallest element from a list. It is due to the fact that the median of median algorithm finds out the estimated median in a linear time, and when this estimated median is used as a pivot point in the quickselect algorithm, the worst-case running time's complexity drastically improves from <code class="literal">O(n<sup>2</sup>)</code> to the linear <code class="literal">O(n)</code>. Therefore, the median of the median algorithm helps the quickselect algorithm to perform significantly better because of the choice of a good pivot value.</p><p>The general approach to the deterministic algorithm to select the <code class="literal">i<sup>th</sup></code> smallest element is listed here:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Select a pivot:
<div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Split a list of unordered items into groups of five elements each.</li><li>Sort and find the median of all the groups.</li><li>Repeat <span class="emphasis"><em>steps 1</em></span> and<span class="emphasis"><em> 2</em></span> recursively to obtain the true median of the list.</li></ol></div></li><li>Use the true median to partition the list of unordered items.</li><li>Recurse into the part of the partitioned list that may contain the <code class="literal">i<sup>th</sup></code> smallest element.</li></ol></div><p>Let's consider an example list of 15 elements to understand the working of the deterministic approach to determine the third smallest element from the list. First, you need to divide the lists that have 5 elements each, and then we sort the sublists. Once we have sorted the lists, we find out the median of the sublists, that is, items <span class="strong"><strong>23</strong></span>, <span class="strong"><strong>52</strong></span>, and <span class="strong"><strong>34</strong></span> are the medians of these three sublists. We prepare a list of medians of all the sublists, and then we sort the list of medians. Next, we determine the median of this list, that is, the <span>median</span><a id="id325644841" class="indexterm"></a> of the median, which is <span class="strong"><strong>34</strong></span>. This value is the estimated median of the whole list, and is used to select the partition/pivot point for the whole list. Since the index of the pivot value is 7, which is greater than the <code class="literal">i<sup>th</sup></code> value, we recursively consider the left sublist.</p><p>The functionality of the algorithm is shown in the following diagram:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/85c7e2df-bd9c-4973-bcee-f6d39734477b.png" /></div><p> </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec71"></a>Pivot selection</h3></div></div></div><p>To implement the <span>deterministic</span><a id="id325644882" class="indexterm"></a> algorithm to efficiently determine the <code class="literal">i<sup>th</sup></code> smallest value from the list, we start by implementing the pivot selection method. Previously, in the random selection algorithm, we selected the first element as the pivot. We shall replace that step with a sequence of steps that enables us to obtain the approximate median. This will improve the partitioning of the list regarding the pivot:</p><pre class="programlisting">    def partition(unsorted_array, first_index, last_index): 

        if first_index == last_index: 
            return first_index 
        else: 
            nearest_median =     
            median_of_medians(unsorted_array[first_index:last_index]) 

        index_of_nearest_median = 
            get_index_of_nearest_median(unsorted_array, first_index, 
                                        last_index, nearest_median) 

        swap(unsorted_array, first_index, index_of_nearest_median) 

        pivot = unsorted_array[first_index] 
        pivot_index = first_index 
        index_of_last_element = last_index 

        less_than_pivot_index = index_of_last_element 
        greater_than_pivot_index = first_index + 1 </pre><p>Let's now understand the <span>code</span><a id="id325837800" class="indexterm"></a> for the <code class="literal">partition</code> function. The <code class="literal">nearest_median</code> variable stores the true or approximate median of a given list:</p><pre class="programlisting">    def partition(unsorted_array, first_index, last_index): 

        if first_index == last_index: 
            return first_index 
        else: 
            nearest_median =   
            median_of_medians(unsorted_array[first_index:last_index]) 
        .... </pre><p>If the <code class="literal">unsorted_array</code> parameter has only one element, <code class="literal">first_index</code> and <code class="literal">last_index</code> will be equal. Therefore, <code class="literal">first_index</code> is, returned anyway.</p><p> </p><p>However, if the list size is greater than one, we call the <code class="literal">median_of_medians</code> function with the section of the array, demarcated by <code class="literal">first_index</code> and <code class="literal">last_index</code>. The return value is yet again stored in <code class="literal">nearest_median</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec72"></a>Median of medians</h3></div></div></div><p>The <code class="literal">median_of_medians</code> function is responsible for finding the <span>approximate</span><a id="id325851490" class="indexterm"></a> median of any given list of items. The function uses recursion to return the true median:</p><pre class="programlisting">def median_of_medians(elems): 

    sublists = [elems[j:j+5] for j in range(0, len(elems), 5)] 

    medians = [] 
    for sublist in sublists: 
        medians.append(sorted(sublist)[len(sublist)//2]) 

    if len(medians) &lt;= 5: 
        return sorted(medians)[len(medians)//2] 
    else: 
        return median_of_medians(medians) </pre><p>The function begins by splitting the list, <code class="literal">elems</code>, into groups of five elements each. This means that if <code class="literal">elems</code> contains 100 items, there will be 20 groups that are created by the <code class="literal">sublists = [elems[j:j+5] for j in range(0, len(elems), 5)]</code> statement, with each containing exactly five elements or fewer:</p><pre class="programlisting">    medians = [] 
        for sublist in sublists: 
            medians.append(sorted(sublist)[len(sublist)/2]) </pre><p>An empty array is created and assigned to <code class="literal">medians</code>, which stores the medians in each of the five element arrays assigned to <code class="literal">sublists</code>.</p><p>The for loop iterates over the list of lists inside <code class="literal">sublists</code>. Each sublist is sorted, the median is found, and is stored in the <code class="literal">medians</code> list.</p><p>The <code class="literal">medians.append(sorted(sublist)[len(sublist)//2])</code> statement will sort the list and obtain the element stored in its middle index. This becomes the median of the five-element list. The use of an existing sorting function will not impact the performance of the algorithm due <span>to</span><a id="id325855502" class="indexterm"></a> the list's small size.</p><p> </p><p> </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note13"></a>Note</h3><p>We understood from the outset that we would not sort the list in order to find the <code class="literal">i<sup>th</sup></code> smallest element, so why employ Python's sorted method? Well, since we are sorting a very small list of five elements or fewer, the impact of that operation on the overall performance of the algorithm is considered negligible.</p></div><p>Thereafter, if the list now contains five or fewer elements, we shall sort the <code class="literal">medians</code> list and return the element located in its middle index:</p><pre class="programlisting">    if len(medians) &lt;= 5: 
            return sorted(medians)[len(medians)/2] </pre><p>If, on the other hand, the size of the list is greater than five, we recursively call the <code class="literal">median_of_medians</code> function again, supplying it with the list of the medians stored in <code class="literal">medians</code>.</p><p>Take, for instance, another example to better understand the concept of the median of median algorithm, with the following list of numbers:</p><p><span class="emphasis"><em>[2, 3, 5, 4, 1, 12, 11, 13, 16, 7, 8, 6, 10, 9, 17, 15, 19, 20, 18, 23, 21, 22, 25, 24, 14]</em></span></p><p>We can break this list into groups of five elements each with the <code class="literal">sublists = [elems[j:j+5] for j in range(0, len(elems), 5)]</code> code statement in order to obtain the following list:</p><p><span class="emphasis"><em>[[2, 3, 5, 4, 1], [12, 11, 13, 16, 7], [8, 6, 10, 9, 17], [15, 19, 20, 18, 23], [21, 22, 25, 24, 14]]</em></span></p><p>Sorting each of the five-element lists and obtaining their medians produces the following list:</p><p><span class="emphasis"><em>[3, 12, 9, 19, 22]</em></span></p><p>Since the list is five elements in size, we only return the median of the sorted list; otherwise, we would have made another call to the <code class="literal">median_of_median</code> function.</p><p>The median of medians algorithm can also be used to choose a pivot point in the quicksort algorithm for sorting a list of elements. This significantly improves the worst-case performance of the quicksort algorithm from <code class="literal">O(n<sup>2</sup>)</code> to a complexity of <code class="literal">O(n log n)</code>.</p><p> </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec73"></a>Partitioning step</h3></div></div></div><p>Now that we have obtained the <span>approximate</span><a id="id326130128" class="indexterm"></a> median, the <code class="literal">get_index_of_nearest_median</code> function takes the bounds of the list indicated by the <code class="literal">first</code> and <code class="literal">last</code> parameters:</p><pre class="programlisting">    def get_index_of_nearest_median(array_list, first, second, median): 
        if first == second: 
            return first 
        else: 
            return first + array_list[first:second].index(median) </pre><p>Once again, we only return the first index if there is only one element in the list. However, <code class="literal">arraylist[first:second]</code> returns an array with an index of <code class="literal">0</code> up to the size of the <code class="literal">list -1</code>. When we find the index of the median, we lose the portion in the list where it occurs because of the new range indexing that the <code class="literal">[first:second]</code> code returns. Therefore, we must add whatever index is returned by <code class="literal">arraylist[first:second]</code> to <code class="literal">first</code> to obtain the true index where the median was found:</p><pre class="programlisting">    swap(unsorted_array, first_index, index_of_nearest_median) </pre><p>We then swap the first element in <code class="literal">unsorted_array</code> with <code class="literal">index_of_nearest_median</code>, using the <code class="literal">swap</code>function.</p><p>The <code class="literal">utility</code> function to swap two array elements is shown here:</p><pre class="programlisting">def swap(array_list, first, second): 
    temp = array_list[first] 
    array_list[first] = array_list[second] 
    array_list[second] = temp </pre><p>Our approximate median is now stored at <code class="literal">first_index</code> of the unsorted list.</p><p>The partition function continues as it would in the code of the quickselect algorithm. After the partitioning step, the array looks like this:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/51d92ce4-dfbb-487d-963d-01a5239053b1.png" /></div><pre class="programlisting">
 def deterministic_select(array_list, left, right, k): 

        split = partition(array_list, left, right) 
        if split == k: 
            return array_list[split] 
        elif split &lt; k : 
           return deterministic_select(array_list, split + 1, right, k) 
        else: 
            return deterministic_select(array_list, left, split-1, k)</pre><p>As you will have already observed, the main function of the deterministic selection algorithm looks exactly the same as its random selection counterpart. After the initial <code class="literal">array_list</code> has been partitioned for the <span>approximate</span><a id="id326168370" class="indexterm"></a> median, a comparison with the <code class="literal">k<sup>th</sup></code> element is made.</p><p>If <code class="literal">split</code> is less than <code class="literal">k</code>, then a recursive call to <code class="literal">deterministic_select(array_list, split + 1, right, k)</code> is made. This will look for the <code class="literal">k<sup>th</sup></code> element in that half of the array. Otherwise, the function call to <code class="literal">deterministic_select(array_list, left, split-1, k)</code> is made.</p></div></div>