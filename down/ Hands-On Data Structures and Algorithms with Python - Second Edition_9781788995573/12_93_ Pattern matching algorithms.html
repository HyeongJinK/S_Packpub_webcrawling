<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch12lvl1sec90"></a>Pattern matching algorithms</h2></div></div><hr /></div><p>A <span>pattern</span><a id="id326151297" class="indexterm"></a> matching algorithm is used to determine the index positions where a given pattern string (P) is matched in a text string (T). It returns <code class="literal">"pattern not found"</code> if the pattern does not match in the text string. For example, for the given string (s) = <code class="literal">"packt publisher"</code>, and the pattern (p)= <code class="literal">"publisher"</code>, the pattern matching algorithm returns the index position where the pattern is matched in the text string.</p><p>In this section, we will discuss four pattern matching algorithms, that is, the brute-force method, as well as the Rabin-Karp algorithm, Knuth-Morris-Pratt (KMP), and Boyer Moore pattern matching algorithms.  </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lvl2sec74"></a>The brute-force algorithm</h3></div></div></div><p>The brute-force algorithm, or naive approach for the <span>pattern</span><a id="id325578025" class="indexterm"></a> matching algorithm, is very basic. Using this, we simply test all the possible combinations of the input <span>pattern</span><a id="id326151300" class="indexterm"></a> in the given string to find the position of the occurrence of the pattern. This algorithm is very naive and is not suitable if the text is very long.</p><p>Here, we start by comparing the characters of the pattern and the text string one by one, and if all the characters of the pattern are matched with the text, we return the index position of the text where the first character of the pattern is placed. If any character of the pattern is mismatched with the text string, we shift the pattern by one place. We continue comparing the pattern and text string by shifting the pattern by one index position.  </p><p>To better understand how the brute-force algorithm works, let's look at an example. Suppose we have a text string (T)= <span class="strong"><strong>acbcabccababcaacbcac</strong></span>, and the pattern string (P) is <span class="strong"><strong>acbcac</strong></span>. Now, the objective of the pattern matching algorithm is to determine the index position of the pattern string in the given text, T, as shown in the following figure:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/dfcf2eca-5eb6-4c26-ac5b-271525f11f20.png" /></div><p>We start by comparing the first character of the text, that is, <span class="strong"><strong>a</strong></span>, and the characters of the pattern. Here, the initial five characters of the pattern are matched, and there is a mismatch in the last character of the pattern. S<span>ince there is a mismatch, we further shift the pattern by </span>one <span>place.  We again start comparing the first character of the pattern and the second character of the text string one by one. Here, </span>character <span class="strong"><strong>c</strong></span> of the text string does not match with the character <span class="strong"><strong>a</strong></span> of the pattern. Since it is a mismatch, we shift the <span>pattern</span><a id="id325949236" class="indexterm"></a> by one space, as shown in the preceding diagram. We continue comparing the characters of the <span>pattern</span><a id="id325949261" class="indexterm"></a> and the text string until we traverse the whole text string. In the preceding example, we find a match at index position <span class="strong"><strong>14</strong></span>, which is shown with the arrows to <span class="strong"><strong>aa</strong></span>.</p><p> </p><p>Here, let's consider the Python implementation of the brute-force algorithm for pattern matching:</p><pre class="programlisting">def brute_force(text, pattern):
    l1 = len(text)      # The length of the text string
    l2 = len(pattern)   # The length of the pattern 
    i = 0
    j = 0               # looping variables are set to 0
    flag = False        # If the pattern doesn't appear at all, then set this to false and execute the last if statement

    while i &lt; l1:         # iterating from the 0th index of text
        j = 0
        count = 0    
        # Count stores the length upto which the pattern and the text have matched

        while j &lt; l2:
            if i+j &lt; l1 and text[i+j] == pattern[j]:  
        # statement to check if a match has occoured or not
        count += 1     # Count is incremented if a character is matched 
            j += 1
        if count == l2:   # it shows a matching of pattern in the text 
                print("\nPattern occours at index", i) 
                  # print the starting index of the successful match
                flag = True 
     # flag is True as we wish to continue looking for more matching of  
      pattern in the text. 
            i += 1
    if not flag: 
        # If the pattern doesn't occours at all, means no match of  
         pattern in the text string
        print('\nPattern is not at all present in the array')


brute_force('acbcabccababcaacbcac','acbcac')         # function call

#outputs
#Pattern occours at index 14</pre><p>In the preceding code for the brute-force approach, we start by computing the length of the given text strings and pattern. We also initialize the looping variables with <code class="literal">0</code> and set the flag to <code class="literal">False</code>. This variable is used to continue searching for a match of the pattern in the string. If the flag is <code class="literal">False</code> by the end of the text string, it means that there is no match of the pattern at all in the text string.</p><p> </p><p> </p><p>Next, we start the searching loop from the <code class="literal">0th</code> index to the end of the text string. In this loop, we have a count variable that is used to keep track of the length up to which the pattern and the text have been matched. Next, we have another nested loop that runs from the <code class="literal">0th</code> index to the length of the pattern. Here, the variable <code class="literal">i</code> keeps track of the index position in the text string and the variable <code class="literal">j</code> keeps track of the characters in the pattern. Next, we compare the characters of the patterns and the text string using the following code fragment:</p><pre class="programlisting">if i+j&lt;l1 and text[i+j] == pattern[j]:</pre><p>Furthermore, we increment the count variable after every match of the character of the pattern in the text string. Then, we continue matching the characters of the pattern and text string. If the length of the pattern becomes equal to the count variable, it means there is a match.</p><p>We print the index position of the text string if there is a match of the <span>pattern</span><a id="id325919387" class="indexterm"></a> in the text string, and keep the flag variable to <code class="literal">True</code> as we wish to continue searching for more matches of the patterns in the text string. Finally, if the value of the variable flag is <code class="literal">False</code>, it means that there was not a match of the pattern in the text string at all.</p><p>The best-case and worst-case time complexity for the naive string matching algorithms are <code class="literal">O(n)</code> and <code class="literal">O(m*(n-m+1))</code>, respectively. The best-case occurs when the pattern is not found in the text and the first character of the pattern is not present in the text at all, for example, if the text string is <code class="literal">ABAACEBCCDAAEE</code>, and the pattern is <code class="literal">FAA</code>. Here, as the first character of the pattern will not match in the text, it will have the comparisons equal to the length of the text (<code class="literal">n</code>). </p><p>The worst-case occurs when all characters of the text string and the pattern are the same, for example, if the text string is <code class="literal">AAAAAAAAAAAAAAAA</code>, and the pattern is <code class="literal">AAAA</code>. Another worst-case scenario occurs when only the last character is different, for example, if the text string is <code class="literal">AAAAAAAAAAAAAAAF</code> and the pattern is <code class="literal">AAAAF</code>. Thus, worst-case time complexity would be <code class="literal">O(m*(n-m+1))</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lvl2sec75"></a>The Rabin-Karp algorithm</h3></div></div></div><p>The Rabin-Karp <span>pattern</span><a id="id325933101" class="indexterm"></a> matching algorithm is an improved version of the brute-force approach for finding the location of the given pattern in the text string.  The performance of the Rabin-Karp algorithm is improved by reducing the number of comparisons with the help of hashing. We described hashing in detail in <a class="link" href="#" linkend="ch07">Chapter 7</a>, <span class="emphasis"><em>Hashing and Symbol Tables</em></span>. The hashing function returns a unique numeric value for a given string. </p><p> </p><p> </p><p>This algorithm is faster than the brute-force approach as it avoids unnecessary comparisons, character by character. Instead, the hash value of the pattern is compared with the hash of the substring of the text string all at once. If the hash values are not matched, the pattern is moved one position, and so there is no need to compare all the characters of the <span>pattern</span><a id="id325933126" class="indexterm"></a> one by one. </p><p>This algorithm is based on the concept that if the hash values of the two strings are equal, then it is assumed that both of these strings are also equal. The main problem with this algorithm is that there can be two different strings whose hash values are equal. In that case, the algorithm may not work; this situation is known as a spurious hit. To avoid this problem, after matching the hash values of the pattern and the substring, we ensure that the pattern is actually matched by comparing them character by character.</p><p>The Rabin-Karp pattern matching algorithm works as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>First, we preprocess the pattern before starting the search, that is, we compute the hash value of the pattern of length <code class="literal">m</code> and the hash values of all the possible substrings of the text of length <code class="literal">m</code>. So, the total number of possible substrings would be <code class="literal">(n-m+1)</code>. Here, <code class="literal">n</code> is the length of the text.</li><li>We compare the hash value of the pattern and compare it with the hash value of the substrings of the text one by one.</li><li>If the hash values are not matched, then we move the pattern by one position.</li><li>If the hash value of the pattern and the hash value of the substring of the text matches, then we compare the pattern and substring character by character to ensure that the pattern is actually found in the text. </li><li>We continue the process of steps 2-4 until we reach the end of the given text string.</li></ol></div><p>In this algorithm, we can compute the numerical hash values using Horner's rule or any other hashing function that returns a unique value for the given string. We can also compute the hashing value using the sum of the ordinal values of all the characters of the string. </p><p> </p><p> </p><p>Let's consider an example to understand the Rabin-Karp algorithm. Let's say we have a text string (T)= <code class="literal">"publisher paakt packt"</code>, and the pattern (P)= <code class="literal">"packt"</code>.  First, we compute the hash value of the pattern (length <code class="literal">m</code>) and all the substrings (of length <code class="literal">m</code>) of the text string. </p><p> </p><p>We start comparing the hash of the pattern <code class="literal">"packt"</code> with the first substring, <code class="literal">"publi" </code> . Since the hash values do not match, we move the pattern by one location, and once again we compare the hash value of pattern with the hash value of the next substring of the text, <code class="literal">"ublis"</code>. As these hash values also do not match, we again move the pattern by one location. We always move the <span>pattern</span><a id="id325933514" class="indexterm"></a> by one location if the hash values do not match.</p><p>Furthermore, if the hash value of the pattern and the hash value of the substring match, we compare the <span>pattern</span><a id="id325933525" class="indexterm"></a> and substring character by character and we return the location of the text string. In this example, these values are matched at location <code class="literal">17</code>. It is important to note that there can be a different string whose hash value can match with the hash of the pattern. This situation is called a spurious hit, and is due to a collision in hashing. The functionality of the Rabin-Karp algorithm is shown here:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/bca2630b-ff3a-44bb-9508-f03a9d6652ca.png" /></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch12lvl3sec48"></a>Implementing the Rabin-Karp algorithm</h4></div></div></div><p>The first step to implementing the Rabin-Karp algorithm is to choose the hash function. We use the sum of all the ordinal values of the characters of the string as the hashing function. </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p>We start by storing the ordinal values of all the characters of the text and the pattern. Next, we store the length of the text and the <span>pattern</span><a id="id325977239" class="indexterm"></a> in the <code class="literal">len_text</code> and <code class="literal">len_pattern</code> variables. Next, we compute the hash value for the pattern by summing up the ordinal values of all the characters in the pattern. </p><p>Next, we create a variable called <code class="literal">len_hash_array</code> that stores the total number of possible substrings of length (equal to the length of the pattern) using <code class="literal">len_text - len_pattern + 1</code>, and we create an array called <code class="literal">hash_text</code> that stores the hash value for all the possible substrings. </p><p>Next, we start a loop that will run for all the possible substrings of the text. Initially, we compute the hash value for the first substring by summing the ordinal values of all of its characters using <code class="literal">sum(ord_text[:len_pattern])</code>. Furthermore, the hash values for all of the substrings are computed using the hash value of its previous substrings as <code class="literal">((hash_text[i-1] - ord_text[i-1]) + ord_text[i+len_pattern-1])</code> .</p><p>The complete Python implementation to compute the hashing values is shown here:</p><pre class="programlisting">def generate_hash(text, pattern):
      ord_text = [ord(i) for i in text]   
                       # stores unicode value of each character in text 
      ord_pattern = [ord(j) for j in pattern] 
                   # stores unicode value of each character in pattern
      len_text = len(text)           # stores length of the text 
      len_pattern = len(pattern)     # stores length of the pattern
      hash_pattern = sum(ord_pattern)
      len_hash_array = len_text - len_pattern + 1    
       #stores the length of new array that will contain the hash 
       values of text
      hash_text = [0]*(len_hash_array) 
                         # Initialize all the values in the array to 0.
      for i in range(0, len_hash_array): 
           if i == 0:  
                hash_text[i] = sum(ord_text[:len_pattern]) 
                                      # initial value of hash function
           else:
                hash_text[i] = ((hash_text[i-1] - ord_text[i-1]) + 
                ord_text[i+len_pattern-1]) 
                    # calculating next hash value using previous value

      return [hash_text, hash_pattern]         # return the hash values</pre><p>After preprocessing the pattern and text, we have precomputed hash values that we will use for comparing the pattern and the text.</p><p>The implementation of the main Rabin-Karp algorithm works as follows. First, we convert the given text and pattern in string format as the ordinal values can only be computed for the strings.</p><p>Next, we call the <code class="literal">generate_hash</code> function to compute the hash values. We also store the length of the text and patterns in the <code class="literal">len_text</code> and <code class="literal">len_pattern</code> variables. We also initialize the <code class="literal">flag</code> variable to <code class="literal">False</code> so that it keeps track of whether the <span>pattern</span><a id="id325988979" class="indexterm"></a> is present in the text at least once. </p><p>Next, we start a loop that implements the main concept of the algorithm. This loop will run for the length of the <code class="literal">hash_text</code>, which is the total number of possible substrings. Initially, we compare the first hash value of the substring with the hash of the pattern by using <code class="literal">if hash_text[i] == hash_pattern</code>. They do not match; we do nothing and look for another substring. If they match, we compare the substring and the pattern character by character through a loop by using <code class="literal">if pattern[j] == text[i+j]</code>.</p><p>We then create a <code class="literal">count</code> variable to keep track of how many characters match in the pattern and the substring. If the length of the count and length of the pattern become equal, this means that all of the characters match, and the index location is returned where the pattern was found. Finally, if the <code class="literal">flag</code> variable remains <code class="literal">False</code>, this means that the pattern does not match at all in the text.</p><p>The complete Python implementation of the Rabin-Karp algorithm is shown as follows:</p><pre class="programlisting">def Rabin_Karp_Matcher(text, pattern):
    text = str(text)                 # convert text into string format
    pattern = str(pattern)           # convert pattern into string format
    hash_text, hash_pattern = generate_hash(text, pattern) 
                    # generate hash values using generate_hash function
    len_text = len(text)              # length of text
    len_pattern = len(pattern)        # length of pattern
    flag = False # checks if pattern is present atleast once or not at all
    for i in range(len(hash_text)): 
        if hash_text[i] == hash_pattern:     # if the hash value matches
            count = 0 
            for j in range(len_pattern): 
                if pattern[j] == text[i+j]: 
                        # comparing patten and substring character by character
                    count += 1  
                else:
                    break
                if count == len_pattern:       # Pattern is found in the text
                    flag = True                # update flag accordingly
                    print("Pattern occours at index", i)
                if not flag:                # Pattern doesn't match even once.
                    print("Pattern is not at all present in the text")</pre><p>The Rabin-Karp pattern matching algorithm preprocesses the pattern before the searching, that is, it computes the hash value for the pattern that has the complexity of <code class="literal">O(m)</code>.  Also, the worst-case running time complexity of the Rabin-Karp algorithm is <code class="literal">O(m *(n-m+1))</code>.</p><p>The worse-case would be when the pattern does not occur in the text at all.</p><p>The average-case would occur when the pattern occurs at least once.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lvl2sec76"></a>The Knuth-Morris-Pratt algorithm</h3></div></div></div><p>The <span class="strong"><strong>Knuth-Morris-Pratt</strong></span> (<span class="strong"><strong>KMP</strong></span>) algorithm is a <span>pattern</span><a id="id325989492" class="indexterm"></a> matching algorithm that is based on a precomputed prefix function that stores the information of an overlapping text portion in the pattern. The KMP algorithm preprocesses this pattern to avoid unnecessary comparisons when using the prefix function. The algorithm utilizes the prefix function to estimate how much the <span>pattern</span><a id="id325989500" class="indexterm"></a> should be shifted to search the pattern in the text string whenever we get a mismatch. <span>The KMP algorithm is efficient as it minimizes the comparisons of the given patterns with respect to the text string.</span></p><p>The motivation behind the KMP algorithm can be seen in the following explanatory diagram:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/24c86f1e-c927-4d2a-be39-7fc840a4a273.png" /></div><p> </p><p> </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch12lvl3sec49"></a>The prefix function</h4></div></div></div><p>The <code class="literal">prefix</code> function (also known as the failure function) finds the <span>pattern</span><a id="id325989544" class="indexterm"></a> in the pattern itself. It tries to find how much the previous comparisons can be reused due to repetition in the pattern itself when there is a mismatch. It has a value that is mainly the longest prefix, which is also a suffix. </p><p>For example, if we have a <code class="literal">prefix</code> function for a pattern where all of the characters are different, the <code class="literal">prefix</code> function would have a value of <code class="literal">0</code>, meaning that if we find any mismatch, the pattern would be shifted by the number of characters in the pattern. It also means that there is no overlap in the pattern, and no previous comparisons would be reused. We start by comparing from the first character of the pattern with the text string if it contains only different characters. Consider the following example: the pattern <span class="strong"><strong>abcde</strong></span> contains all different characters, so it would be shifted to the number of characters in the pattern, and we would start comparing the first character of the pattern with the next character of the text string, as shown in the following diagram:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/4c9867ca-f70d-4f5e-9c73-0e0300f55824.png" /></div><p>Let's consider another example to better understand how the <code class="literal">prefix</code> function works for the pattern (P) <span class="strong"><strong>abcabbcab</strong></span> as shown in the following diagram:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/46f58a3f-c8d0-4063-b55a-b67c92b5620d.png" /></div><p>In the preceding diagram, we start calculating the values of the <code class="literal">prefix</code> function starting from index <span class="strong"><strong>1</strong></span>. We assign value <span class="strong"><strong>0</strong></span> if there is no repetition of the characters. In the preceding example, we assign <span class="strong"><strong>0</strong></span> to the <code class="literal">prefix</code> function for the index positions <span class="strong"><strong>1</strong></span> to <span class="strong"><strong>3</strong></span>.  Next, at index position <span class="strong"><strong>4</strong></span>, we can see that there is a character, <span class="strong"><strong>a</strong></span>, which is the repetition of the first character of the <span>pattern</span><a id="id325989980" class="indexterm"></a> in itself, so we assign value <span class="strong"><strong>1</strong></span> here, shown as follows:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/e764365a-822a-4d40-bc79-c5b9d7e2badc.png" /></div><p>Next, we look at the next character at position <span class="strong"><strong>5</strong></span>. It has the longest suffix pattern, <span class="strong"><strong>ab</strong></span>, and so it would have a value of <span class="strong"><strong>2</strong></span>, as shown in the following diagram:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/b65fb380-6712-4f35-8330-2f6c74e87315.png" /></div><p> </p><p>Similarly, we look at the next index position of <span class="strong"><strong>6</strong></span>. Here, the character is <span class="strong"><strong>b</strong></span>. This character does not have the longest suffix in the pattern, so it has the value <span class="strong"><strong>0</strong></span>. Next, we assign value <span class="strong"><strong>0</strong></span> at index position <span class="strong"><strong>7</strong></span>. Then, we look at the index position <span class="strong"><strong>8</strong></span>, and we assign the value <span class="strong"><strong>1</strong></span> as it has the longest suffix of length <span class="strong"><strong>1</strong></span>. Finally, at the index position of <span class="strong"><strong>9</strong></span>, we have the longest suffix of <span class="strong"><strong>2</strong></span>:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/31b3dc22-e6a2-4de4-85ae-44bbdc4ceaee.png" /></div><p>The value of the <code class="literal">prefix</code> function shows how much of the start of the string can be reused if there is a mismatch. For example, if the comparison fails at the index position of <span class="strong"><strong>5</strong></span>, the <code class="literal">prefix</code> function value is <span class="strong"><strong>2</strong></span>, which means that the two starting characters don't need to be compared.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch12lvl3sec50"></a>Understanding KMP algorithms</h4></div></div></div><p>The KMP <span>pattern</span><a id="id326007076" class="indexterm"></a> matching algorithm uses a pattern that has overlap in the pattern itself so that it avoids unnecessary comparisons. The main idea behind the KMP algorithm is to detect how much the pattern should be shifted, based on the overlaps in the patterns. The algorithm works as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>First, we precompute the <code class="literal">prefix</code> function for the given pattern and initialize a counter, q, that represents the number of characters that matched.</li><li>We start by comparing the first character of the pattern with the first character of the text string, and if this matches, then we increment the counter, <span class="strong"><strong>q</strong></span>, for the pattern and the counter for the text string, and we compare the next character.</li><li>If there is a mismatch, then we assign the value of the precomputed <code class="literal">prefix</code> function for <span class="strong"><strong>q</strong></span> to the index value of <span class="strong"><strong>q</strong></span>. </li><li>We continue searching the pattern in the text string until we reach the end of the text, that is, if we do not find any matches. If all of the characters in the pattern are matched in the text string, we return the position where the pattern is matched in the text and continue to search for another match.
</li></ol></div><p>Let's consider the following example to understand this:</p><p>The <code class="literal">prefix</code> function for the given pattern would be as follows:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/940e540a-a160-4538-ac06-3c5ad8966d5b.png" /></div><p>Now, we start comparing the first character of the pattern with the first character of the text string and continue comparing it until we find a match. For example, in the following diagram, we start by comparing character <span class="strong"><strong>a </strong></span>of the text string with the character <span class="strong"><strong>a</strong></span> of the pattern. As it is matched, we continue comparing until we find a mismatch or we have compared the whole pattern. Here, we find a mismatch at index position <span class="strong"><strong>6</strong></span>, so now we have to shift the pattern.
We find the number of shifts the <span>pattern</span><a id="id326007528" class="indexterm"></a> should take by using the help of the <code class="literal">prefix</code> function. This is because the <code class="literal">prefix</code> function has the value of<span class="strong"><strong>2</strong></span>at the mismatch position (that is, <code class="literal">prefix_function(6)</code> is <span class="strong"><strong>2</strong></span>), and so we start comparing the pattern from index position <code class="literal">2</code> of the pattern. Due to the efficiency of the KMP algorithm, we do not need to compare the character at<span class="strong"><strong>1</strong></span>index position, and we compare the characters <span class="strong"><strong>c</strong></span> of the pattern, and character <span class="strong"><strong>b</strong></span> of the text. Since these do not match, we shift the pattern by<span class="strong"><strong>1</strong></span>position, as follows:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/e0a0a50f-0b74-4061-a994-ed2719811730.png" /></div><p>Next, the compared characters are <span class="strong"><strong>b</strong></span> and <span class="strong"><strong>a</strong></span>—these do not match, so we shift the pattern by <span class="strong"><strong>1</strong></span> distance. Next, we compare the pattern and text string and find a mismatch at index position 10 in the text between characters <span class="strong"><strong>b</strong></span> and <span class="strong"><strong>c</strong></span>.  Here, we use the precomputed <code class="literal">prefix</code> function to shift the pattern, as the <code class="literal">prefix_function(4)</code> is <span class="strong"><strong>2</strong></span>, so we shift the at its index position of <span class="strong"><strong>2</strong></span>, as shown in the following diagram:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/1d06be4a-eaae-4744-98b9-42630b66e7c6.png" /></div><p>After that, we shift the pattern by 1 location as there is a mismatch between characters <span class="strong"><strong>b </strong></span>and <span class="strong"><strong>c</strong></span>. Next, we compare the characters at index <span class="strong"><strong>11</strong></span> in the text, and continue until a mismatch is found. We find a mismatch between characters <span class="strong"><strong>b</strong></span> and <span class="strong"><strong>c</strong></span>, as shown in the following diagram. We shift the <span>pattern</span><a id="id326044593" class="indexterm"></a> and move it to the index of <code class="literal">0</code> of the pattern as the <code class="literal">prefix_function(2)</code> is <code class="literal">0</code>. We repeat the same process until we reach the end of the string. We find a match of the pattern in the text string at the index location of <span class="strong"><strong>13</strong></span> in the text string, as follows:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/6bf78f26-01d1-475f-a80d-165d046db040.png" /></div><p>The KMP algorithm has two phases, the preprocessing phase,which is where we compute the <code class="literal">prefix</code> function, It takes the space and time complexity of <code class="literal">O(m)</code> and further, in the second phase, that searching, the KMP algorithm takes time complexity of  <code class="literal">O(n)</code>. </p><p>Now, we will discuss the implementation of the KMP algorithm by using Python.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch12lvl3sec51"></a>Implementing the KMP algorithm</h4></div></div></div><p>The Python implementation of the KMP algorithm is explained here. We start by implementing the <code class="literal">prefix</code> function for the given pattern. For this, first, we compute the length of the <span>pattern</span><a id="id326061034" class="indexterm"></a> by using the <code class="literal">len()</code> function, and then we initialize a list to store the computed values by the <code class="literal">prefix</code> function. </p><p><span>Next, we start the loop that executes from 2 to the length of the pattern</span>. Then, we have a nested loop that is executed until we have processed the whole pattern. The variable <code class="literal">k</code> is initialized to <code class="literal">0</code>, which is the <code class="literal">prefix</code> function for the first element of the pattern.  If the <code class="literal">k<sup>th</sup></code> element of the pattern is equal to the <code class="literal">q<sup>th</sup></code> element, then we increment the value of <code class="literal">k</code> by <code class="literal">1</code>.</p><p> </p><p> </p><p>The value of k is the computed value by the <code class="literal">prefix</code> function, and so we assign it at the index position of the <code class="literal">q</code> of the pattern. Finally, we return the list of the <code class="literal">prefix</code> function that has the computed value for each character of the pattern. The code for the <code class="literal">prefix</code> function is shown as follows:</p><pre class="programlisting">def pfun(pattern): # function to generate prefix function for the given pattern
    n = len(pattern) # length of the pattern
    prefix_fun = [0]*(n) # initialize all elements of the list to 0
    k = 0
    for q in range(2,n):
         while k&gt;0 and pattern[k+1] != pattern[q]:
            k = prefix_fun[k]
         if pattern[k+1] == pattern[q]: # If the kth element of the pattern is equal to the qth element
            k += 1            # update k accordingly
         prefix_fun[q] = k
    return prefix_fun         # return the prefix function </pre><p>Once we have created the <code class="literal">prefix</code> function, we implement the main <span>KMP</span><a id="id326076611" class="indexterm"></a> matching algorithm. We start by computing the length of the text string and the pattern, which are stored in the variables <code class="literal">m</code> and <code class="literal">n</code>, respectively. T<span>he following code shows this in detail:</span></p><pre class="programlisting">
def KMP_Matcher(text,pattern):     
    m = len(text)
    n = len(pattern)
    flag = False
    text = '-' + text       # append dummy character to make it 1-based indexing
    pattern = '-' + pattern       # append dummy character to the pattern also
    prefix_fun = pfun(pattern) # generate prefix function for the pattern
    q = 0
    for i in range(1,m+1):
        while q&gt;0 and pattern[q+1] != text[i]: 
        # while pattern and text are not equal, decrement the value of q if it is &gt; 0
            q = prefix_fun[q]
        if pattern[q+1] == text[i]: # if pattern and text are equal, update value of q
            q += 1
        if q == n: # if q is equal to the length of the pattern, it means that the pattern has been found.
            print("Pattern occours with shift",i-n) # print the index,</pre><p> </p><p> </p><pre class="programlisting">where first match occours.
            flag = True
            q = prefix_fun[q]
    if not flag:
            print('\nNo match found')


KMP_Matcher('aabaacaadaabaaba','abaac')         #function call</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lvl2sec77"></a>The Boyer-Moore algorithm</h3></div></div></div><p>As we have already discussed, the main objective of the string pattern matching algorithm is to find ways of skipping comparisons as much as possible by avoiding unnecessary comparisons.</p><p>The Boyer-Moore <span>pattern</span><a id="id326096350" class="indexterm"></a> matching algorithm is <span>another</span><a id="id326096359" class="indexterm"></a> such algorithm (apart from the KMP algorithm) that further improves the performance of pattern matching by skipping some comparisons using some methods. You need to understand the following concepts to be able to use the Boyer-Moore algorithm:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>In this algorithm, we shift the pattern in the direction from left to right, similar to the KMP algorithm</li><li>We compare the characters of the pattern and the text string from the right to the left direction, which is the opposite of the KMP algorithm</li><li>The algorithm skips the unnecessary comparisons by using the good-suffix and bad-character shifts concept</li></ol></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch12lvl3sec52"></a>Understanding the Boyer-Moore algorithm</h4></div></div></div><p>The Boyer-Moore algorithm compares the <span>pattern</span><a id="id326100585" class="indexterm"></a> over the text from right to left. It uses the information of the various possible alignments in the pattern by preprocessing it. The main idea of this algorithm is that we compare the end characters of the pattern with the text. If they do not match, then the pattern can be moved on further. If the characters do not match in the end, there is no need to do further comparisons. In addition, in this algorithm, we can also see what portion of the pattern has matched (with the matched suffix), so we utilize this information and align the text and pattern by skipping any unnecessary comparisons. </p><p>The Boyer-Moore algorithm has two heuristics to determine the maximum shift possible for the pattern when we find a mismatch:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Bad character heuristic</li><li style="list-style-type: disc">Good suffix heuristic</li></ul></div><p>At the time of a mismatch, each of these heuristics suggests possible shifts, and the Boyer-Moore algorithm shifts the pattern by considering the maximum shift possible due to bad character and good suffix heuristics. The details of the bad character and good suffix heuristics are explained in detail with examples in the following subsections.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch12lvl3sec53"></a>Bad character heuristic</h4></div></div></div><p>The Boyer-Moore algorithm compares the <span>pattern</span><a id="id326100613" class="indexterm"></a> and the text string in the direction from right to left. It uses the bad character heuristic to shift the pattern. According to the bad character shift concept, if there is a mismatch between the character of the pattern and the text, then we check if the mismatched character of the text occurs in the pattern or not. If this mismatched character (also known as a bad character) does not appear in the pattern, then the pattern will be shifted next to this character, and if that character appears somewhere in the pattern,  we shift the pattern to align with the occurrence of that character with the bad character of the text string.</p><p>Let's understand this concept by using an example. Consider a text string (T) and the pattern = {<span class="strong"><strong>acacac</strong></span>}. We start by comparing the characters from right to left, that is, character <span class="strong"><strong>b</strong></span> of the text string and character <span class="strong"><strong>c</strong></span> of the pattern. They do not match, so we look for the mismatched character of the text string, that is, <span class="strong"><strong>b</strong></span>, in the pattern. Since it does not occur in the pattern, we shift the pattern next to the mismatched character, as shown in the following diagram:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/9d830a75-1cbd-4dd8-972f-a2f9335fef27.png" /></div><p> </p><p>Let's look at another example. We start by comparing characters of the text string and the pattern from right to the left, and we get a mismatch for the character <span class="strong"><strong>d</strong></span> of the text. Here, the suffix <span class="strong"><strong>ac</strong></span> is matched, but the characters <span class="strong"><strong>d</strong></span> and <span class="strong"><strong>c</strong></span> do not match, and the mismatched character <span class="strong"><strong>d</strong></span> does not occur in the pattern. Therefore, we shift the <span>pattern</span><a id="id326109042" class="indexterm"></a> to the mismatched character, as shown in the following diagram:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/2eda199d-d023-4809-94d4-f3c80efa6ee6.png" /></div><p>Let's consider another example case for the bad character heuristic. Here, the suffix <span class="strong"><strong>ac </strong></span>is matched, but the next characters, <span class="strong"><strong>a</strong></span> and <span class="strong"><strong>c</strong></span>, do not match, so we search for the occurrences of the mismatched character <span class="strong"><strong>a</strong></span> in the pattern. Since it has two occurrences in the pattern, we have two options so that we can align the mismatched character, as shown in the following diagram. In such a situation, where we have more than one option to shift the pattern, we move the pattern with the minimum amount of shifts to avoid any possible match. (In other words, it would be the rightmost occurrence of that character in the pattern.) If we would have only one occurrence of the mismatched character in the pattern, we can easily shift the pattern in such a way that the mismatched character is aligned.</p><p>In the following example, we would prefer option <span class="strong"><strong>1</strong></span> to shift the pattern:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/8d12bccd-4409-424c-aebd-a6d003af0c54.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch12lvl3sec54"></a>Good suffix heuristic</h4></div></div></div><p>The bad character heuristic does not always provide good suggestions. The Boyer-Moore algorithm also uses good suffix heuristic as well to shift the <span>pattern</span><a id="id326109412" class="indexterm"></a> over the text string to find out the location of the matched patterns. </p><p>Good suffix heuristic is based on the matched suffix. Here, we shift the pattern to the right in such a way that the matched suffix subpattern is aligned with another occurrence of the same suffix in the pattern. It works like this: we start by comparing the pattern and the text string from right to left. If we find any mismatch, then we check the occurrence of the suffix that we have matched so far. This is known as the good suffix. We shift the pattern in such a way that we align another occurrence of the good suffix to the text. Good suffix heuristic has mainly two cases:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>The matching suffix has one or more occurrences in the pattern.</li><li>Some part of the matching suffix is present in the start of the pattern (this means that the suffix of the matched suffix exists as the prefix of the pattern).</li></ol></div><p>Let's understand these cases with the following examples. Suppose we have a pattern, <span class="strong"><strong>acabac</strong></span>. We get a mismatch for the characters <span class="strong"><strong>a</strong></span> and <span class="strong"><strong>b</strong></span>, but at this moment in time, we have already matched the suffix, that is, <span class="strong"><strong>ac</strong></span>. Now, we search for another occurrence of the good suffix <span class="strong"><strong>ac</strong></span> in the pattern and we shift the pattern by aligning that suffix, as follows:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/723da53c-c691-47d3-a3f3-da805b6ef899.png" /></div><p>Let's consider another example, where we have two options to align the shift of the <span>pattern</span><a id="id326109469" class="indexterm"></a> so that we get two good suffix strings. Here, we will take the option <span class="strong"><strong>1</strong></span> to align the good suffix by considering the option that has the minimum shifts, as follows:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/91dc6d5c-f4a1-4a8a-b6bf-02434df1f342.png" /></div><p>Let's take a look at another example. Here, we get a suffix match of <span class="strong"><strong>aac</strong></span>, but we get a mismatch for the characters <span class="strong"><strong>b</strong></span> and <span class="strong"><strong>a</strong></span>.  We search for the good suffix <span class="strong"><strong>aac</strong></span>, but we do not find another occurrence in the pattern. However, we find that the prefix, <span class="strong"><strong>ac</strong></span>, at the start of the pattern does not match with the whole suffix, but it does match with the suffix <span class="strong"><strong>ac</strong></span> of the matched suffix <span class="strong"><strong>aac</strong></span>. In such a situation, we shift the pattern by aligning with the suffix of <span class="strong"><strong>aac</strong></span> that is also a prefix of the pattern and align that prefix with the suffix, as follows:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/e7783fa8-d86d-4526-94cb-b3b0eb64106d.png" /></div><p>Another case for the good suffix heuristic is as follows. In this case, we match the suffix <span class="strong"><strong>aac</strong></span>, but we mismatch it at characters <span class="strong"><strong>b</strong></span> and <span class="strong"><strong>a</strong></span>. We try to search for the matched suffix in the pattern, but there is no occurrence of the suffix in the pattern, so in this situation, we shift the <span>pattern</span><a id="id326127612" class="indexterm"></a> after the matched suffix, as follows:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/c8b2d7e8-3ef4-4403-a3d9-69f10e669d5e.png" /></div><p> </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note14"></a>Note</h3><p>We shift the pattern by the longer distance that is given by the bad character heuristics and the good suffix heuristics.</p></div><p>The Boyer-Moore algorithm takes the time of <code class="literal">O(m)</code> for the preprocessing of the pattern, and further searching takes the time complexity of <code class="literal">O(mn)</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch12lvl3sec55"></a>Implementing the Boyer-Moore algorithm</h4></div></div></div><p>Let's understand the implementation of the Boyer-Moore algorithm. Initially, we have the text string and the pattern. After initializing the variables, we start with a while loop that starts by comparing the last character of the <span>pattern</span><a id="id326128033" class="indexterm"></a> to the corresponding character of the text.</p><p>Then, the characters are compared from right to left by the use of the nested loop from the last index of the pattern to the first character of the pattern. This uses <code class="literal">range(len(pattern)-1, -1, -1)</code>.</p><p>The outer while loop keeps tracks of the index in the text string while the inner for loop keeps track of the index position in the pattern.</p><p>Next, we start comparing the characters by using <code class="literal">pattern[j] != text[i+j]</code>. If they are mismatched, we make the flag variable <code class="literal">False</code>, denoting that there is a mismatch. </p><p>Now, we check if the good suffix is present or not by using the condition <code class="literal">j == len(pattern)-1</code>. If this condition is true, it means that there is no good suffix possible, so we check for the bad character heuristics, that is, if a mismatched character is present in the pattern or isn't using the condition <code class="literal">text[i+j] in pattern[0:j]</code>, and if the condition is true, then it means that the bad character is present in the pattern. In this case, we move the pattern to align this bad character to the other occurrence of this character in the pattern by using <code class="literal">i=i+j-pattern[0:j].rfind(text[i+j])</code>. Here, <code class="literal">(i+j)</code> is the index of the bad character. </p><p>If the bad character is not present in the pattern (it isn't in the <code class="literal">else</code> part of it), we move the whole pattern next to the mismatched character by using the index <code class="literal">i=i+j+1</code>.</p><p>Next, we go into the <code class="literal">else</code> part of the condition to check the good suffix. When we find the mismatch, we further test to see whether we have any subpart of a good suffix present in the prefix of the pattern. We do this by using the following condition:</p><pre class="programlisting"> text[i+j+k:i+len(pattern)] not in pattern[0:len(pattern)-1]</pre><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p>Furthermore, we check whether the length of the good suffix is <code class="literal">1</code> or not. If the length of the good suffix is <code class="literal">1</code>, we do not consider this shift. If the good suffix is more than <code class="literal">1</code>, we find out the number of shifts by using the good suffix heuristics and store this in the <code class="literal">gsshift</code> variable. This is the pattern to a position where the good suffix of a pattern matches with the good suffix of text using the instruction <code class="literal">gsshift=i+j+k-pattern[0:len(pattern)-1].rfind(text[i+j+k:i+len(pattern)])</code>. Furthermore, we computed the number of shifts possible due to the bad character heuristic and stored this in the <code class="literal">bcshift</code> variable. The number of shifts possible is <code class="literal">i+j-pattern[0:j].rfind(text[i+j])</code> when the bad character is present in the pattern, and the number of shifts possible would be <code class="literal">i+j+1</code> in the case of the bad character not being present in the pattern.</p><p>Next, we shift the <span>pattern</span><a id="id326128141" class="indexterm"></a> on the text string by the maximum number of moves given by a bad character and good suffix heuristics by using the instruction <code class="literal">i=max((bcshift, gsshift))</code>. Finally, we check whether the flag variable is <code class="literal">True</code> or not. If it is <code class="literal">True</code>, this means that the pattern has been found and that the matched index has been stored in the <code class="literal">matched_indexes</code> variable.</p><p>The complete implementation of the Boyer-Moore algorithm is shown as follows:</p><pre class="programlisting">text= "acbaacacababacacac"
pattern = "acacac"

matched_indexes = []
i=0
flag = True
while i&lt;=len(text)-len(pattern):
    for j in range(len(pattern)-1, -1, -1): #reverse searching
        if pattern[j] != text[i+j]:
            flag = False #indicates there is a mismatch
            if j == len(pattern)-1: #if good-suffix is not present, we test bad character 
                if text[i+j] in pattern[0:j]:
                    i=i+j-pattern[0:j].rfind(text[i+j]) #i+j is index of bad character, this line is used for jumping pattern to match bad character of text with same character in pattern
                else:
                    i=i+j+1 #if bad character is not present, jump pattern next to it
            else:
                k=1
                while text[i+j+k:i+len(pattern)] not in pattern[0:len(pattern)-1]: #used for finding sub part of a good-suffix
                    k=k+1
                if len(text[i+j+k:i+len(pattern)]) != 1: #good-suffix should not be of one character
                    gsshift=i+j+k-pattern[0:len(pattern)-1].rfind(text[i+j+k:i+len(pattern)]) #jumps pattern to a position where good-suffix of pattern matches with good-suffix of text
                else:
                    #gsshift=i+len(pattern)
                    gsshift=0 #when good-suffix heuristic is not applicable, we prefer bad character heuristic
                if text[i+j] in pattern[0:j]:
                    bcshift=i+j-pattern[0:j].rfind(text[i+j]) #i+j is index of bad character, this line is used for jumping pattern to match bad character of text with same character in pattern
                else:
                    bcshift=i+j+1
                i=max((bcshift, gsshift))
            break
    if flag: #if pattern is found then normal iteration
        matched_indexes.append(i)
        i = i+1
    else: #again set flag to True so new string in text can be examined
        flag = True

print ("Pattern found at", matched_indexes)
</pre></div></div></div>