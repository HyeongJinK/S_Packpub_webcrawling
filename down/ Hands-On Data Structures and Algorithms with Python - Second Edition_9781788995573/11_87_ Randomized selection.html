<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch11lvl1sec85"></a>Randomized selection</h2></div></div><hr /></div><p>In the previous chapter, we <span>discussed</span><a id="id326466972" class="indexterm"></a> the quicksort algorithm. The <span>quicksort</span><a id="id326466992" class="indexterm"></a> algorithm allows us to sort an unordered list of items, but has a way of preserving the index of elements as the sorting algorithm runs. Generally speaking, the quicksort algorithm does the following:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Selects a pivot</li><li>Partitions the unsorted list around the pivot</li><li>Recursively sorts the two halves of the partitioned list using <span class="emphasis"><em>steps 1</em></span> and <span class="emphasis"><em>2</em></span></li></ol></div><p>One interesting and important fact is that after every partitioning step the index of the pivot will not change, even after the list has become sorted. This means that after each iteration the selected pivot value will be placed at its correct position in the list. It is this property that enables us to be able to work with a not-so-fully sorted list to obtain the <code class="literal">i<sup>th</sup></code> smallest number. Because randomized selection is based on the quicksort algorithm, it is generally referred to as quick select.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec70"></a>Quick select</h3></div></div></div><p>The quickselect algorithm is <span>used</span><a id="id325898385" class="indexterm"></a> to obtain the <code class="literal">k<sup>th</sup></code> smallest element in an <span>unordered</span><a id="id326096222" class="indexterm"></a> list of items, and is based on the quicksort algorithm. In quicksort, we recursively sort the elements of both the sublists from the pivot point. In quicksort, in each iteration, we know that the pivot value reaches its correct position in the list with two sublists (left and right sublists), having all of their elements set to be unordered.</p><p>However, in the case of the quickselect algorithm, we recursively call the function exclusively for the sublist that has the <code class="literal">k<sup>th</sup></code> smallest element. In the quickselect algorithm, we compare the index of the pivot point with the <code class="literal">k</code> value to obtain the <code class="literal">k<sup>th</sup></code> smallest element from the given unordered list. There will be three cases in the quickselect algorithm, and they are as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li> If the index of the pivot point is smaller than <code class="literal">k</code>, then we are sure that the <code class="literal">k<sup>th</sup></code> smallest value will be present in the right sublist from the pivot point. So, we only recursively call the quickselect function for the right sublist. </li><li>If the index of the pivot point is greater than <code class="literal">k</code>, then it is obvious that the <code class="literal">k<sup>th</sup></code> smallest element will be present in the left side from the pivot point. So, we only recursively look for the <code class="literal">i<sup>th</sup></code> element in the left sublist.</li><li>If the index of the pivot point is equal to <code class="literal">k</code>, then it means that we have found out the <code class="literal">k<sup>th</sup></code> smallest value, and we return it.</li></ol></div><p>Let's understand how the quickselect algorithm work by looking at an example. Let's consider a list of elements, <code class="literal">{45, 23, 87, 12, 72, 4, 54, 32, 52}</code>, where want to find out the 3<sup>rd</sup> smallest element from this list—we do this by using the quicksort algorithm.</p><p>We start the algorithm by selecting a pivot value, that is, 45. After the first iteration of the algorithm, we place the pivot value to its correct position in the list, that is, at index 4 (the index is starting from 0). Now, we compare the index of the pivot value (that is, 4 ) with the value of <code class="literal">k</code> (that is, 3<sup>rd</sup> position, or at index 2). Since this is at the <code class="literal">k&lt;pivot</code> point (that is, 2&lt;4), we only consider the left sublist, and recursively call the function.</p><p>Now, we take the left sublist and select the pivot point (that is, <span class="strong"><strong>4</strong></span>). After the run, the <span class="strong"><strong>4</strong></span> is placed at its correct position (that is, the 0<sup>th</sup> index). As the index of the pivot is less than the value of <code class="literal">k</code>, we consider the right sublist. Similarly, we take<span class="strong"><strong>23</strong></span>as the pivot point, which is also placed at its correct position. Now, when we compare the index of the pivot point and the value of <code class="literal">k</code>, they are equal, which means we have found the 3<sup>rd</sup>smallest element, and it will be returned. </p><p>This process is also shown in the following diagram:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/ebf65443-2d09-4b66-b3dc-4c88e953b073.png" /></div><p>To implement the <span>quickselect</span><a id="id326265533" class="indexterm"></a> algorithm, we first need to understand the main function, where we have three possible conditions. We declare the main method of the algorithm as follows:</p><pre class="programlisting">    def quick_select(array_list, left, right, k): 

        split = partition(array_list, left, right) 

        if split == k: 
            return array_list[split] 
        elif split &lt; k: 
            return quick_select(array_list, split + 1, right, k) 
        else: 
            return quick_select(array_list, left, split-1, k) </pre><p>The <code class="literal">quick_select</code> function takes the index of the first element in the list—as well as the last —as parameters. The <code class="literal">i<sup>th</sup></code> element is specified by the third parameter, <code class="literal">k</code>. The value of <code class="literal">k</code> should always be positive; the values greater or equal to zero (<code class="literal">0</code>) are only allowed in such a way that when <code class="literal">k</code> is <code class="literal">0</code>, we know to search for the first-smallest item in the list. Others like to treat the <code class="literal">k</code> parameter so that it maps directly with the index that the user is searching for, so that the first-smallest number maps to the <code class="literal">0</code> index of a sorted list.</p><p>A method call to the partition function, <code class="literal">split = partition(array_list, left, right)</code>, returns the <code class="literal">split</code> index. This index of the <code class="literal">split</code> array is the position in the unordered list where all elements between <code class="literal">right</code> to <code class="literal">split-1</code> are less than the element contained in the <code class="literal">split</code> array, while all elements between <code class="literal">split+1</code> to <code class="literal">left</code> are greater.</p><p>When the <code class="literal">partition</code> function returns the <code class="literal">split</code> value, we compare it with <code class="literal">k</code> to find out if the <code class="literal">split</code> corresponds to the <code class="literal">k<sup>th</sup></code> items.</p><p>If <code class="literal">split</code> is less than <code class="literal">k</code>, then it means that the <code class="literal">k<sup>th</sup></code> smallest item should exist or be found between <code class="literal">split+1</code> and <code class="literal">right</code>:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/296e7357-dfae-43e2-ac2f-853f656b3618.png" /></div><p>In the preceding example, a split within an <span>imaginary</span><a id="id326467642" class="indexterm"></a> unordered list occurs at index <span class="strong"><strong>5</strong></span>, while we are searching for the second-smallest number. Since 5&lt;2 yields <code class="literal">false</code>, a recursive call to return <code class="literal">quick_select(array_list, left, split-1, k)</code> is made so that the other half of the list is searched.</p><p>If the <code class="literal">split</code> index was less than <code class="literal">k</code>, then we would make a call to <code class="literal">quick_select</code>, like this:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/f3acb343-5760-4e3e-8d95-23822ea2a802.png" /></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch11lvl3sec47"></a>Understanding the partition step</h4></div></div></div><p>The partition step is similar to what we had in the <span>quicksort</span><a id="id326534866" class="indexterm"></a> algorithm. There are a couple of things that are worth noting:</p><pre class="programlisting">    def partition(unsorted_array, first_index, last_index): 
        if first_index == last_index: 
            return first_index 

        pivot = unsorted_array[first_index] 
        pivot_index = first_index 
        index_of_last_element = last_index 

        less_than_pivot_index = index_of_last_element 
        greater_than_pivot_index = first_index + 1 

        while True: 

            while unsorted_array[greater_than_pivot_index] &lt; pivot and  
                  greater_than_pivot_index &lt; last_index: 
                  greater_than_pivot_index += 1 
            while unsorted_array[less_than_pivot_index] &gt; pivot and 
                  less_than_pivot_index &gt;= first_index: 
                  less_than_pivot_index -= 1 

            if greater_than_pivot_index &lt; less_than_pivot_index: 
                temp = unsorted_array[greater_than_pivot_index] 
                unsorted_array[greater_than_pivot_index] = 
                    unsorted_array[less_than_pivot_index] 
                unsorted_array[less_than_pivot_index] = temp 
            else: 
                break 

        unsorted_array[pivot_index] =  
            unsorted_array[less_than_pivot_index] 
        unsorted_array[less_than_pivot_index] = pivot 

        return less_than_pivot_index </pre><p>An <code class="literal">if</code> statement has been inserted at the beginning of the <span>function</span><a id="id326534886" class="indexterm"></a> definition to cater for situations where <code class="literal">first_index</code> is equal to <code class="literal">last_index</code>. In such cases, it means that there is only one element in our sublist. Therefore, we simply return any of the function parameters, in this case, <code class="literal">first_index</code>.</p><p>The first element is always chosen as the pivot. This choice to make the first element the pivot is a random decision. It often does not yield a good split—and subsequently—a good partition. However, the <code class="literal">i<sup>th</sup></code> element will eventually be found, even though the pivot is chosen at random.</p><p>The <code class="literal">partition</code> function returns the pivot index pointed to by <code class="literal">less_than_pivot_index</code>, as we saw in the preceding chapter.</p></div></div></div>