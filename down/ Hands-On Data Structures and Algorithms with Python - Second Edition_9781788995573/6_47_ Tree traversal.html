<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec50"></a>Tree traversal</h2></div></div><hr /></div><p>The method to visit all the nodes in a <span>tree</span><a id="id325851489" class="indexterm"></a> is called <span class="strong"><strong>tree traversal</strong></span>. This can be done either <span class="strong"><strong>depth-first</strong></span> <span class="strong"><strong>search</strong></span> (<span class="strong"><strong>DFS</strong></span>) or <span class="strong"><strong>breadth-first search</strong></span> (<span class="strong"><strong>BFS</strong></span>). We will discuss these two methods in the subsequent subsections.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec36"></a>Depth-first traversal</h3></div></div></div><p>In depth-first traversal, we <span>traverse</span><a id="id325590552" class="indexterm"></a> the tree, starting from the root, and go <span>deeper</span><a id="id325590536" class="indexterm"></a> into the tree as much as possible on each child, and then continue to traverse to the next sibling. We use <span>the recursive approach</span> for tree traversal. There are three forms of depth-first traversal, namely, in-order, pre-order, and post-order.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec41"></a>In-order traversal and infix notation</h4></div></div></div><p>In-order tree traversal works as follows. First of all, we check if the <span>current</span><a id="id325590562" class="indexterm"></a> node is null or empty. If it is not empty, we traverse the tree. In in-order tree traversal, we follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>We start traversing the left sub-tree and call the <code class="literal">inorder</code> function recursively</li><li>Next, we visit the root node</li><li>Finally, we traverse the right sub-tree and call the <code class="literal">inorder</code> function recursively</li></ol></div><p>So, in a nutshell, in in-order tree traversal, we visit the nodes in the tree in the order of (left sub-tree, root, right sub-tree). </p><p>Let's consider an example to understand in-order tree traversal: </p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/f8e3763d-3a28-4ace-8b07-92e571a5023d.png" /></div><p>In the example binary tree for in-order traversal, first, we recursively visit the left sub-tree of the root node <span class="strong"><strong>A</strong></span>. The left sub-tree of node <span class="strong"><strong>A</strong></span> has node <span class="strong"><strong>B</strong></span> as root, so we again go to the left sub-tree of the root node <span class="strong"><strong>B</strong></span>, that is, node <span class="strong"><strong>D</strong></span>. We recursively go to the left sub-tree of root node <span class="strong"><strong>D </strong></span>so that we get the left child with root node <span class="strong"><strong>D</strong></span>. So, first, we visit the left child, that is, <span class="strong"><strong>G</strong></span>, then visit the root node, <span class="strong"><strong>D</strong></span>, and then visit the right child, <span class="strong"><strong>H</strong></span>.</p><p> </p><p>Next, we visit node <span class="strong"><strong>B</strong></span> and then visit node <span class="strong"><strong>E</strong></span>. In this manner, we have visited the left sub-tree with the root node <span class="strong"><strong>A</strong></span>. So, next, we visit the root node <span class="strong"><strong>A</strong></span>. After that, we will visit the right sub-tree with root node <span class="strong"><strong>A</strong></span>. Here, we go to the left sub-tree with root node <span class="strong"><strong>C</strong></span>, which is null, so next we visit node <span class="strong"><strong>C</strong></span>, and then we visit the right child of node <span class="strong"><strong>C</strong></span>, that is, node <span class="strong"><strong>F</strong></span>.</p><p>Therefore, the in-order traversal for this example tree is <code class="literal">G–D-H-B-E-A-C-F</code>.</p><p>The Python implementation of a recursive function to return an <code class="literal">inorder</code> listing of nodes in a tree is as follows:</p><pre class="programlisting">    def inorder(self, root_node): 
        current = root_node 
        if current is None: 
            return 
        self.inorder(current.left_child) 
        print(current.data) 
        self.inorder(current.right_child) </pre><p>We visit the node by printing the visited node. In this case, we first recursively call the <code class="literal">inorder</code> function with <code class="literal">current.left_child</code>, then we visit the root node, and finally we recursively call the <code class="literal">inorder</code> function with <code class="literal">current.right_child</code> once more.</p><p>The <span class="strong"><strong>infix</strong></span> notation (also known as reverse Polish notation) is a commonly used notation to express arithmetic expressions where the operators are placed in-between the operands. It is common to use this way of representing an arithmetic expression since this is the way we are <span>normally</span><a id="id325902000" class="indexterm"></a> taught in schools. For example, the operator is inserted (infixed) between the operands, as in <code class="literal">3 + 4</code>. When necessary, parentheses can be used to build a more complex expression, such as <code class="literal">(4 + 5) * (5 - 3)</code>.</p><p>An expression tree is a special kind of <span class="strong"><strong>binary tree</strong></span> that can be used to represent arithmetic expressions. This in-order traversal of an expression tree produce the infix notation. For example, consider the following expression tree:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/8384e7e4-dca8-4a6b-8967-96798e70fbf8.png" /></div><p>The in-order traversal of the preceding expression tree gives us the infix notation, that is, <code class="literal">(5 + 3)</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec42"></a>Pre-order traversal and prefix notation</h4></div></div></div><p>Pre-order tree traversal works as follows. First of all, we check if the <span>current</span><a id="id325913854" class="indexterm"></a> node is null or empty. If it is not empty, we traverse the tree. The pre-order tree traversal works as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>We start traversing with the root node</li><li>Next, we traverse the left sub-tree and call the <code class="literal">preorder</code> function with the left sub-tree recursively</li><li>Next, we visit the right sub-tree and call the <code class="literal">preorder</code> function with the right sub-tree recursively</li></ol></div><p>So, to traverse a tree in pre-order mode, we visit the tree in the order of root node, the left sub-tree, and the right sub-tree node. </p><p>Consider the following example tree to understand pre-order traversal:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/f8e3763d-3a28-4ace-8b07-92e571a5023d.png" /></div><p>In the preceding example of a binary tree, first, we visit root node <span class="strong"><strong>A</strong></span>. Next, we go to the left sub-tree of root node <span class="strong"><strong>A</strong></span>. The left sub-tree of node <span class="strong"><strong>A</strong></span> has node <span class="strong"><strong>B</strong></span> as the root, so we visit this root node and the go to the left sub-tree of root node <span class="strong"><strong>B</strong></span>, that is, node <span class="strong"><strong>D</strong></span>. We then visit node <span class="strong"><strong>D</strong></span> and go to the left sub-tree of root node <span class="strong"><strong>D</strong></span>, and then we visit the left child, <span class="strong"><strong>G</strong></span>, which is the sub-tree of root node <span class="strong"><strong>D</strong></span>. Next, we visit the right child of the sub-tree with root node <span class="strong"><strong>D</strong></span>, that is, node <span class="strong"><strong>H</strong></span>. Next, we visit the right child of the sub-tree with root node <span class="strong"><strong>B</strong></span>, that is, node <span class="strong"><strong>E</strong></span>. So, in this manner, we have visited root node <span class="strong"><strong>A</strong></span> and the left sub-tree with root node <span class="strong"><strong>A</strong></span>. Now, we will visit the right sub-tree of root node <span class="strong"><strong>A</strong></span>. Here, we visit the root node <span class="strong"><strong>C</strong></span>, and then we go to the left sub-tree with root node <span class="strong"><strong>C</strong></span>, which is null, so next, we visit the right child of node <span class="strong"><strong>C</strong></span>, that is, node <span class="strong"><strong>F</strong></span>.</p><p>The pre-order traversal for this example tree would be <code class="literal">A-B-D-G-H-E-C-F</code>.</p><p> </p><p>The recursive function for <code class="literal">pre-order</code> tree traversal is as follows:</p><pre class="programlisting">    def preorder(self, root_node): 
        current = root_node 
        if current is None: 
            return 
        print(current.data) 
        self.preorder(current.left_child) 
        self.preorder(current.right_child) </pre><p>Prefix notation is commonly referred to as Polish notation. In this notation, the operator comes before its operands. Prefix notation is well known to LISP programmers. For example, the <span>arithmetic</span><a id="id325923534" class="indexterm"></a> expression to add two numbers, 3 and 4, would be shown as <code class="literal">+ 3 4</code>. Since there is no ambiguity of precedence, parentheses are not required: <code class="literal">* + 4 5 - 5 3</code>.</p><p>Let's consider another example, that is, the <code class="literal">(3 +4) * 5 </code>. This can also be represented as <code class="literal">* (+ 3 4) 5</code> in prefix notation. </p><p>The pre-order traversal of an expression tree results in the prefix notation of the arithmetic expression. For example, consider the following expression tree:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/f3c1592e-bd28-4edf-b47e-c30e1496c677.png" /></div><p>The preorder traversal of the preceding tree will give the expression in prefix notation as <code class="literal">+- 8 3 3</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec43"></a>Post-order traversal and postfix notation</h4></div></div></div><p><code class="literal">Post-order</code> tree traversal works as follows. First of all, we check if the <span>current</span><a id="id325928057" class="indexterm"></a> node is null or empty. If it is not empty, we traverse the tree. <code class="literal">Post-order</code> tree traversal works as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>We start traversing the left sub-tree and call the <code class="literal">postorder</code> function recursively</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Next, we traverse the right sub-tree and call the postorder function recursively</li><li>Finally, we visit the root node</li></ol></div><p>So. in a nutshell, regarding <code class="literal">post-order</code> tree traversal, we visit the nodes in the tree in the order of left sub-tree, right sub-tree, and finally the root node. </p><p>Consider the following example tree to understand post-order tree traversal:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/f8e3763d-3a28-4ace-8b07-92e571a5023d.png" /></div><p>In the preceding diagram, we first visit the left sub-tree of root node <span class="strong"><strong>A</strong></span> recursively. We get to the last left subtree, that is, root node D, and then we visit the left node of it, which is node <span class="strong"><strong>G</strong></span>. Then, we visit the right child, <strong class="userinput"><code>H</code></strong>, and then we visit the root node <strong class="userinput"><code>D</code></strong>. Following the same rule, we next visit the right child of node <span class="strong"><strong>B</strong></span>, that is, node <span class="strong"><strong>E</strong></span>. Then, we visit node <span class="strong"><strong>B</strong></span>. Following on from this, we traverse the right sub-tree of node <span class="strong"><strong>A</strong></span>. Here, we first reach the last right sub-tree and visit node <span class="strong"><strong>F</strong></span>, and then we visit node <span class="strong"><strong>C</strong></span>. Finally, we visit root node <span class="strong"><strong>A</strong></span>.</p><p>The postorder traversal for this example tree would be <code class="literal">G-H-D-E-B-F-C-A</code>.</p><p>The implementation of the <code class="literal">post-order</code> method for tree traversal is as follows:</p><pre class="programlisting">    def postorder(self, root_node): 
        current = root_node 
        if current is None: 
            return 
        self.postorder(current.left_child) 
        self.postorder(current.right_child) 

        print(current.data)</pre><p> </p><p> </p><p>Postfix or <span class="strong"><strong>reverse Polish notation</strong></span> (<span class="strong"><strong>RPN</strong></span>) places the <span>operator</span><a id="id325963655" class="indexterm"></a> after its operands, as in <code class="literal">3 4 +</code>. As is the case with Polish notation, there is no further confusion over the precedence of operators, so parentheses are never needed: <code class="literal">4 5 + 5 3 - *</code>.</p><p>The post-order traversal of the following expression tree will give the postfix notation of the arithmetic expression:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/f3c1592e-bd28-4edf-b47e-c30e1496c677.png" /></div><p>The postfix notation for the preceding expression tree is <code class="literal">8 3 -3 +</code>.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec37"></a>Breadth-first traversal</h3></div></div></div><p>Breadth-first traversal starts from the root of the tree and then <span>visits</span><a id="id325963696" class="indexterm"></a> every node on the next level of the tree. Then, we move to the next level in the tree, and so on. This kind of tree traversal is breadth-first as it broadens the tree by traversing all the nodes in a level before going deep into the tree. </p><p>Let's consider the following example tree and traverse it by using the breadth-first traversal method:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/07b1d437-6d1e-4a08-b2b7-214856c0d671.png" /></div><p>In the preceding diagram, we start by visiting the root node at <span class="strong"><strong>level 0</strong></span>, that is, the node with a value of <span class="strong"><strong>4</strong></span>. We visit this node by printing out its value. Next, we move to <span class="strong"><strong>level 1</strong></span> and visit all the nodes on this level, which are the nodes with the values <span class="strong"><strong>2</strong></span> and <span class="strong"><strong>8</strong></span>. Finally, we move to the next level in the tree, that is, <span class="strong"><strong>level 3</strong></span>, and we visit all the nodes at this level. The nodes at this level are <span class="strong"><strong>1</strong></span>, <span class="strong"><strong>3</strong></span>, <span class="strong"><strong>5</strong></span>, and <span class="strong"><strong>10</strong></span>.</p><p>Thus, the breadth-first tree traversal for this tree is as follows—<span class="strong"><strong>4</strong></span>, <span class="strong"><strong>2</strong></span>, <span class="strong"><strong>8</strong></span>, <span class="strong"><strong>1</strong></span>, <span class="strong"><strong>3</strong></span>, <span class="strong"><strong>5</strong></span>, and <span class="strong"><strong>10</strong></span>.</p><p>This mode of traversal is implemented using a queue data structure. Starting with the root node, we push it into a queue. The node at the front of the queue is accessed (dequeued) and either printed or stored for later use. The left node is added to the queue followed by the right node. Since the queue is not empty, we repeat this process.</p><p>The Python implementation of this algorithm will <span>enqueue</span><a id="id325979703" class="indexterm"></a> the root node <span class="strong"><strong>4</strong></span>, dequeue it, and visit the node. Next, nodes <span class="strong"><strong>2</strong></span> and <span class="strong"><strong>8</strong></span> are enqueued as they are the left and right nodes at the next level, respectively. Node <span class="strong"><strong>2</strong></span> is dequeued so that it can be visited. Next, its left and right nodes, that is, nodes <span class="strong"><strong>1</strong></span> and <span class="strong"><strong>3</strong></span>, are enqueued. At this point, the node at the front of the queue is <span class="strong"><strong>8</strong></span>. We dequeue and visit node <span class="strong"><strong>8</strong></span>, after which we enqueue its left and right nodes. This process continues until the queue is empty.</p><p>The Python implementation of breadth-first traversal is as follows:</p><pre class="programlisting">    from collections import deque 
    class Tree: 
        def breadth_first_traversal(self): 
            list_of_nodes = [] 
            traversal_queue = deque([self.root_node]) </pre><p>We enqueue the root node and keep a list of the visited nodes in the <code class="literal">list_of_nodes</code> list. The <code class="literal">dequeue</code> class is used to maintain a queue:</p><pre class="programlisting">        while len(traversal_queue) &gt; 0: 
            node = traversal_queue.popleft() 
            list_of_nodes.append(node.data) 
               if node.left_child: 
                traversal_queue.append(node.left_child) 

            if node.right_child: 
                traversal_queue.append(node.right_child) 
        return list_of_nodes</pre><p> </p><p> </p><p>If the number of elements in <code class="literal">traversal_queue</code> is greater than zero, the body of the loop is executed. The node at the front of the queue is popped off and appended to the <code class="literal">list_of_nodes</code> list. The first <code class="literal">if</code> statement will <code class="literal">enqueue</code> the left child node if the <code class="literal">node</code> provided with a left node exists. The second <code class="literal">if</code> statement does the same for the right child node.</p><p>The <code class="literal">list_of_nodes</code> list is returned in the last statement.</p></div></div>