<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec57"></a>Hash tables </h2></div></div><hr /></div><p>A<span class="strong"><strong> hash table</strong></span> is a data structure where elements are accessed by a keyword rather than an index number, <span>unlike</span><a id="id325855505" class="indexterm"></a> in <span class="strong"><strong>lists</strong></span> and <span class="strong"><strong>arrays</strong></span>. In this data structure, the data <span>items</span><a id="id325855482" class="indexterm"></a> are stored in key/value pairs similar to dictionaries. A hash table uses a hashing function in order to find an index position where an element should be stored and retrieved. This gives us fast lookups since we are using an index number that corresponds to the <span>hash</span><a id="id325855473" class="indexterm"></a> value of the key. </p><p>Each position in the hash table data <span>structure</span><a id="id325851504" class="indexterm"></a> is often called a <span class="strong"><strong>slot</strong></span> or <span class="strong"><strong>bucket</strong></span> and<span class="strong"><strong> </strong></span>can <span>store</span><a id="id325851484" class="indexterm"></a> an element. So, each data item in the form of <code class="literal">(key, value)</code> pairs would be stored in the hash table at a position that is decided by the hash value of the data. For example, the hashing function maps the input string names to a hash value; the <code class="literal">hello world</code> string is mapped to a hash value of 92, which finds a slot position in the hash table. Consider the following diagram:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/87a93dda-c6b3-4bd0-b22d-a325e086c8e2.png" /></div><p>To implement the hash table, we start by creating a class to hold hash table items. These need to have a key and a value since our hash table is a <code class="literal">{key-value}</code> store:</p><pre class="programlisting">    class HashItem: 
        def __init__(self, key, value): 
            self.key = key 
            self.value = value </pre><p>This gives us a very simple way to store items. Next, we start <span>working</span><a id="id325837820" class="indexterm"></a> on the hash table class itself. As usual, we start off with a constructor:</p><pre class="programlisting">    class HashTable: 
        def __init__(self): 
            self.size = 256 
            self.slots = [None for i in range(self.size)] 
            self.count = 0 </pre><p>The hash table uses a standard Python list to store its elements. Let's set the size of the hash table to 256 elements to start with. Later, we will look at strategies for how to grow the hash table as we begin filling it up. We will now initialize a list containing 256 elements in the code. These are the positions where the elements are to be stored—the slots or buckets. So, we have 256 slots to store elements in the hash table. Finally, we add a counter for the number of actual hash table elements we have:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/ed24fc90-a031-4587-a58f-bbcaad5ecaa2.png" /></div><p>It is important to note the difference between the size and count of a table. The size of a table refers to the total number of slots in the table (used or unused). The count of the table refers to the number of slots that are filled, meaning the number of actual <code class="literal">(key-value)</code> pairs that have been added to the table.</p><p>Now, we have to decide on adding our hashing function to the table. We can use the same hash function that returns the sum of ordinal values for each character in the strings with a slight change. Since our hash table has 256 slots, that means we need a hashing function that returns a value in the range of 1 to 256 (the size of the table). A good way of doing it is to return the remainder of dividing the hash value by the size of the table since the remainder would surely be an integer value between 0 and 255.</p><p> </p><p>As the hashing function is only meant to be used internally by the class, we put an underscore (<code class="literal">_</code>) at the beginning of the name to indicate this. This is a normal Python convention for indicating that something is meant for internal use. Here is the implementation of the <code class="literal">hash</code> function:</p><pre class="programlisting">    def _hash(self, key): 
        mult = 1 
        hv = 0 
        for ch in key: 
            hv += mult * ord(ch) 
            mult += 1 
        return hv % self.size </pre><p>For the time being, we are going to assume that keys are strings. We shall discuss how one can use non-string keys later. For now, the <code class="literal">_hash()</code> function is going to generate the hash value for a string.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec48"></a>Storing elements in a hash table</h3></div></div></div><p>To store the elements in the <span>hash</span><a id="id325644877" class="indexterm"></a> table, we add them to the <span>table</span><a id="id325644886" class="indexterm"></a> with the <code class="literal">put()</code> function and retrieve them with the <code class="literal">get()</code> function. First, we will look at the implementation of the <code class="literal">put()</code> function. We start by embedding the key and the value into the <code class="literal">HashItem</code> class and then compute the hash value of the key.   </p><p>Here is the implementation of the <code class="literal">put</code> function to store the elements in the hash table:</p><pre class="programlisting">    def put(self, key, value): 
        item = HashItem(key, value) 
        h = self._hash(key) </pre><p>Once we know the hash value of the key, it will be used to find the position where the element should be stored in the hash table. Hence, we need to find an empty slot. We start at the slot that corresponds to the hash value of the key. If that slot is empty, we insert our item there.</p><p>However, if the slot is not empty and the key of the item is not the same as our current key, then we have a collision. It means that we have a hash value for the item that is the same as some previously stored item in the table. This is where we need to figure out a way to handle a conflict.</p><p> </p><p> </p><p>For example, in the following diagram, the <span class="strong"><strong>hello world</strong></span> key string is already stored in the table, and there is a collision when a new string, <code class="literal">world hello</code>, gets the same hash value of <code class="literal">92</code>. Take a look at the following diagram:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/fc4e64d6-a1d0-4d50-89f5-8ae0166d337b.png" /></div><p>One way of resolving this kind of collision is to find another free slot from the position of the collision; this collision resolution process is called <span class="strong"><strong>open addressing</strong></span>. We can do this by <span>linearly</span><a id="id325992564" class="indexterm"></a> looking for the next available slot by adding <code class="literal">1</code> to the previous hash value where we get the collision. We can resolve this conflict by adding<code class="literal">1</code>to the sum of the ordinal values of each character in the key string, which is further divided by the size of the hash table to obtain the hash value. This systematic way of visiting each slot is a linear way of resolving <span>collisions</span><a id="id325993041" class="indexterm"></a> and is called<span class="strong"><strong>linear probing</strong></span>.</p><p>Let's consider an example as shown in the <span>following</span><a id="id326638296" class="indexterm"></a> diagram to better <span>understand</span><a id="id326638305" class="indexterm"></a> how we resolve this collision. The hash value for the <code class="literal">eggs</code> key string is<code class="literal">51</code>. Now, there is a collision because we have already used this location to store data. Therefore, we add <code class="literal">1</code> in the hash value that is computed by the sum of the ordinal values of each character of the string to resolve the collision. Hence, we obtain a new hash value for this key string to store the data—location <code class="literal">52</code>. See the following diagram and code snippet for this implementation:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/d86ed3c9-7de8-4d67-bbf1-4ace37ede19d.png" /></div><p>Now, consider the following code:</p><pre class="programlisting">    while self.slots[h] is not None: 
        if self.slots[h].key is key: 
            break 
        h = (h + 1) % self.size </pre><p>The preceding code is to check whether the slot is empty, then get the new hash value using the method described. If the slot is empty, to store the new element (that means the slot contained <code class="literal">None</code> previously), then we increase the count by one. Finally, we insert the item into the list at the required position:</p><pre class="programlisting">    if self.slots[h] is None: 
        self.count += 1 
    self.slots[h] = item  </pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec49"></a>Retrieving elements from the hash table</h3></div></div></div><p>To retrieve the <span>elements</span><a id="id326639341" class="indexterm"></a> from the hash table, the value <span>stored</span><a id="id326639350" class="indexterm"></a> corresponding to the key would be returned. Here, we will discuss the implementation of the retrieval method—the <code class="literal">get()</code> method. This method would return the value stored in the table corresponding to the given key.</p><p>First of all, we compute the hash of the given key corresponding to the value that is to be retrieved.  Once we have the hash value of the key, we look up the hash table at the position of the hash value. If the key item is matched with the stored key value at that location, the corresponding<code class="literal">value</code>is retrieved. If that does not match, then we add<code class="literal">1</code>to the sum of the ordinal values of all the characters in the string, similar to what we did at the time of storing the data, and we look at the newly obtained hash value. We keep looking until we get our key element or we check all the slots in the hash table.</p><p>Consider an example to understand the concept in the following diagram in four steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>We compute the hash value for the given key string, <code class="literal">"egg"</code>, which turns out to be <code class="literal">51</code>. Then, we compare this key with the stored key value at location <code class="literal">51</code>, but it does not match.</li><li>As the key does not match, we compute a new hash value.</li><li>We look up the key at the location of the newly created hash value, which is <code class="literal">52</code>; we compare the key string with the stored key value and, here, it matches, as shown in the following diagram.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>The stored value is returned corresponding to this key value in the hash table. See the following diagram:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788995573/graphics/7dd986c0-1233-41fa-b1d5-ec74b3f30bd9.png" /></div><p>To implement this retrieval method that is, the <code class="literal">get()</code> method, we start by calculating the hash of the key. Next, we look up at the computed hash value in the table. If there is a match, we return the corresponding stored value. Otherwise, we keep looking at the <span>new</span><a id="id325608152" class="indexterm"></a> hash value location computed as described. Here is the <span>implementation</span><a id="id325608161" class="indexterm"></a> of the <code class="literal">get()</code> method:</p><pre class="programlisting">def get(self, key): 
    h = self._hash(key)    # computer hash for the given key 
    while self.slots[h] is not None:
        if self.slots[h].key is key: 
            return self.slots[h].value 
        h = (h+ 1) % self.size 
    return None        </pre><p>Finally, we return <code class="literal">None</code> if the key was not found in the table. Another good alternative may be to raise an exception in case the key does not exist in the table.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec50"></a>Testing the hash table</h3></div></div></div><p>To test our hash table, we create <code class="literal">HashTable</code> and store a <span>few</span><a id="id325896245" class="indexterm"></a> elements in it, then try to retrieve them. We will also try to <code class="literal">get()</code> a key that does not exist. We also use the two strings, <code class="literal">ad</code> and <code class="literal">ga</code>, which had the collision and returned the same hash value by our hashing function. To properly evaluate the work of the hash table, we throw this collision as well, just to see that the collision is properly resolved. See the example code, as follows:</p><pre class="programlisting">ht = HashTable() 
    ht.put("good", "eggs") 
    ht.put("better", "ham") 
    ht.put("best", "spam") 
    ht.put("ad", "do not") 
    ht.put("ga", "collide") 

    for key in ("good", "better", "best", "worst", "ad", "ga"): 
        v = ht.get(key) 
        print(v) </pre><p>Running the preceding <span>code</span><a id="id325896270" class="indexterm"></a> returns the following:</p><pre class="programlisting"><span class="strong"><strong>% python hashtable.py</strong></span>

<span class="strong"><strong>eggs</strong></span>
<span class="strong"><strong>ham</strong></span>
<span class="strong"><strong>spam</strong></span>
<span class="strong"><strong>None</strong></span>
<span class="strong"><strong>do not</strong></span>
<span class="strong"><strong>collide </strong></span></pre><p>As you can see, looking up the <code class="literal">worst</code>key returns <code class="literal">None</code>, since the key does not exist. The <code class="literal">ad</code> and <code class="literal">ga</code>keys also return their corresponding values, showing that the collision between them is properly handled.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec51"></a>Using [] with the hash table</h3></div></div></div><p>Using the <code class="literal">put()</code> and <code class="literal">get()</code> methods doesn't look very convenient to use. However, we would have preferred to be able to treat our hash table as a list, as it would be easier to use. For example, we would like to be able to use <code class="literal">ht["good"]</code> instead of <code class="literal">ht.get("good")</code> for the retrieval of elements from the table.</p><p> </p><p> </p><p>This can be easily done with the special methods, <code class="literal">__setitem__()</code> and <code class="literal">__getitem__()</code>. See the following <span>code</span><a id="id325920325" class="indexterm"></a> for this:</p><pre class="programlisting">    def __setitem__(self, key, value): 
        self.put(key, value) 

    def __getitem__(self, key): 
        return self.get(key) </pre><p>Now, our test code would be like the following: </p><pre class="programlisting">    ht = HashTable() 
    ht["good"] = "eggs" 
    ht["better"] = "ham" 
    ht["best"] = "spam" 
    ht["ad"] = "do not" 
    ht["ga"] = "collide" 

    for key in ("good", "better", "best", "worst", "ad", "ga"): 
        v = ht[key] 
        print(v) 

    print("The number of elements is: {}".format(ht.count)) </pre><p>Notice that we also print the number of elements already stored in the hash table using the <code class="literal">count</code> variable.  </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec52"></a>Non-string keys</h3></div></div></div><p>In most cases in real-time applications, generally, we <span>need</span><a id="id325920358" class="indexterm"></a> to use strings for the keys. However, if necessary, you could use any other Python types. If you create your own class that you want to use as a key, you will need to override the special <code class="literal">__hash__()</code> function for that class, so that you get reliable hash values.</p><p>Note that you would still have to calculate the modulo (<code class="literal">%</code>) of the hash value and the size of the hash table to get the slot. That calculation should happen in the hash table and not in the key class since the table knows its own size (the key class should not know anything about the table that it belongs to).</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec53"></a>Growing a hash table</h3></div></div></div><p>In our example, we fixed the hash table <span>size</span><a id="id325920381" class="indexterm"></a> to 256. It is obvious that, when we add the elements to the hash table, we would begin to fill up the empty slots, and at some point, all of the slots would be filled up and the hash table will be full. To avoid such a situation, we can grow the size of the table when it is starting to get full. </p><p>To grow the size of the hash table, we compare the size and the count in the table. <code class="literal">size</code> is the total number of the slots and <code class="literal">count</code> denotes the number of slots that contains elements. So, if <code class="literal">count</code> is equal to <code class="literal">size</code>, that means we have filled up the table. The load factor of the hash table is generally used to expand the size of the table; that gives us an indication of how many available slots of the table have been used. The load factor of the hash table is computed by dividing the number of <span class="strong"><strong>used</strong></span> slots by the <span class="strong"><strong>total</strong></span> number of slots in the table. It is defined as follows:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/e0804bdb-018a-47d1-8725-f7eee41911f3.png" /></div><p>As the load factor value approaches 1, it means that the table is going to be filled, and we <span>need</span><a id="id325921144" class="indexterm"></a> to grow the size of the table. It is better to grow the size of the table before it gets almost full, as the retrieval of elements from the table becomes slow when the table fills up. A value of 0.75 for the load factor may be a good value to grow the size of the table.</p><p>The next question is how much we should increase the size of the table. One strategy would be to simply double the size of the table.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec54"></a>Open addressing</h3></div></div></div><p>The collision resolution mechanism we used in our example was linear probing, which is an example of an open addressing strategy. Linear probing is simple since we use a fixed number of slots. There are other open addressing strategies as well, however, they all share the idea that there is an array of slots. When we want to insert a key, we check whether the slot already has an item or not. If it does, we look for the next available slot.</p><p>If we have a <span>hash</span><a id="id325921163" class="indexterm"></a> table that contains 256 slots, then 256 is the maximum number of elements in that hash. Moreover, as the load factor increases, it will take longer to find the insertion point for the new element. </p><p><span>Because of these limitations, we may prefer to use a different strategy to resolve c</span>ollisions, such as chaining.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec55"></a>Chaining</h3></div></div></div><p>Chaining is another <span>method</span><a id="id325921561" class="indexterm"></a> to handle the problem of collision in <span>hash</span><a id="id325921568" class="indexterm"></a> tables. It solves this problem by allowing each slot in the hash table to store a reference to many items at the position of a collision. So, at the index of a collision, we are allowed to store many items in the hash table. Observe the following diagram—there is a collision for the strings, <span class="strong"><strong>hello world</strong></span> and <span class="strong"><strong>world hello</strong></span>. In the case of chaining, both items are allowed to store at the location of the <span class="strong"><strong>92</strong></span>hash value using a <span class="strong"><strong>list</strong></span>. Here is the example diagram to show collision resolution using chaining:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/93e5f1d9-40ae-4f73-ba12-ae6fb7123e3b.png" /></div><p> In chaining, the slots in the hash table are initialized with empty lists:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/1fda30a6-62b7-4f6c-b5b5-1af3dd188c9f.png" /></div><p>When an element is inserted, it will be appended to the list that corresponds to that element's hash value. That is, if you have two elements that both have a hash value of <code class="literal">1075</code>, both of these elements would be added to the list that exists in the <code class="literal">1075%256=51</code> slot of the hash table:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/08a2b3b4-7d72-4ee1-aa8d-9fa821a1d811.png" /></div><p>The preceding diagram shows a list of entries with hash value <code class="literal">51</code>.</p><p>Chaining then avoids conflict by allowing multiple elements to have the same <span>hash</span><a id="id325921642" class="indexterm"></a> value. Hence, there is no limit on the number of elements that can be stored in a hash table, whereas, in the case of linear probing, we had to fix the size of the table, which we need to later grow when the table is filled up, depending upon the load factor. Moreover, the hash table can hold more values than the number of available slots, since each slot holds a list that can grow.</p><p>However, there is a problem in chaining—it becomes inefficient when a list grows at a particular <span>hash</span><a id="id325921651" class="indexterm"></a> value location. As a particular slot has many items, searching them can get very slow since we have to do a linear search through the list until we find the element that has the key we want. This can slow down retrieval, which is not good, since hash tables are meant to be efficient. The following diagram demonstrates a linear search through list items until we find a match:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/58107627-9bee-44e0-877e-cfbe341f0bff.png" /></div><p>So, there is a problem of slow retrieval of items when a particular position in a hash table has many entries. This problem can be resolved using another data structure in place of using a list that can perform fast searching and retrieval. There is a nice choice of using <span class="strong"><strong>binary search trees</strong></span> (<span class="strong"><strong>BSTs</strong></span>), which <span>provide</span><a id="id325921681" class="indexterm"></a> fast retrieval, as we discussed in the previous chapter.</p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p>We could simply put an (initially empty) BST in each slot as shown in the following diagram:</p><div class="mediaobject"><img src="/graphics/9781788995573/graphics/b732657b-a058-44c9-89ae-d9f994c10d91.png" /></div><p>In the preceding diagram, the <code class="literal">51</code>slot holds a BST, which we use to store and retrieve the data items. But we would still have a potential problem—depending on the order in which the items were added to the BST, we could end up with a search tree that is as inefficient as a list. That is, each node in the tree has exactly one child. To avoid this, we would need to ensure that our BST is self-balancing.</p></div></div>