<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec13"></a>What's new in Java 8</h2></div></div><hr /></div><p>Up until Java 7, we only had object-oriented features in Java. Java 8 has added many new features. Some of <span>these</span><a id="id325162060" class="indexterm"></a> features are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Lambda expressions and functional interfaces</li><li style="list-style-type: disc">Default and static methods in interfaces</li><li style="list-style-type: disc">The <code class="literal">forEach()</code> method in iterable interfaces</li><li style="list-style-type: disc">The Java Stream API for bulk data operations on collections</li></ul></div><p>Don't worry if you find this intimidating. We will slowly uncover Java 8 as we progress throughout this book.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec6"></a>Lambda expressions and functional interfaces</h3></div></div></div><p>Lambda expressions are essential in functional programming. Lambda expressions are constructs that <span>exist</span><a id="id325448940" class="indexterm"></a> in a standalone fashion and not as a part of any class. One particular scenario where Lambda expressions can be used is while creating classes which consist of just a single method. Lambda expressions, in this case, help to be <span>an</span><a id="id325448949" class="indexterm"></a> alternative to anonymous classes (classes without names), which might not be feasible in certain situations. We will briefly look at two examples, side by side, of how we can convert a conventional Java snippet into a Lambda expression.</p><p>In the following code, we will assign a method to a variable called <code class="literal">blockofCodeA</code>. This is just what we are intending to solve with the means of Lambda expressions:</p><pre class="programlisting">blockofCodeA = public void demo(){ System.out.println("Hello World");
}</pre><p>The same piece of code can be written using Lambda expressions, as shown here:</p><pre class="programlisting">blockofCodeA = () -&gt; {                                 
    System.out.println("Hello World");
}</pre><p>Remove the name, return type, and the modifier, and simply add the arrow after the brackets. This becomes your Lambda expression.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec7"></a>Functional interfaces</h3></div></div></div><p>Functional interfaces contain one—and only one—abstract method. An abstract method is one which should have a body in the implementation class if the implementation <span>class</span><a id="id325450387" class="indexterm"></a> is not abstract. It can have any number of regular methods (methods which have a body in the implementation classes), but the prerequisite of a functional interface is that the number of abstract methods must be only one. These interfaces are used hand-in-hand with Lambda expressions.</p><p>In the following code block, the <code class="literal">demo</code> method is inside an <code class="literal">interface Greeting</code>. Therefore, this interface should only have one abstract method, which is the <code class="literal">demo</code> method. In order to instruct other users that this is a functional interface, we annotate this interface with the <code class="literal">@FunctionalInterface</code> annotation.</p><p>The type of <code class="literal">blockofCodeA</code> will be of this functional interface type. This annotation is optional:</p><pre class="programlisting">@FunctionalInterface
public interface Greeting {
        public void demo();
}</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec8"></a>Default and static methods in an interface</h3></div></div></div><p>Up until Java <span>1.7</span>, it was not <span>possible</span><a id="id325450466" class="indexterm"></a> to define a method inside an interface. Now, 1.8 introduces the default methods through which we can provide implementation for a <span>method</span><a id="id325450474" class="indexterm"></a> inside the interface. Let's see an example of this here:</p><pre class="programlisting">interface Phone{
 void dial();
 default void text() { 
 System.out.println("Texting a message");
 }
}</pre><p>Static methods in Java are those methods that can be invoked without creating an object of a particular class, provided that the static method is in that particular class. In Java 8, static methods can be defined inside an interface, as shown here:</p><pre class="programlisting">interface Phone {
    inx x;
    void changeRingtone();
    static void text() {
        System.out.println("Texting");
    }
}
public class PhoneDemo {
    public static void main(String[] args) {
        Phone.text();
    }
}</pre><p>You can invoke the <code class="literal">text()</code> method directly using the name of the interface.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec9"></a>The forEach method for a collection</h3></div></div></div><p>Starting with Java 8, we can invoke the <code class="literal">forEach</code> method on a collection and iterate through the <span>contents</span><a id="id325470661" class="indexterm"></a> of the collection. Let's compare the 7 and 8 versions of iterating over an array list of strings.</p><p>The following code, which is from Jave 7, fetches individual fruit names from the fruits list and prints it to the console:</p><pre class="programlisting">
    List&lt;String&gt; fruits = Arrays.asList("Apples", "Oranges", "Bananas",
        "Pears");
    for (int i = 0; i &lt; fruits.size(); i++) {
      System.out.println(fruits.get(i));
    }

</pre><p>A second alternative that you can use is as follows:</p><pre class="programlisting">for (String fruit : fruits ){
    System.out.println(fruit);
}</pre><p>The example shown here does the same thing in Java 8 using lambda expressions:</p><pre class="programlisting">fruits.forEach(i -&gt; System.out.println(i));</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec10"></a>Streams in Java 8</h3></div></div></div><p>As per the <span>Java</span><a id="id325470697" class="indexterm"></a> documentation's definition:</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Streams are a sequence of elements supporting sequential and parallel aggregate operations.</em></span></p></blockquote></div><p>Imagine a factory in which workers are standing with tools in their hands, and machine parts <span>keep</span><a id="id325470713" class="indexterm"></a> moving around so that the individual worker can do their part. Streams can be compared somewhat to such a scenario:</p><pre class="programlisting">List&lt;String&gt; fruits = Arrays.asList("Apples","Oranges","Bananas","Pears");
fruits.stream().forEach(fruit -&gt; System.out.println(fruit));</pre></div></div>