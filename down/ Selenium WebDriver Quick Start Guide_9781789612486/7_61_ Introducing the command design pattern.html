<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec63"></a>Introducing the command design pattern</h2></div></div><hr /></div><p>The command design pattern is a <span>behavioral</span><a id="id325162059" class="indexterm"></a> design pattern that involves four players, as in the following example:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Client</li><li style="list-style-type: disc">Invoker</li><li style="list-style-type: disc">Command </li><li style="list-style-type: disc">Receiver</li></ul></div><p>In very simple words, the receiver is the object on screen such as a textbox and button and the command is <code class="literal">sendKeys</code> and <code class="literal">click</code>. We encapsulate the command in an object and pass it to the receiver.</p><p>The actual command design pattern also supports an <code class="literal">Undo</code> operation, <span>but we will not consider the <code class="literal">Undo</code> operation here. By </span>using command objects, it becomes easier to build generic components that need to assign, delegate, or execute method calls without needing to know the class of the method or the method parameters. Using an <code class="literal">invoker</code> object allows command executions to be conveniently performed. Using this, we can also create different modes for commands that are handled by the <code class="literal">invoker</code> object without the client needing to be aware of the existence of the different modes involved.</p><p>The main players in a command design pattern are the Client, the invoker, the command, and the receiver. Let's understands all four from a <span>framework</span><a id="id325450387" class="indexterm"></a> perspective.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec53"></a>Client</h3></div></div></div><p>The client will do the <span>following</span><a id="id325450402" class="indexterm"></a> things:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Declare references of two abstract classes, such as <code class="literal">AActionKeyword</code> and <code class="literal">ACommand</code>. We will take a look at both of these abstract classes later in this chapter.</li><li style="list-style-type: disc">Create <code class="literal">invoker</code> objects.</li><li style="list-style-type: disc">Invoke the different commands such as <code class="literal">open</code>, <code class="literal">navigate</code>, and <code class="literal">enterText</code> using the <code class="literal">invoker</code> objects.</li></ul></div><p>The client will initially call <code class="literal">ReadExcelData</code> by passing it the browser name on which the execution has to be done. <code class="literal">ReadExcelData</code> will extract records from the Excel sheet, put those in a list of Hashmaps, and pass it back to the client. The client now reads the list of HashMaps, pulls out one Hashmap at a time, extracts the contents, and based on the action keyword executes the switch case logic, which we will look at later.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec54"></a>Invoker  </h3></div></div></div><p>There will be as many invokers as there are are components. Components can be textboxes, radio buttons, and so on. Each individual invoker will <span>create</span><a id="id325450488" class="indexterm"></a> a command object inside it. There will be customized methods inside each invoker, but inside each customized method, the execute method from the <code class="literal">ACommand</code> abstract class will be called. The individual invoker will call the overloaded execute methods from the <code class="literal">ACommand</code> abstract class.</p><p>The following code shows the <code class="literal">BrowserInvoker</code> class:</p><pre class="programlisting">public class BrowserInvoker {
  private ACommand aCommand = null;

  public BrowserInvoker(ACommand command) {
    this.aCommand = command;
  }

  public WebDriver open(List&lt;String&gt; browserName) {
    WebDriver driver = aCommand.execute(browserName);
    return driver;
  }
}</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec55"></a>Command </h3></div></div></div><p>The command, in our case, will be an abstract class that will have overloaded versions of the execute method. This has been done so that, if we want to <span>create</span><a id="id325524945" class="indexterm"></a> a concrete command class, we don't need to add code to all of the methods of the <code class="literal">ACommand</code> interface. The concrete command classes will have the <code class="literal">AActionKeyword</code> object, and there will be execute methods that are required for that particular operation. For example, if the operation is a <code class="literal">click</code> operation, then there will be just the usage of the no argument execute method.</p><p>Next comes the dummy class, <code class="literal">ACommand</code>, which has empty implementations.</p><p>The following code shows the <code class="literal">ACommand</code> abstract class:</p><pre class="programlisting">public abstract class ACommand {
  public void execute(String x) {
  }
  public void execute(WebDriver driver, String x) {
  }
  public void execute(WebElement element, String x) {
  }
  public WebDriver execute(List&lt;String&gt; x) {
    return null;
  }
  public WebDriver execute() {
    // TODO Auto-generated method stub
    return null;
  }
}</pre><p>Finally, the following code shows the concrete class which creates a new browser session. In the next chapter, the <span>no-argument execute method</span> will be <span>replaced</span><a id="id325524988" class="indexterm"></a> by a single argument method, which includes the browser name:</p><pre class="programlisting">public class NewBrowser extends ACommand {
  private AActionKeyword actionKeyword = null;
  static WebDriver driver;

  public NewBrowser(AActionKeyword actKeyword) {
    this.actionKeyword = actKeyword;
  }

  public WebDriver execute(List&lt;String&gt; browsers) {
    driver = actionKeyword.openBrowser(browsers);
    return driver;
  }

}</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec56"></a>Receiver</h3></div></div></div><p>The Receiver will be an <code class="literal">abstract</code> class called <code class="literal">AActionKeyword</code> that will contain empty method bodies that will be placeholders to perform the work by <span>invoking</span><a id="id325588675" class="indexterm"></a> Selenium <code class="literal">WebDriver</code> methods such as <code class="literal">click()</code>. Once again, we use an abstract class that has dummy implemented method bodies. Each individual concrete class will only implement the required methods.</p><p>We start with the <code class="literal">abstract</code> class with the unimplemented methods:</p><pre class="programlisting">public abstract class AActionKeyword extends TestBase {

  public AActionKeyword() throws IOException, FilloException {
    super();
  }
  public void clickElement(String x) {
  }
  public WebDriver navigate(WebDriver driver2, String url) {
    return null;
  }
  public WebDriver openBrowser(List&lt;String&gt; browsers) {
    return null;
  }
  public void sendKeys(WebElement elem, String textFill) {
  }

  public void selectValue() {
  }

}</pre><p>Then comes the <code class="literal">Concrete</code> class with the implementations. Here, we open a Firefox driver, but we can parameterize this method to accept a string argument for the browser name:</p><pre class="programlisting">public class OpenBrowser extends AActionKeyword {
        public WebDriver openBrowser() { WebDriver driver = new ChromeDriver(); return driver; }
}</pre><p>The following code is for the sample driver <span>script</span><a id="id325588713" class="indexterm"></a> with a single execution. This script will simply open a Firefox browser for now:</p><pre class="programlisting">public class MainClass {
  public static void main(String[] args) throws IOException, FilloException {
    WebDriver driver = null;
    List&lt;String&gt; browsers = new ArrayList&lt;String&gt;();
    browsers.add("chrome");
    System.setProperty("webdriver.chrome.driver",
        "src/main/resources/chromedriver.exe");
    AActionKeyword actKeyword = new OpenBrowser();
    ACommand command = new NewBrowser(actKeyword);
    BrowserInvoker invoker = new BrowserInvoker(command);
    driver = invoker.open(browsers);

  }
}</pre></div></div>