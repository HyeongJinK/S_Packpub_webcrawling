<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec21"></a>DOM traversal</h2></div></div><hr /></div><p>Now that we have seen the basic <span>definitions</span><a id="id325162060" class="indexterm"></a> of XPaths and CSS and also looked at what WebElements are, let's understand how we can use these to exploit the DOM. DOM traversal entails getting to the desired element with the help of either XPaths or CSS. It is possible to traverse the DOM in a forward and backward direction with XPaths but traversal through XPaths is slow compared to CSS. Traversal using CSS can only be done in the forward direction. In order to traverse the DOM, using either XPaths or CSS, we need to understand the <code class="literal">By</code> class.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec19"></a>Dissecting the By class</h3></div></div></div><p>The <code class="literal">By</code> class is an abstract class that has eight <span>static</span><a id="id325162935" class="indexterm"></a> methods and <span>eight</span><a id="id325437568" class="indexterm"></a> inner classes. Let's understand the structure of the <code class="literal">By</code> class.</p><p>The following code skeleton shows a fragment of the structure of the <code class="literal">By</code> class:</p><pre class="programlisting">public abstract class By {
           public static By id(String id);
public static By cssSelector(String css);
public static By name(String name);
public static By linkText(String text);
           public static By className(String className);
           public static By tagName(String tagName);
           public static By partialLinkText(String partialLinkText);
           public static By xpath(String xpath);
           public static class ById extends By {
                         WebElement findElement(By by);                                         
                         List &lt;WebElement&gt; findElements(By by);
   }
}</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note6"></a>Note</h3><p>Note: Inner classes are present corresponding to all the static methods. There are inner classes such as <code class="literal">ByName</code>, <code class="literal">ByTagName</code>, and so on.</p></div><p>Inner classes similar to <code class="literal">ById</code> exist for <code class="literal">name</code>, <code class="literal">linkText</code>, <code class="literal">xpath</code>, and so on. We will be using the two static methods <code class="literal">xpath</code> and <code class="literal">cssSelector</code> to design what are called customized <code class="literal">xpath</code> and <code class="literal">css</code>. Let's try to understand the various mechanisms to access the DOM elements. There are eight ways to access <code class="literal">WebElements</code> using the static methods in the <code class="literal"><span>By</span></code> class. We will just be covering access using static methods.</p><p>We will look at each of the eight methods individually, and then we will adopt a better approach using the relative (customized) XPath, which will cover each method internally:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal"><span>By</span>.id</code>: Uses the <code class="literal">id</code> attribute of the <span>element</span><a id="id325444797" class="indexterm"></a> to locate. For example, <code class="literal">By.id("userid").</code></li><li style="list-style-type: disc"><code class="literal">By.name</code>: Uses the <code class="literal">name</code> attribute of the element to locate. For example,<code class="literal">By.name("username").</code></li><li style="list-style-type: disc"><code class="literal">By.className</code>: Uses the <code class="literal">class</code> attribute of the <span>element</span><a id="id325447011" class="indexterm"></a> to locate. For example,<code class="literal">By.className("class1").</code></li><li style="list-style-type: disc"><code class="literal">By.linkText</code>: Uses the text of any anchor link to locate. For example, <code class="literal">By.linkText("Click here to Login").</code></li><li style="list-style-type: disc"><code class="literal">By.partialLinkText</code>: Uses the partial text of any anchor link to locate. For example, <code class="literal">By.partialLinkText("Login").</code><code class="literal"> </code></li><li style="list-style-type: disc"><code class="literal">By.xpath</code>: Uses the XPath of the element to locate. For example, <code class="literal">By.xpath("//*[text()='Login']").</code></li><li style="list-style-type: disc"><code class="literal">By.cssSelector</code>: Uses CSS selectors to locate. For example, <code class="literal">By.cssSelector(".ctrl-p").</code> </li><li style="list-style-type: disc"><code class="literal">By.tagName</code>: Uses tag names, such as <span><code class="literal">input</code>, <code class="literal">button</code>, <code class="literal">select</code>, and so on to locate</span>. For example,<code class="literal">By.tagName("input").</code></li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec20"></a>The two types of XPaths</h3></div></div></div><p>Let's now understand what absolute XPaths are and <span>how</span><a id="id325789660" class="indexterm"></a> they <span>differ</span><a id="id325917226" class="indexterm"></a> from relative (customized) XPaths:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">An absolute XPath is the entire path of the <code class="literal">WebElement</code> taken from the root node. For example, <code class="literal">html/body/div/a</code>.</li><li style="list-style-type: disc">A relative or customized XPath is one in which we use the following format. For example, if the <code class="literal">div</code> has an <code class="literal">id</code> of <code class="literal">ABC</code>, then the same absolute XPath will be<code class="literal"> //div[@id='ABC']/a.</code></li></ul></div><p>There is an apparent problem with the absolute type of XPath. If the DOM structure changes in the future (for example, if <code class="literal">div</code> is removed), then this path will undergo changes. </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec7"></a>Understanding customized XPaths</h4></div></div></div><p>The structure of a customized XPath is <span>given</span><a id="id325917275" class="indexterm"></a> as follows: <code class="literal">//*[@Attribute = 'Value'].</code></p><p>Here, <code class="literal">//</code> indicates that the entire DOM will be searched. We will <span>understand</span><a id="id325917293" class="indexterm"></a> some important XPaths with the help of <a class="ulink" href="http://www.freecrm.com" target="_blank">http://www.freecrm.com</a>:</p><p>Mentioned below are some of the commonly used strategies.</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span>Using the na</span>me attribute: <code class="literal">//*[@name='username']</code>. This searches the DOM for an element for which the name value is <code class="literal">username</code>. This is the login field on the landing page. </li><li style="list-style-type: disc">Using the name and type attributes: <code class="literal">//*[@type='password'][@name='password']</code>. In the DOM, the <code class="literal">password</code> field on the screen can be identified using just the <code class="literal">name</code> field. Just for the sake of demonstrating multiple attributes, I have taken the type attribute also. The need for multiple attributes arises when a unique element cannot be found using just one attribute.</li><li style="list-style-type: disc">Using the <code class="literal">contains</code> clause: <code class="literal">//*[contains(@type,'password')]</code>. This searches for an element whose type attribute contains the text <code class="literal">password</code>.</li><li style="list-style-type: disc">Using <code class="literal">starts-with</code>: <code class="literal">//*[starts-with(@name,'user')]</code>. This XPath will find the <code class="literal">username</code> field again but this time based on the starting text present in the <code class="literal">name</code> attribute.</li><li style="list-style-type: disc">Using the following node: <code class="literal">//*[@name='username']//</code> following the <code class="literal">::</code> input. This XPath searches for input tags which follow the username field. The boundary of this search is the container element within which the username lies. Since there is a password textbox and <strong class="userinput"><code>Login</code></strong> button following the username and the username, password, and <strong class="userinput"><code>Login</code></strong> button are inside a form, it identifies the password textbox and <strong class="userinput"><code>Login</code></strong> button.</li><li style="list-style-type: disc">Using the node: <code class="literal">//*[@value='Login']//</code> preceding the <code class="literal">::</code> input. This will provide the <code class="literal">username</code> and <code class="literal">password</code> textboxes.</li><li style="list-style-type: disc">Using the <code class="literal">onclick</code> attribute:<code class="literal"> //a[contains(@onclick,'html/entlnet/userLogin.html')]</code>. This is a very common case and is used when we have anchor tags without an ID or name and just an <code class="literal">onclick</code> attribute that has a JavaScript function called <code class="literal">onclick()={function content}</code>. In this case, the anchor tag can be structured as <code class="literal"><span>&lt;a</span><span> </span><span>onclick</span><span>=</span><span>'</span><span>window</span><span>.</span><span>open</span><span>(</span><span>"http://boot1/html/entlnet/userLogin.html")'</span><span>&gt;Login</span><span>&lt;/a&gt;.</span></code></li></ul></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Using the <code class="literal">ExtJs qtip</code> attribute: <code class="literal">//*[@*[local-name()='ext:qtip'][.='Account Number']]</code>. With the growing popularity of <code class="literal">ExtJs</code> for developing web apps, it is necessary to have something to identify common <code class="literal">ExtJs</code> attributes. One <code class="literal">ExtJs</code> attribute is <code class="literal">qtip</code>. Here we are finding an element with the <span><code class="literal">qtip</code><code class="literal">Account Number</code></span>.</li><li style="list-style-type: disc">Using <code class="literal">and</code>: <code class="literal">//input[@class='textboxes' and @name='firstName']</code>. In this case, an input element with the class attribute as <span><code class="literal">textboxes</code> and <code class="literal">name</code> as <code class="literal">firstName</code></span> will be located. Both <span>conditions</span><a id="id325948521" class="indexterm"></a> in <code class="literal">and</code> must be satisfied.</li><li style="list-style-type: disc">Using <code class="literal">or</code>: <code class="literal">//input[@class='textboxes' or @name='firstName']</code>. In this case, an input <span>element with the class attribute</span> as <span><code class="literal">textboxes</code></span> or <span>name</span><a id="id325948551" class="indexterm"></a> as <span><code class="literal">firstName</code></span> will be located. Either of the conditions in <code class="literal">and</code> must be satisfied.</li></ul></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec21"></a>Customized CSS</h3></div></div></div><p>Now that we have <span>seen</span><a id="id325948577" class="indexterm"></a> the customized XPath, it's <span>time</span><a id="id325948583" class="indexterm"></a> to look at customized CSS. Remember, CSS can be used only for forward traversal.</p><p>The following are some customized CSS examples that one can use while coding the program:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Using the name attribute: <code class="literal">input[name='username']</code>. This CSS identifies the username. Notice there are no <code class="literal">'//'</code>s.</li><li style="list-style-type: disc">Using the name and type attribute: <code class="literal">input[type='password'][name='password']</code>. This will identify the <code class="literal">password</code> textbox.</li><li style="list-style-type: disc">Using the <code class="literal">ID</code> and <code class="literal">class: form[id='loginForm'],form[id='loginForm'][class='navbar-form']</code>. These two CSS selectors will identify the login form.</li><li style="list-style-type: disc">Using the <code class="literal">'contains'</code> clause: <code class="literal">form[id*='Form']</code>. This will identify the form since the <code class="literal">ID</code> of the form contains the text <code class="literal">Form</code>. Contains is indicated by <code class="literal">'*'</code> in CSS.</li><li style="list-style-type: disc">Using the <code class="literal">'starts-with'</code> clause: <code class="literal">form[id^='login']</code>. This will identify the form since the form <code class="literal">ID</code> starts with the text <code class="literal">'login'</code>. <code class="literal">starts-with</code> is indicated by <code class="literal">'^'</code> in CSS.</li><li style="list-style-type: disc">Using the <code class="literal">'ends-with'</code> clause: <code class="literal">form[id$='Form']</code>. This will identify the form since the form <code class="literal">ID</code> ends with the text <code class="literal">'Form'</code>. <code class="literal">ends-wit</code>h is indicated by <code class="literal">'$'</code> in CSS. </li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec22"></a>An example traversal</h3></div></div></div><p>The element retrieval and traversal can be <span>done</span><a id="id325959723" class="indexterm"></a> quite easily by what is known as a browsers console. In all the three browsers, the console can be invoked by pressing the <span class="emphasis"><em>F12</em></span> key on the keyboard. In Chrome, the <strong class="userinput"><code>Elements</code></strong> tab will help in finding the XPath. One can traverse back and forth in the DOM using <code class="literal">'/..'</code> and (<code class="literal">'//'</code> or <code class="literal">'/'</code>). Let's see what the Chrome console looks like.</p><p>The following snapshot shows the Chrome console with the username field highlighted because we tried to find an element through it's XPath . In order to search for any element, just press <span class="emphasis"><em>Ctrl </em></span>+ <span class="emphasis"><em>F</em></span> on the console. A search box opens where you can type the <code class="literal">XPath</code>:</p><div class="mediaobject"><img src="/graphics/9781789612486/graphics/d0a9e279-4eba-462d-bb84-6e9ad02379b8.png" /></div><p>A similar console in Internet <span>Explorer</span><a id="id325960045" class="indexterm"></a> is called <span class="strong"><strong>Developer Options</strong></span> and in <span>Firefox</span><a id="id325960056" class="indexterm"></a> it is called <span class="strong"><strong>Firepath</strong></span>. In Firefox, one must remember to first add the firebug plugin from the Firefox plugins page (go to the <strong class="userinput"><code>Tools</code></strong> | <strong class="userinput"><code>Add-ons</code></strong> menu and then select <strong class="userinput"><code>Add-ons</code></strong> from the left pane). Only then can Firepath be accessed using the <span class="emphasis"><em>F12</em></span> key.</p><p>Apart from the consoles, which come built-in with the browsers, there are a few extensions such as XPath helper in Chrome and MRI in Internet Explorer. MRI is a bookMarklet for IE. One <span>can</span><a id="id325960082" class="indexterm"></a> get it from <a class="ulink" href="http://westciv.com/mri/" target="_blank">http://westciv.com/mri/</a> as a free installation. All the <span>instructions</span><a id="id325966104" class="indexterm"></a> are available on this website.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note7"></a>Note</h3><p>MRI will not work on popup windows. In the case of popups, the console is a better option.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec23"></a>Understanding the text() methods</h3></div></div></div><p>One very useful method in finding XPath is the <code class="literal">text()</code> method. When we <span>need</span><a id="id325966128" class="indexterm"></a> to supply some text at runtime, say for example, from an Excel file, then we can <span>utilize</span><a id="id325966134" class="indexterm"></a> the <code class="literal">text()</code> method in the following manner:</p><pre class="programlisting">public class DynamicText {
  public static void main(String[] args) {
    System.setProperty("webdriver.chrome.driver",
        "C:\\SeleniumWD\\src\\main\\resources\\chromedriver.exe");
    WebDriver driver = new ChromeDriver();
    driver.manage().timeouts().implicitlyWait(30, TimeUnit.SECONDS);
    driver.get("http://www.google.com");
    String variableData = "Google";
    String dynamicXpath = "//*[text()='" + variableData + "']";
    List&lt;WebElement&gt; elem = 
    driver.findElements(By.xpath(dynamicXpath));
    System.out.println("no of elements: " + elem.size());

  }
} 

The program above prints
<span class="strong"><strong>no of elements: 3</strong></span></pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec24"></a>Finding elements within the container element</h3></div></div></div><p>On the <a class="ulink" href="http://www.freecrm.com" target="_blank">http://www.freecrm.com</a> login page, the <span>structure</span><a id="id325968760" class="indexterm"></a> is such that the username, password, and the <strong class="userinput"><code>login</code></strong> button are contained inside the form with <code class="literal">id=xyz</code>. In such a situation, the child elements can be accessed using <code class="literal">findElements</code> on the container or parent element.</p><p>The following code displays the number of input elements in the form:</p><pre class="programlisting">public class DynamicText1 {
 public static void main(String[] args) {
     System.setProperty("webdriver.chrome.driver",
     "C:\\SeleniumWD\\src\\main\\resources\\chromedriver.exe");
     WebDriver driver = new ChromeDriver();
     driver.manage().timeouts().implicitlyWait(30, TimeUnit.SECONDS);
     driver.get("http://www.freecrm.com");
     String dynamicXpath = "//*[@id='loginForm']";
     List&lt;WebElement&gt; elem =    
    driver.findElements(By.xpath(dynamicXpath));
     List&lt;WebElement&gt; elem1 = 
     elem.get(0).findElements(By.tagName("input"));
     System.out.println("no of elements: " + elem1.size());
    }
}

The output displayed in console is shown below
<span class="strong"><strong>no of elements: 3</strong></span></pre><p>This is a very simple program which has hardcoded values. To remove hardcoding from a program, we require a framework, which we will discuss in <span>forthcoming</span><a id="id325968792" class="indexterm"></a> chapters. </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec25"></a>Best practice</h3></div></div></div><p>A best practice while coding Selenium is <span>always</span><a id="id325968807" class="indexterm"></a> to follow a design pattern. We will go over design patterns in a subsequent chapter.</p><p>We should always have modular code delinked from each other so that when one module changes, there is no impact on other modules.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec26"></a>Extracting WebElements dynamically using tagName</h3></div></div></div><p>Now that we have seen how to <span>create</span><a id="id325968824" class="indexterm"></a> relative (customized) XPaths, it's time to see how to retrieve <code class="literal">WebElements</code> programmatically <span>using</span><a id="id325983548" class="indexterm"></a> Java lists. The best way to understand this is through an example. Suppose we want to find all the input textboxes on the login page of <a class="ulink" href="http://www.freecrm.com" target="_blank">http://www.freecrm.com</a>. We will make use of the <code class="literal">findElements</code> method. Remember, the <code class="literal">findElements</code> method is in the <code class="literal">SearchContext</code> interface.</p><p>Since the WebDriver interface is a child interface of <code class="literal">SearchContext</code>, it inherits the <code class="literal">findElements</code> method and we can invoke this method on the reference variable of WebDriver. In conjunction with <code class="literal">findElements</code>, we will also make use of the static method, <code class="literal">tagName</code> , of the <code class="literal">By</code> class.</p><p>The following code makes <span>efficient</span><a id="id325983591" class="indexterm"></a> use of the list <span>interface</span><a id="id325983600" class="indexterm"></a> in Java (present in the <code class="literal">Java.Util</code> package): </p><pre class="programlisting">public class URLTest {
 public static void main(String[] args) {
     System.setProperty("webdriver.chrome.driver",
         "C:\\SeleniumWD\\src\\main\\resources\\chromedriver.exe");
     WebDriver driver = new ChromeDriver();
     driver.get("http://www.freecrm.com");
     List&lt;WebElement&gt; inputBoxes = 
     driver.findElements(By.tagName("input"));
     System.out.println("No of inputBoxes: " + inputBoxes.size());
 }
}

Output from this program:
<span class="strong"><strong>No of inputBoxes: 3</strong></span></pre><p>The two textboxes for <code class="literal">UserName</code> and <code class="literal">Password</code> and the <strong class="userinput"><code>Login</code></strong><span>button</span><a id="id325991242" class="indexterm"></a> are treated as input tags. The <code class="literal">tagName</code> static method is an extremely useful method and you can use this method for almost any element on any web page.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec8"></a>Properties file for WebElements</h4></div></div></div><p>We have explored <code class="literal">WebElement</code>s to a <span>large</span><a id="id325991265" class="indexterm"></a> extent. Now we will actually start preparing for the hybrid framework (we will look at this in a later chapter) by creating a <code class="literal">WebElement</code> store. This store will be created in a file known as the properties file, which always has the <code class="literal">.properties</code> extension. An example entry in the properties file can be:</p><p><code class="literal">USERNAME=//*[@name='username'] </code></p><p>Entries in the properties file consist of key value pairs. Here, <code class="literal">username</code> i<span>s the ke</span>y and <code class="literal">'//*[@name='username'] '</code> is the value. </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip8"></a>Note</h3><p>The key in a properties file should always be unique. The value part can have duplicate values.</p></div><p>These values should be retrieved by the code once the key is supplied. For this purpose, we will be writing a retrieval program in a subsequent chapter.</p><p>The next question that might come up to mind is: we have created a properties file and will be writing retrieval logic for this, but on what basis should the retrieval logic be invoked? For this purpose, we will have to create test scripts. The test scripts can be created either in an Excel or in a database. We have APIs such as Apache POI and Fillo available as open source. Fillo gives us certain advantages over POI. Fillo treats an Excel tab as a database table and regular SQL queries, such as SELECT, UPDATE, and DELETE, can be triggered on the Excel tab data. Each row is equivalent to the row in a DB table while a column is equivalent to a database field. We will gradually uncover the power of Fillo as we move <span>ahead</span><a id="id325993664" class="indexterm"></a> but the curtain raiser will be in <a class="link" href="#" linkend="ch03">Chapter 3</a>, <span class="emphasis"><em>Basic Selenium Commands and Their Usage in Building a Framework</em></span>. As of the current release of Fillo, joins are not possible but we will not require complex joins for our framework.</p><p>Let's take a small diversion here to see what the prerequisites for automating mobile applications are.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec27"></a>Prerequisites for automating mobile applications</h3></div></div></div><p>For automating mobile applications, there is <span>specific</span><a id="id325993690" class="indexterm"></a> software that <span>needs</span><a id="id325993699" class="indexterm"></a> to be downloaded. The following is a list of all the steps needed to set up the Appium server on <span>your</span><a id="id325993707" class="indexterm"></a> machine:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><span class="strong"><strong><span>Download the Java Development K</span>it</strong></span> (<span class="strong"><strong>JDK</strong></span>) (<a class="ulink" href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a>).</li><li><span>Set the Java environment</span> variable path so that Java <span>commands</span><a id="id326068055" class="indexterm"></a> can be executed from anywhere on the system.</li><li><span>Download the Android SDK/AD</span>B (<a class="ulink" href="https://developer.android.com/studio/" target="_blank">https://developer.android.com/studio/</a>).</li><li><span>Utilize the Android SDK packages</span> from SDK Manager in the downloaded <code class="literal">Android SDK</code> folder</li><li>Se<span>t the Android Environ</span>ment variables so that commands can be executed anywhere on the system.</li><li>Download and <span>configure</span><a id="id326068094" class="indexterm"></a> nodejs (<a class="ulink" href="https://nodejs.org/en/download/" target="_blank">https://nodejs.org/en/download/</a>). Take the LTS for whichever OS is applicable.</li><li>Download <span>the</span><a id="id326068110" class="indexterm"></a> Microsoft .net framework (<a class="ulink" href="https://www.microsoft.com/en-in/download/details.aspx?id=30653" target="_blank">https://www.microsoft.com/en-in/download/details.aspx?id=30653</a>).</li><li>Download <span>the</span><a id="id326068125" class="indexterm"></a> Appium server (<a class="ulink" href="http://appium.io/" target="_blank">http://appium.io/</a>).</li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec28"></a>XPaths for mobile applications</h3></div></div></div><p>Let's first <span>understand</span><a id="id326068145" class="indexterm"></a> the various <span>types</span><a id="id326068153" class="indexterm"></a> of mobile applications. There are three types of mobile applications:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Web application</strong></span>: Works only in the <span>mobile</span><a id="id326074554" class="indexterm"></a> browser (for example, a personal blog site)</li><li style="list-style-type: disc"><span class="strong"><strong>Native application</strong></span>: Works <span>only</span><a id="id326074568" class="indexterm"></a> as a standalone app (for example, a calculator)</li><li style="list-style-type: disc"><span class="strong"><strong>Hybrid application</strong></span>: Works on a mobile <span>browser</span><a id="id326074582" class="indexterm"></a> or standalone (for example, Gmail, Flipkart, and so on); it can also be defined as an application that contains a native view and web view</li></ul></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec9"></a>Finding XPaths for mobile browser applications</h4></div></div></div><p>We have a variety of ways in <span>which</span><a id="id326074597" class="indexterm"></a> we can find the <span>locators</span><a id="id326074605" class="indexterm"></a> of mobile elements. Let's explore some of them.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch02lvl4sec0"></a>Connecting the actual mobile device</h5></div></div></div><p>Perform the following steps to find <span>locators</span><a id="id326098310" class="indexterm"></a> using an actual device connected to the computer:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Type <code class="literal">chrome://inspect/#devices</code> and ensure that <strong class="userinput"><code>Discover USB devices</code></strong> is checked.</li><li>Type <code class="literal">URL</code> in the URL textbox and click <strong class="userinput"><code>Open</code></strong>. The website now opens in the connected device.</li><li>Click <strong class="userinput"><code>Inspect</code></strong> in Chrome on the desktop. A new instance of Chrome Developer tools opens in the desktop.</li><li>We can interact with mobile web elements using DevTools.</li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch02lvl4sec1"></a>How to use Screencast</h5></div></div></div><p>Follow the steps to use <span>screencast</span><a id="id326098355" class="indexterm"></a> in DevTools:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Perform the preceding steps 1-4.</li><li>Click on the screencast icon in DevTools.</li></ol></div><p>A window opens in which one can see the URL opened in the mobile device. You can interact with this window using DevTools.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch02lvl4sec2"></a>Appium Inspector window</h5></div></div></div><p>To use the <strong class="userinput"><code>Appium Inspector</code></strong> window, perform <span>following</span><a id="id326098390" class="indexterm"></a> the <span>steps</span><a id="id326098398" class="indexterm"></a> and find the desired locator:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li> Start the Appium server.</li><li> In the downloaded <code class="literal">Android SDK</code> folder, open the <span class="strong"><strong>Android AVD</strong></span> (<span class="strong"><strong>Android Virtual Device</strong></span>) Manager.</li><li>Start the emulator inside the AVD.</li><li>Click the magnifying glass icon on the Android server GUI. This opens up the <strong class="userinput"><code>Android Inspector</code></strong>.</li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch02lvl4sec3"></a>How to use UIAutomatorViewer</h5></div></div></div><p>Perform <span>the</span><a id="id326123222" class="indexterm"></a> following <span>steps</span><a id="id326123230" class="indexterm"></a> to use <strong class="userinput"><code>UIAutomatorViewer</code></strong> for <span>capturing</span><a id="id326123242" class="indexterm"></a> the locator:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Download Android SDK from <a class="ulink" href="https://android-sdk.en.lo4d.com/" target="_blank">https://android-sdk.en.lo4d.com/.</a><a class="ulink" href="https://android-sdk.en.lo4d.com/" target="_blank">https://android-sdk.en.lo4d.com/</a></li><li>Once downloaded, go to <code class="literal">Andriodsdk/tools</code> and double-click <code class="literal">uiautomatorviewer.bat.</code><a class="ulink" href="https://android-sdk.en.lo4d.com/" target="_blank">https://android-sdk.en.lo4d.com/</a></li><li>Click on the device screenshot button, second from the left. The device image gets displayed in the left pane.</li><li>Click on any element and the corresponding information is displayed in the right pane.</li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch02lvl4sec4"></a>Mobile locators</h5></div></div></div><p>The main locators used in mobile <span>automation</span><a id="id326123285" class="indexterm"></a><span>are as follows</span>:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">Accessibility id</code>: Unique identifier for a UI element.</li><li style="list-style-type: disc"><code class="literal">TagName</code>: The same as WebDriver. This tells us what the tag is (input, select, and so on).</li><li style="list-style-type: disc"><code class="literal">Class Name</code>: <span>Identifies b</span>y the <code class="literal">classname</code> attribute.</li><li style="list-style-type: disc"><code class="literal">Xpath</code>: Identifies by the absolute or customized XPath. </li><li style="list-style-type: disc"><code class="literal">ID</code>: Identifies by the ID of the element.</li></ul></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec10"></a>What is a WebView?</h4></div></div></div><p>The browser view that is embedded <span>inside</span><a id="id326123337" class="indexterm"></a> a native app is called a W<span>eb View</span>. To view the XPath of a webview in a hybrid app, we make use of the <strong class="userinput"><code>Selendroid Inspector</code></strong>. To use the <strong class="userinput"><code>Selendroid Inspector</code></strong>, perform the following the steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Open the <strong class="userinput"><code>Appium Server</code></strong> GUI and put the local APK file path in the application path.</li><li>Select the <strong class="userinput"><code>Automation Name</code></strong> as <code class="literal">Selendroid</code> and the other mandatory parameters.</li><li>Start the server after selecting <strong class="userinput"><code>Pre-Launch Application</code></strong>.</li><li>Navigate to <code class="literal">http://localhost:8080/inspector</code> and start using the <strong class="userinput"><code>Selendroid Inspector</code></strong>.</li></ol></div></div></div></div>