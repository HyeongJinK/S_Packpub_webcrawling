<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec60"></a>Basic Camera Types</h2></div></div><hr /></div><p>In this chapter, we will discuss the following two <span>camera</span><a id="id325357458" class="indexterm"></a> types:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Orbiting camera</li><li style="list-style-type: disc">Tracking camera</li></ul></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec77"></a>Orbiting Camera</h3></div></div></div><p>So far, we've learned how to <span>generate</span><a id="id325358940" class="indexterm"></a> rotations and translations in either world or camera coordinates. In both cases, however, we are always generating the rotations around the center of the world. This may be ideal when we're orbiting around a 3D object, such as our car model. In that example, you put the object at the center of the world, and then examine the object at different angles (rotation); after that, you can move away (translation) to see the result. We will refer to this type of <span>camera</span><a id="id325358949" class="indexterm"></a> as an <span class="strong"><strong>orbiting camera</strong></span>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec78"></a>Tracking Camera</h3></div></div></div><p>If we return to the example of the first-person shooting game, we need to have a camera that can look up when we want to check whether there are enemies above us. We should also be able to look left and right (rotations) and then move in the direction in which our <span>camera</span><a id="id325358966" class="indexterm"></a> is pointing (translation). This camera <span>type</span><a id="id325401404" class="indexterm"></a> can be designated as a <span class="strong"><strong>first-person</strong></span> camera. This same <span>type</span><a id="id325401415" class="indexterm"></a> is used when the game follows the main character. Therefore, it is generally known as a <span class="strong"><strong>tracking camera</strong></span>.</p><p>To implement first-person cameras, we need to set up the rotations on the camera axis instead of using the world origin.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec21"></a>Rotating the Camera Around Its Location</h4></div></div></div><p>When multiplying matrices, the <span>order</span><a id="id325401526" class="indexterm"></a> in which we multiply them is relevant. Say, for instance, we have two 4x4 matrices. Let <code class="literal">R</code> be the first matrix and let's assume that this matrix encodes pure rotation; let <code class="literal">T</code> be the second matrix and let's assume that <code class="literal">T</code> encodes pure translation. Now:</p><pre class="programlisting"><div class="mediaobject"><img src="/graphics/9781788629690/graphics/64a25db5-e7dc-4dad-88b2-caf307cc9999.png" /></div></pre><p>In other words, the order of the operations affects the result. It is not the same to rotate around the origin and then translate away from it (orbiting camera), as compared to translating the origin and then rotating around it (tracking camera)! Your success depends on understanding this critical difference.</p><p>In order to set the location of the camera as the center for rotations, we need to invert the order in which operations are called. This is equivalent to converting from an orbiting camera to a tracking camera.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec22"></a>Translating the Camera in the Line of Sight</h4></div></div></div><p>With an orbiting camera, the camera will always look toward the center of the world. Therefore, we will always use the z-axis to move to and from the <span>object</span><a id="id325631870" class="indexterm"></a> we are examining. However, with a tracking camera, since the rotation occurs at the camera location, we can end up looking to any position in the world (which is ideal if you want to move around and explore it). Thus, we need to know the direction in which the camera is pointing in world coordinates (camera axis). We will see how to obtain this next.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec23"></a>The Camera Model</h4></div></div></div><p>Just like its counterpart, the Model-View matrix, the Camera matrix encodes information about the camera orientation. As we can see in the <span>following</span><a id="id325631885" class="indexterm"></a> diagram, the upper-left 3x3 matrix corresponds to the camera axes:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">The first column corresponds to the x-axis of the camera. We will call it <code class="literal">RightVector</code>.</li><li style="list-style-type: disc">The second column is the y-axis of the camera. This will be <code class="literal">UpVector</code>.</li><li style="list-style-type: disc">The third column determines the vector in which the camera can move back and forth. This is the z-axis of the camera and we will call it <code class="literal">CameraAxis</code>.</li></ul></div><p>Because the Camera matrix is the inverse of the Model-View matrix, the upper-left 3x3 rotation matrix contained in the Camera matrix gives us the orientation of the camera axes in world space. This is a plus, because it means that we can tell the orientation of our camera in world space just by looking at the columns of this 3x3 rotation matrix (and we now know what each column means):</p><div class="mediaobject"><img src="/graphics/9781788629690/graphics/154c22ea-b526-4f0c-9056-b73bcbefe666.png" /></div><p>In the following section, we will play with orbiting and tracking cameras to see how we can change the camera position using mouse gestures and sliders. In addition, we will look at a graphical representation of the resulting Model-View matrix. In this exercise, we will integrate both rotations and translations and we will see how they behave under the two basic types of cameras we are studying.</p></div></div></div>