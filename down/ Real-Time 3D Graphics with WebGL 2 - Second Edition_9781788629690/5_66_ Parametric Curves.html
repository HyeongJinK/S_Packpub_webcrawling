<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec73"></a>Parametric Curves</h2></div></div><hr /></div><p>There are many situations where we don't know the exact position of an object at a given time, but we do know an equation that describes its movement. These <span>equations</span><a id="id325358908" class="indexterm"></a> are known as <span class="strong"><strong>parametric curves</strong></span>; they are parametric because the position depends on one parameter—for example, the time.</p><p>There are many <span>examples</span><a id="id325358928" class="indexterm"></a> of parametric curves. For example, a projectile shot in a game, a car going downhill, or a bouncing ball. In each case, there are equations that describe the motion of these objects under ideal conditions. The following diagram shows the parametric equation that describes the free-fall motion:</p><div class="mediaobject"><img src="/graphics/9781788629690/graphics/a47d9584-dbc6-4e36-9b59-3432a93fc843.png" /></div><pre class="programlisting"><div class="mediaobject"><img src="/graphics/9781788629690/graphics/4b1f883a-4c8b-4c0d-848c-90104d749edc.png" /></div></pre><p>Where:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal"><div class="mediaobject"><img src="/graphics/9781788629690/graphics/80f20477-b520-4a4a-bfdc-db66e15ea8a2.png" /></div></code>: Gravity at <code class="literal"><div class="mediaobject"><img src="/graphics/9781788629690/graphics/4534047b-9a49-4936-ac96-b152d9759cf8.png" /></div></code></li><li style="list-style-type: disc"><code class="literal"><div class="mediaobject"><img src="/graphics/9781788629690/graphics/10451b8e-8376-4527-98d7-8d44293070ce.png" /></div></code>: Initial velocity</li><li style="list-style-type: disc"><code class="literal"><div class="mediaobject"><img src="/graphics/9781788629690/graphics/fdf48723-4ec4-475b-8ada-ed80d66a2d29.png" /></div></code>: Initial Position</li><li style="list-style-type: disc"><code class="literal"><div class="mediaobject"><img src="/graphics/9781788629690/graphics/b3c25379-50d9-47a8-ba2f-c5c17dfc3447.png" /></div></code>: Time</li><li style="list-style-type: disc"><code class="literal"><div class="mediaobject"><img src="/graphics/9781788629690/graphics/b276f52a-9187-4cfd-9ac1-fd7af5e5460d.png" /></div></code>: Position</li></ul></div><p>We are going to use parametric curves to animate objects in a WebGL scene. In this example, we will model a set of bouncing balls. The complete source code for this exercise can be found in <code class="literal">ch05_03_bouncing-balls.html</code>.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec95"></a>Initialization Steps</h3></div></div></div><p>We will create a global <span>variable</span><a id="id325617381" class="indexterm"></a> that will store the (simulation) time. We will also create the global variables that regulate the animation:</p><pre class="programlisting">let
gl, scene, program, camera, transforms,
elapsedTime, initialTime,
fixedLight = false,
balls = [],
sceneTime = 0,
animationRate = 15,
gravity = 9.8,
ballsCount = 50;</pre><p>The <code class="literal">load</code> function is updated to load a bunch of balls using the same geometry (same JSON file), but we are adding it several times to the <code class="literal">scene</code> object. The code looks like this:</p><pre class="programlisting">function load() {
  scene.add(new Floor(80, 2));
for (let i = 0; i &lt; ballsCount; i++) {
    balls.push(new BouncingBall());
scene.load('/common/models/geometries/ball.json', `ball${i}`);
}
}</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip61"></a>Note</h3><p><strong class="userinput"><code>ES6 Template Literals</code></strong><span class="strong"><strong></strong></span> If you're not familiar with the <code class="literal">`ball${i}`</code> syntax, it's equivalent to <code class="literal">'ball' + i</code>. Instead of concatenating strings, we can leverage template literals in ES6 for dynamic string values. For more information, check out <a class="ulink" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals" target="_blank">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals</a>.</p></div><p>Notice that we’ve also populated an array named <code class="literal">balls[]</code>. We do this so that we can store the ball positions every time the global time changes. We will talk in depth about the bouncing ball simulation in the next <span class="emphasis"><em>Time for action</em></span> section. For the moment, it’s worth mentioning that it is on the <code class="literal">load</code> function that we load the geometry and initialize the ball array with the initial ball positions.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec96"></a>Setting up the Animation Timer</h3></div></div></div><p>The <code class="literal">render</code> and <code class="literal">onFrame</code> functions look <span>exactly</span><a id="id325638060" class="indexterm"></a> the same as in the previous examples:</p><pre class="programlisting">function onFrame() {
  elapsedTime = (new Date).getTime() - initialTime;
if (elapsedTime &lt; animationRate) return;

let steps = Math.floor(elapsedTime / animationRate);
while (steps &gt; 0) {
animate();
steps -= 1;
}

  initialTime = (new Date).getTime();
}

function render() {
  initialTime = (new Date).getTime();
setInterval(onFrame, animationRate / 1000);
}</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec97"></a>Running the Animation</h3></div></div></div><p>The <code class="literal">animate</code> function passes the <code class="literal">sceneTime</code> variable to the <code class="literal">update</code> method of <span>every</span><a id="id325643382" class="indexterm"></a> ball in the ball array. Then, <code class="literal">sceneTime</code> updates by a fixed amount. The code looks like this:</p><pre class="programlisting">function animate() {
  balls.forEach(ball =&gt; ball.update(sceneTime));
sceneTime += 33 / 1000;
draw();
}</pre><p>Again, parametric curves are very helpful because they don’t require us to know the location of every object that we want to move beforehand. We just apply a parametric equation that gives us the location based on the current time. This occurs for every ball inside its update method.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec98"></a>Drawing Each Ball in Its Current Position</h3></div></div></div><p>In the <code class="literal">draw</code> function, we use a <span>matrix</span><a id="id325662108" class="indexterm"></a> stack to save the state of the Model-View matrix before applying a local transformation for each one of the balls. The code looks like this:</p><pre class="programlisting">function draw() {
  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

<span class="strong"><strong>transforms.updatePerspective();
</strong></span>
try {
    gl.uniform1i(program.uUpdateLight, fixedLight);

scene.traverse(object =&gt; {
<span class="strong"><strong>transforms.calculateModelView();
transforms.push();

if (~object.alias.indexOf('ball')) {</strong></span>
<span class="strong"><strong>const index = parseInt(object.alias.substring(4, 8));
const ballTransform = transforms.modelViewMatrix;
mat4.translate(ballTransform, ballTransform, balls[index].position);
object.diffuse = balls[index].color;
}</strong></span>

<span class="strong"><strong> transforms.setMatrixUniforms();
transforms.pop();
</strong></span>
gl.uniform4fv(program.uMaterialDiffuse, object.diffuse);
gl.uniform4fv(program.uMaterialSpecular, object.specular);
gl.uniform4fv(program.uMaterialAmbient, object.ambient);

gl.uniform1i(program.uWireframe, object.wireframe);
gl.uniform1i(program.uPerVertexColor, object.perVertexColor);

// Bind
gl.bindVertexArray(object.vao);
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, object.ibo);

if (object.wireframe) {
        gl.drawElements(gl.LINES, object.indices.length, gl.UNSIGNED_SHORT, 
         0);
}
else {
        gl.drawElements(gl.TRIANGLES, object.indices.length, 
         gl.UNSIGNED_SHORT, 0);
}

// Clean
gl.bindVertexArray(null);
gl.bindBuffer(gl.ARRAY_BUFFER, null);
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
});
}
catch (error) {
    console.error(error);
}
}</pre><p>The trick here is to use the number that makes up part of the ball alias to look up the respective ball position in the <code class="literal">balls</code> array. For example, if the ball being rendered has the <code class="literal">ball32</code> alias, then this code will look for the current position of the ball whose index is <code class="literal">32</code> in the <code class="literal">balls</code> array. This one-to-one correspondence <span>between</span><a id="id325662155" class="indexterm"></a> the <code class="literal">ball</code> alias and its location in the ball array was established in the <code class="literal">load</code> function.</p><p>In the following <span class="emphasis"><em>Time for Action</em></span> section, we will see the bouncing balls animation in action. We will also discuss some of the code detail.</p></div></div>