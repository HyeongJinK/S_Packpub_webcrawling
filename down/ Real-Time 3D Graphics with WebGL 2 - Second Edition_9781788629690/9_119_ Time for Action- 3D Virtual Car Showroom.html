<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec122"></a>Time for Action: 3D Virtual Car Showroom</h2></div></div><hr /></div><p>Leveraging the WebGL skills and <span>infrastructure</span><a id="id325357458" class="indexterm"></a> code we have developed thus far, we will create an application that visualizes different 3D car models. The final result will look like this:</p><div class="mediaobject"><img src="/graphics/9781788629690/graphics/6abf5799-8adb-47f9-a81a-9c0a89822c4c.png" /></div><p>First, we'll start by defining the <span class="strong"><strong>graphical user interface (GUI</strong></span>) of our application. Then, we'll add WebGL support by creating a <code class="literal">canvas</code> element and obtaining a WebGL context. After obtaining a valid WebGL context, we will define and implement the vertex and fragment shader using ESSL. Then, we will <span>implement</span><a id="id325400732" class="indexterm"></a> the three functions that hook into the life cycle of our application: <code class="literal">configure</code>, <code class="literal">load</code>, and <code class="literal">draw</code>.</p><p>Before we get started, let's consider some of the fundamentals of our virtual showroom application.</p><p> </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec140"></a>Complexity of the Models</h3></div></div></div><p>Real-world applications are, generally, much more <span>complex</span><a id="id325400760" class="indexterm"></a> than PoC (proof of concept) demos. This is especially true with 3D applications, since 3D assets, such as models, are much more complex than simple spheres, cones, and other primitive geometric figures. Models in large 3D applications tend to have lots of vertices with complicated configurations that provide the level of detail and realism users expect. Apart from the pure geometrical representation of these models, they often come with several textures. As expected, creating geometries and textures <span class="emphasis"><em>manually</em></span> with JSON files is nothing short of daunting.</p><p>Fortunately, we can use various industry proved 3D design software to create and import models into a WebGL scene. For our 3D virtual car showroom, we will use models that have been <span>created</span><a id="id325400774" class="indexterm"></a> with <span class="strong"><strong>Blender</strong></span>, a widely used, open source 3D tool.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note83"></a>Note</h3><p><strong class="userinput"><code>Blender</code></strong>
Blender is an open source 3D computer graphics software that allows you to create animations, games, and other interactive applications. Blender provides numerous features so that you can create complex models. You can check out the official Blender website for more information: <a class="ulink" href="https://www.blender.org/" target="_blank">https://www.blender.org</a>.</p></div><p>We will use Blender to import car models into our WebGL scene. First, we will <span>export</span><a id="id325617267" class="indexterm"></a> the models to an intermediary file format called <span class="strong"><strong>OBJ</strong></span> and then <span>parse</span><a id="id325617280" class="indexterm"></a> them into consumable JSON files. We will cover more on these concepts later.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec141"></a>Shader Quality</h3></div></div></div><p>Since we will be using <span>complex</span><a id="id325617294" class="indexterm"></a> models, such as cars, we'll need to develop shaders that can render the different materials of our models. This should be relatively simple, since the shaders we've developed already handle diffuse, specular, and ambient components for materials. In Blender, we will select the option to export <span>materials</span><a id="id325643367" class="indexterm"></a> when generating the OBJ files. Blender will then generate a second file known as the <span class="strong"><strong>Material Template Library</strong></span> (<span class="strong"><strong>MTL</strong></span>). For the best results, our shaders will use Phong shading and Phong lighting, with support for multiple lights.</p><p> </p><p> </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec142"></a>Network Delays and Bandwidth Consumption</h3></div></div></div><p>When it comes to WebGL <span>applications</span><a id="id325643396" class="indexterm"></a> with large 3D assets, we <span>generally</span><a id="id325643404" class="indexterm"></a> download geometries and textures from a web server. As expected, this can take some time depending on the quality of the network connection and the amount of data that needs to be transferred. There are, however, several strategies for optimizing this process, such as compression and 3D asset optimizations, which will be covered in a later chapter. We will use AJAX to provide users with a great user experience by downloading these large assets in the background.</p><p>With these considerations in mind, let's get started.</p></div></div>