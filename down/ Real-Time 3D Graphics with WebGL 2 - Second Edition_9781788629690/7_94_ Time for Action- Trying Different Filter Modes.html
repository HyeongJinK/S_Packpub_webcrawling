<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec99"></a>Time for Action: Trying Different Filter Modes</h2></div></div><hr /></div><p>Let's cover an example of <span>seeing</span><a id="id325358908" class="indexterm"></a> different filter modes in action:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Open the <code class="literal">ch07_03_texture-filters.html</code>file using your browser:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788629690/graphics/3d64d571-e175-41cc-9572-d7dcab0c68bf.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>The controls include a slider to adjust the distance of the box from the viewer, while the buttons modify the magnification and minification filters.</li><li>Experiment with different modes to observe the effect they have on the texture. Magnification filters take effect when the cube's textures are being rendered larger than their source image size; minification filters when it is further away. Be sure to rotate the cube as well to <span>observe</span><a id="id325617303" class="indexterm"></a> what the texture looks like when viewed at an angle with each mode.</li></ol></div><p><span class="emphasis"><em><span class="strong"><strong>What just happened?</strong></span></em></span></p><p>We learned how to create and load textures into our 3D scene. We also covered various techniques for mapping textures onto objects, along with an interactive example to demonstrate these capabilities.</p><p>Let's look at each of the filter modes in depth and discuss how they work.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec123"></a>NEAREST</h3></div></div></div><p>Textures using the <code class="literal">NEAREST</code> filter always return the color of the texel <span>whose</span><a id="id325617372" class="indexterm"></a> center is nearest to the sample point. Using this mode, textures will look blocky and <span>pixilated</span><a id="id325617379" class="indexterm"></a> when viewed up close, which can be useful for creating "retro" graphics. <code class="literal">NEAREST</code> can be used for both the <code class="literal">MIN</code> and <code class="literal">MAG</code> filters:</p><div class="mediaobject"><img src="/graphics/9781788629690/graphics/90799c8c-d057-426d-b911-8a18fd9b55aa.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec124"></a>LINEAR</h3></div></div></div><p>The <code class="literal">LINEAR</code> filter returns the <span>weighted</span><a id="id325628785" class="indexterm"></a> average of the four pixels whose centers are nearest to the sample point. This provides a smooth <span>blending</span><a id="id325631832" class="indexterm"></a> of texel colors when looking at textures close upâ€”it's generally the more desirable effect. This does mean that the graphics hardware has to read four times as many pixels per fragment there is, so naturally, it's slower than <code class="literal">NEAREST</code>, but modern graphics hardware is so fast that this is <span>almost</span><a id="id325631874" class="indexterm"></a> never an issue. <code class="literal">LINEAR</code> can be used for both the <code class="literal">MIN</code> and <code class="literal">MAG</code> filters. This filtering mode is also known as <span class="strong"><strong>bilinear filtering</strong></span>:</p><div class="mediaobject"><img src="/graphics/9781788629690/graphics/9983006e-b2e1-415a-bb6b-551f69d894ec.png" /></div><p>Returning to the close-up example image we showed earlier in this chapter, had we used <code class="literal">LINEAR</code> filtering, it would have looked like this:</p><div class="mediaobject"><img src="/graphics/9781788629690/graphics/bebc56b8-0439-4482-a326-fdc5fd656469.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec125"></a>Mipmapping</h3></div></div></div><p>Before we can discuss the remaining filter <span>modes</span><a id="id325638066" class="indexterm"></a> that are only applicable to <code class="literal">TEXTURE_MIN_FILTER</code>, we need to introduce a new concept: <span class="strong"><strong>mipmapping</strong></span>.</p><p>A problem arises when <span>sampling</span><a id="id325643376" class="indexterm"></a> minified textures. In cases where we use <code class="literal">LINEAR</code> filtering and the sample points are so far apart, we can completely miss some details of the texture. As the view shifts, the texture fragments that we miss change, which results in a shimmering effect. You can see this in action by setting the <code class="literal">MIN</code> filter in the demo to <code class="literal">NEAREST</code> or <code class="literal">LINEAR</code>, zooming out, and rotating the cube:</p><div class="mediaobject"><img src="/graphics/9781788629690/graphics/92922195-b4a7-4ff9-b9d2-410be5f0ba09.png" /></div><p>To avoid this, graphics cards can utilize a <span class="strong"><strong>mipmap chain</strong></span>.</p><p>Mipmaps are scaled-down <span>copies</span><a id="id325643414" class="indexterm"></a> of a texture, with each copy being exactly half the size of the previous one. If you were to show a texture and all of its <span>mipmaps</span><a id="id325643421" class="indexterm"></a> in a row, it would look like this:</p><div class="mediaobject"><img src="/graphics/9781788629690/graphics/5a9c4c4e-2a76-4294-9a85-931338411727.png" /></div><p>The advantage is that when rendering, the graphics hardware can choose the copy of the texture that most closely matches the size of the texture on screen and samples from it instead. This reduces the number of skipped texels and the jittery artifacts that accompany them. However, mipmapping is only used if you use the appropriate texture filters.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl3sec39"></a>NEAREST_MIPMAP_NEAREST</h4></div></div></div><p>This filter will <span>select</span><a id="id325643482" class="indexterm"></a> the mipmap that most closely matches the size of the texture on screen and samples from it using the <code class="literal">NEAREST</code> algorithm.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl3sec40"></a>LINEAR_MIPMAP_NEAREST</h4></div></div></div><p>This filter selects the <span>mipmap</span><a id="id325643498" class="indexterm"></a> that most closely matches the size of the texture on screen and samples from it using the <code class="literal">LINEAR</code> algorithm.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl3sec41"></a>NEAREST_MIPMAP_LINEAR</h4></div></div></div><p>This filter selects two <span>mipmaps</span><a id="id325647099" class="indexterm"></a> that most closely match the size of the texture on screen and samples from both of them by using the <code class="literal">NEAREST</code> algorithm. The color returned is a weighted average of those two samples.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl3sec42"></a>LINEAR_MIPMAP_LINEAR</h4></div></div></div><p>This filter selects two <span>mipmaps</span><a id="id325647115" class="indexterm"></a> that most closely match the size of the texture on screen and samples from both of them using the <code class="literal">LINEAR</code> algorithm. The color <span>returned</span><a id="id325647125" class="indexterm"></a> is a weighted average of those two samples. This mode is also known as <span class="strong"><strong>trilinear filtering</strong></span>:</p><div class="mediaobject"><img src="/graphics/9781788629690/graphics/481ae502-de72-401a-9f3c-8b674f2405c4.png" /></div><p>Of the <code class="literal">*_MIPMAP_*</code> filter modes, <code class="literal">NEAREST_MIPMAP_NEAREST</code> is the fastest and lowest quality while <code class="literal">LINEAR_MIPMAP_LINEAR</code> will provide the best quality but the lowest performance. The other two modes sit somewhere in between on the quality/speed scale. In most cases, the performance trade-off will be small enough that it's common to use <code class="literal">LINEAR_MIPMAP_LINEAR</code>.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec126"></a>Generating Mipmaps</h3></div></div></div><p>WebGL doesn't automatically create <span>mipmaps</span><a id="id325647195" class="indexterm"></a> for every texture; so, if we want to use one of the <code class="literal">*_MIPMAP_*</code> filter modes, we have to create the mipmaps for the texture first. Fortunately, all this takes is a single function call:</p><pre class="programlisting">gl.generateMipmap(gl.TEXTURE_2D);</pre><p><code class="literal">generateMipmap</code> must be called after the texture has been populated with <code class="literal">texImage2D</code> and will automatically create a full mipmap chain for the image.</p><p>Alternatively, if you want to provide the mipmaps manually, you can always specify that you are providing a mipmap level rather than the source texture when calling <code class="literal">texImage2D</code> by passing a number other than <code class="literal">0</code> as the second parameter:</p><pre class="programlisting">gl.texImage2D(gl.TEXTURE_2D, 1, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, mipmapImage);</pre><p>Here, we're manually creating the first mipmap level, which is half the height and width of the normal texture. The second level would be a quarter of the dimensions of the normal texture, and so on.</p><p>This can be useful for some advanced effects or when using compressed textures that cannot be used with <code class="literal">generateMipmap</code>.</p><p>If you are familiar with WebGL 1, you'll remember its limit that textures with dimensions that were not a power of two (<span class="strong"><strong>not</strong></span><code class="literal">1</code>, <code class="literal">2</code>, <code class="literal">4</code>, <code class="literal">8</code>, <code class="literal">16</code>, <code class="literal">32</code>, <code class="literal">64</code>, <code class="literal">128</code>, <code class="literal">256</code>, <code class="literal">512</code>, and so on) could not use mips and <span>could</span><a id="id325628829" class="indexterm"></a> not repeat. In WebGL 2, these restrictions are gone.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note72"></a>Note</h3><p><strong class="userinput"><code>Non Power of Two (NPOT)</code></strong>
In order to use mipmaps with a texture in WebGL 1, mipmaps need to satisfy some dimension restrictions. Namely, the texture width and height must both be <span class="strong"><strong>Powers of Two</strong></span> (<span class="strong"><strong>POT</strong></span>). That is, the width and height can be <code class="literal">pow(2, n)</code> pixels, where <code class="literal">n</code> is any integer. Examples are <code class="literal">16px</code>, <code class="literal">32px</code>, <code class="literal">64px</code>, <code class="literal">128px</code>, <code class="literal">256px</code>, <code class="literal">512px</code>, <code class="literal">1024px</code>, and so on. Also, note that the width and height do not have to be the same as long as both are powers of two. For example, a <code class="literal">512x128</code> texture can still be mipmapped. NPOT textures can still be used with WebGL 1, but are restricted to only using<code class="literal">NEAREST</code>and<code class="literal">LINEAR</code>filters.
Why, then, is power restricted for two textures? Recall that the mipmap chain is made up of textures whose sizes are half the previous level. When the dimensions are powers of two, this will always produce integer numbers, which means that the number of pixels never needs to be rounded off, and hence produces clean and fast scaling algorithms.</p></div><p>For all of the texture code samples after this point, we'll be using a <span>simple</span><a id="id325628896" class="indexterm"></a> texture class that cleanly wraps up the texture's download, creation, and setup. Any textures created with the class will automatically have mipmaps generated for them and be set to use<code class="literal">LINEAR</code>for the magnification filter and<code class="literal">LINEAR_MIPMAP_LINEAR</code>for the minification filter.</p></div></div>