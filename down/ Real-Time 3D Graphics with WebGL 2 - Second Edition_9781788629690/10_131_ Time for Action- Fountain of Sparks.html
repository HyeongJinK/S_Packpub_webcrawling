<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch10lvl1sec133"></a>Time for Action: Fountain of Sparks</h2></div></div><hr /></div><p>Let's see how we can use <span>point</span><a id="id325358845" class="indexterm"></a> sprites to create a fountain of sparks:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Open the <code class="literal">ch10_02_point-sprites.html</code> file in your browser:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788629690/graphics/b3cdddb1-e9ab-40a3-ae3d-fba5ba05a958.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>This example showcases a simple <span class="emphasis"><em>fountain of sparks </em></span>effect with point sprites. You can adjust the size and lifetime of the particles by using the sliders.</li><li>The particle simulation is performed by maintaining a list of particles that are comprised of position, velocity, and lifespan. In every frame, we iterate through the list and move the particles according to the velocity; we also apply gravity and reduce the remaining lifespan. Once a particle's lifespan has reached <code class="literal">0</code>, it's reset to the origin with a random velocity and updated lifespan.</li><li>With every iteration of the particle's simulation, the particle positions and lifespans are copied to an array that is then used to update a vertex buffer. This vertex buffer is what is rendered to produce the onscreen sprites.</li><li>Let's experiment with some of the other values that control the simulation and see how they affect the scene. Open up <code class="literal">ch10_02_point-sprites.html</code> in your editor.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>First, locate the call to <code class="literal">configureParticles</code> at the bottom of the <code class="literal">configure</code> function. The number passed as an argument, initially set to <code class="literal">1024</code>, determines <span>how</span><a id="id325643462" class="indexterm"></a> many particles are created. Try changing it to a lower or higher value to see the effect it has on the particle system. Be careful, though, since extremely high values (for example, in the millions) may cause performance issues.</li><li>Next, find the <code class="literal">resetParticle</code> function. This function is called any time a particle is created or reset. There are several values here that can have a significant effect on how the scene renders:</li></ol></div><pre class="programlisting">function resetParticle(particle) {
  particle.position = [0, 0, 0];

particle.velocity = [
    Math.random() * 20 - 10,
Math.random() * 20,
Math.random() * 20 - 10,
];

particle.lifespan = Math.random() * particleLifespan;
particle.remainingLife = particle.lifespan;
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="8" type="1"><li>The <code class="literal">particle.position</code> is the <code class="literal">x</code>, <code class="literal">y</code>, <code class="literal">z</code> starting coordinates for the particle. Initially, all points start at the world origin <code class="literal">(0, 0, 0)</code>, but this could be set to anything. It's often desirable to have the particles originate from the location of another object so as to give the impression that the object is producing the particles. You can also randomize the position to make the particles appear within a given area.</li><li><code class="literal">particle.velocity</code> is the initial velocity of the particle. Here, you can see that it has been randomized so that particles spread out as they move away from the origin. Particles that move in random directions tend to look more like explosions or sprays, while those that move in the same direction give the appearance of a steady stream. In this case, the <code class="literal">y</code> value is designed to always be positive, while the <code class="literal">x</code> and <code class="literal">z</code> values may either be positive or negative. Experiment with what happens when you increase or decrease these velocity values or remove the random element from one of the components.</li><li>Finally, <code class="literal">particle.lifespan</code> determines how long a particle is displayed before being reset. This uses the value from the controls while being randomized to provide visual variety. If you remove the random element from the particle lifespan, all of the particles will expire and reset at the same time, resulting in fireworks-like <span class="emphasis"><em>bursts </em></span>of particles.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="11" type="1"><li>Next, find the <code class="literal">updateParticles</code> function. This function is called once per frame to update the position and velocity of all particles <span>before</span><a id="id325647145" class="indexterm"></a> pushing the new values to the vertex buffer. It's interesting to note that in terms of manipulating the simulation behavior, gravity is applied mid-way through the function:</li></ol></div><pre class="programlisting">function updateParticles(elapsed) {
// Loop through all the particles in the array
particles.forEach((particle, i) =&gt; {
// Track the particles lifespan
particle.remainingLife -= elapsed;

if (particle.remainingLife &lt;= 0) {
// Once the particle expires, reset it to the origin with a 
      // new velocity
resetParticle(particle);
}

// Update the particle position
particle.position[0] += particle.velocity[0] * elapsed;
particle.position[1] += particle.velocity[1] * elapsed;
particle.position[2] += particle.velocity[2] * elapsed;

// Apply gravity to the velocity
particle.velocity[1] -= 9.8 * elapsed;

if (particle.position[1] &lt; 0) {
// Allow particles to bounce off the floor
particle.velocity[1] *= -0.75;
particle.position[1] = 0;
}

// Update the corresponding values in the array
const index = i * 4;
particleArray[index] = particle.position[0];
particleArray[index + 1] = particle.position[1];
particleArray[index + 2] = particle.position[2];
particleArray[index + 3] = particle.remainingLife / 
     particle.lifespan;
});

// Once we are done looping through all the particles, update the 
  // buffer once
gl.bindBuffer(gl.ARRAY_BUFFER, particleBuffer);
gl.bufferData(gl.ARRAY_BUFFER, particleArray, gl.STATIC_DRAW);
gl.bindBuffer(gl.ARRAY_BUFFER, null);
}</pre><p> </p><div class="orderedlist"><ol class="orderedlist arabic" start="12" type="1"><li>The <code class="literal">9.8</code> here is the acceleration applied to the <code class="literal">y</code> component over time. In other words, this is the gravity. We can remove this calculation <span>entirely</span><a id="id325647205" class="indexterm"></a> to create an environment where the particles float indefinitely along their original trajectories. We can increase the value to make the particles fall very quickly (giving them a <span class="emphasis"><em>heavy</em></span> appearance), or we can change the component that the deceleration is applied to so that we can change the direction of gravity. For example, subtracting from <code class="literal">velocity[0]</code> makes the particles <span class="emphasis"><em>fall</em></span> sideways.</li><li>This is also where we apply a simple collision response with the <span class="emphasis"><em>floor</em></span>. Any particles with a <code class="literal">y</code><span class="emphasis"><em> </em></span>position less than <code class="literal">0</code> (below the floor) have their velocities reversed and reduced. This gives us a realistic bouncing motion. We can make the particles less bouncy by reducing the multiplier (that is, <code class="literal">0.25</code> instead of <code class="literal">0.75</code>) or even eliminate bouncing altogether by simply setting the <code class="literal">y</code> velocity to <code class="literal">0</code>. Additionally, we can remove the floor by taking away the check for <code class="literal">y &lt; 0</code>, which will allow the particles to fall indefinitely.</li><li>It's also worth seeing the different effects we can achieve with different textures. Try changing the path for the <code class="literal">spriteTexture</code> in the <code class="literal">configure</code> function to see what it looks like when you use different images.</li></ol></div><p><span class="emphasis"><em><span class="strong"><strong>What just happened?</strong></span></em></span></p><p>We've seen how point sprites can be used to efficiently render particle effects. We've also seen the different ways that we can manipulate a particle simulation to achieve various effects.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec163"></a>Have a Go: Bubbles!</h3></div></div></div><p>The particle system in place <span>here</span><a id="id325656665" class="indexterm"></a> could be used to simulate bubbles or smoke floating upward just as easily as bouncing sparks. How would you change the simulation to make the particles float rather than fall?</p></div></div>