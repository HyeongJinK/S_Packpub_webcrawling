<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec68"></a>Animating a 3D scene</h2></div></div><hr /></div><p>Animating a scene is <span>nothing</span><a id="id325357458" class="indexterm"></a> more than <span>applying</span><a id="id325358916" class="indexterm"></a> the appropriate local transformations to the objects in the scene. For instance, if we want to move a cone and a sphere, each one of them will have a corresponding local transformation that will describe its location, orientation, and scale. In the previous section, we learned that matrix stacks allow us to preserve the original Model-View transform so that we can apply the correct local transforms to each object.</p><p>Now that we know how to move objects with local transforms and matrix stacks, we should address w<span class="emphasis"><em>hen</em></span> to apply these transforms.</p><p>If we calculate the position to apply to the cone and sphere in our example every time we call the <code class="literal">render</code> function, this would imply that the animation rate would depend on the speed of our rendering cycle. A slow rendering cycle would produce choppy animations and too fast a rendering cycle would create the illusion of objects jumping from one side to the other without smooth transitions.</p><p>Therefore, it is important to make the animation independent of the rendering cycle. There are a couple of solutions that we can use to achieve this goal: the <code class="literal">requestAnimationFrame</code> function and JavaScript timers.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec86"></a>The requestAnimationFrame Function</h3></div></div></div><p>The <code class="literal">requestAnimationFrame</code> function is <span>available</span><a id="id325643395" class="indexterm"></a> in all WebGL-enabled browsers. One of the advantages of leveraging this function is that it is designed to call the <span>rendering</span><a id="id325643404" class="indexterm"></a> function (whatever function we indicate) only when the browser/tab window is in focus. Otherwise, there is no call. This saves precious CPU, GPU, and memory resources. By using the <code class="literal">requestAnimationFrame</code> function, we can obtain a rendering cycle that is in sync with hardware capabilities and one that will automatically suspend itself when the window is out of focus.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip57"></a>Note</h3><p><strong class="userinput"><code>requestAnimationFrame</code></strong>
To check out the status of <code class="literal">requestAnimationFrame</code> in your browser, visit <a class="ulink" href="https://caniuse.com/#search=requestanimationframe" target="_blank">https://caniuse.com/#search=requestanimationframe</a>.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec87"></a>JavaScript Timers</h3></div></div></div><p>That said, <code class="literal">requestAnimationFrame</code> is not a magical function that is a complete black box. It’s important to remember that we can implement our own in situations where it's not <span>available</span><a id="id325643472" class="indexterm"></a> or if we want a tailored animation experience. To do so, we will use two JavaScript timers to isolate the <span>rendering</span><a id="id325643480" class="indexterm"></a> rate from the animation rate.</p><p>Unlike the <code class="literal">requestAnimationFrame</code> function, JavaScript timers continue running in the background, even when the page is not in focus. This is not optimal performance since computer resources are allocated toward a scene that is not in view. To mimic some of the intelligent behavior of <code class="literal">requestAnimationFrame</code>, we can use the <code class="literal">onblur</code> and <code class="literal">onfocus</code> events of the JavaScript window object.</p><p>Let's see what we can do:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Action (What)</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Goal (Why)</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Method (How)</strong></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Pause the rendering</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>To stop the rendering until the window is in focus.</p></td><td style="border-bottom: 0.5pt solid ; "><p>Clear the timer calling <code class="literal">clearInterval</code> in the <code class="literal">window.onblur</code> function.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Slow the rendering</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>To reduce resource consumption but make sure that the 3D scene keeps evolving, even if we’re not looking at it.</p></td><td style="border-bottom: 0.5pt solid ; "><p>We can clear current timer calling <code class="literal">clearInterval</code> in the <code class="literal">window.onblur</code> function and create a new timer with a more relaxed interval (higher value).</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Resume the rendering</p></td><td style="border-right: 0.5pt solid ; "><p>To activate the 3D scene at full speed when the browser window recovers its focus.</p></td><td style=""><p>We start a new timer with the original render rate in the <code class="literal">window.onfocus</code> function.</p></td></tr></tbody></table></div><p> </p><p>By reducing the JavaScript timer rate or clearing the timer, we can handle hardware resources more efficiently.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip58"></a>Note</h3><p><strong class="userinput"><code>Controlling the Render Cycle</code></strong>
An example of this sort of low-level functionality can be seen in the <code class="literal">common/js/Clock.js</code> file. With this universal clock, you can see how the <code class="literal">onblur</code> and <code class="literal">onfocus</code> events have been used to control the clock ticking (the rendering cycle), as we described previously.</p></div></div></div>