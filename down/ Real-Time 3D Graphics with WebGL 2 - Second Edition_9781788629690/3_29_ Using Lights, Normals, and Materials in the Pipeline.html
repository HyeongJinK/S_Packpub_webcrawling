<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec38"></a>Using Lights, Normals, and Materials in the Pipeline</h2></div></div><hr /></div><p>In <a class="link" href="#" linkend="ch02">Chapter 2</a>, <span class="emphasis"><em>Rendering</em></span>, we discussed that WebGL buffers, attributes, and uniforms are used as input variables to the shaders, and that varyings are <span>used</span><a id="id325358916" class="indexterm"></a> to pass <span>information</span><a id="id325358924" class="indexterm"></a> between the <span>vertex</span><a id="id325358933" class="indexterm"></a> shader and the fragment shader. Let's revisit the pipeline and see where lights, normals, and materials fit in:</p><div class="mediaobject"><img src="/graphics/9781788629690/graphics/3570bac9-39ee-4856-b19d-26b59183a95c.png" /></div><p>Normals are defined on a vertex-per-vertex basis; therefore, normals are modeled as a VBO and are mapped using an attribute, as shown in the preceding diagram. Note that attributes cannot be directly passed to the fragment shader. To pass information from the vertex shader to the fragment shader, we must use varyings.</p><p>Lights and materials are passed as uniforms. Uniforms are available to both the vertex shader and the fragment shader. This gives us a lot of flexibility to calculate our lighting model, because we can calculate how the light is reflected on a vertex-by-vertex basis (vertex shader) or <span>on</span><a id="id325358957" class="indexterm"></a> a fragment-per-fragment basis (fragment shader).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note35"></a>Note</h3><p><strong class="userinput"><code>Program</code></strong>
Remember that the vertex shader and fragment shader together are referred to as a <span class="strong"><strong>program</strong></span>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec39"></a>Parallelism and the Difference Between Attributes and Uniforms</h3></div></div></div><p>There is an important <span>distinction</span><a id="id325359393" class="indexterm"></a> to make between <span>attributes</span><a id="id325359401" class="indexterm"></a> and uniforms. When a draw call is invoked (using <code class="literal">drawArrays</code> or <code class="literal">drawElements</code>), the GPU will launch several copies of the vertex shader in parallel. Each copy will receive a different set of attributes. These attributes are drawn from the VBOs that are mapped onto the respective attributes.</p><p>On the other hand, all of the copies of the vertex shaders will receive the same uniforms – hence the name: uniform. In other words, uniforms can be seen as constants <span class="emphasis"><em>per draw call</em></span>:</p><div class="mediaobject"><img src="/graphics/9781788629690/graphics/acd33d03-ea39-45f5-ad98-b4f8394f5104.png" /></div><p>Once lights, normals, and materials are passed to the program, the next step is to determine which <span class="emphasis"><em>shading</em></span> and <span class="emphasis"><em>lighting</em></span> models we will implement. Let's investigate what this involves.</p></div></div>