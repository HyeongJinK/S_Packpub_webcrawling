<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec105"></a>Time for Action: Trying out Cube Maps</h2></div></div><hr /></div><p>Let's cover an example of <span>seeing</span><a id="id325358908" class="indexterm"></a> cube maps in action:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Open the <code class="literal">ch07_07_cubemap.html</code>file in your browser. Once again, this contains a simple textured cube example on top of which we'll build the cube map example. We want to use the cube map to create a reflective-looking surface.</li><li>Creating the cube map is a bit more complicated than the textures we've loaded in the past, so this time, we'll use a function to simplify the asynchronous loading of individual cube faces. It's called <code class="literal">loadCubemapFace</code> and has already been to the file. Inside of the <code class="literal">configure</code> function, at the bottom, add the following code, which creates and loads the cube map faces:</li></ol></div><pre class="programlisting">cubeTexture = gl.createTexture();

gl.bindTexture(gl.TEXTURE_CUBE_MAP, cubeTexture);
gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

loadCubemapFace(gl, gl.TEXTURE_CUBE_MAP_POSITIVE_X, cubeTexture, '/common/images/cubemap/positive_x.png');

loadCubemapFace(gl, gl.TEXTURE_CUBE_MAP_NEGATIVE_X, cubeTexture, '/common/images/cubemap/negative_x.png');

loadCubemapFace(gl, gl.TEXTURE_CUBE_MAP_POSITIVE_Y, cubeTexture, '/common/images/cubemap/positive_y.png');

loadCubemapFace(gl, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, cubeTexture, '/common/images/cubemap/negative_y.png');

loadCubemapFace(gl, gl.TEXTURE_CUBE_MAP_POSITIVE_Z, cubeTexture, '/common/images/cubemap/positive_z.png');

loadCubemapFace(gl, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, cubeTexture, '/common/images/cubemap/negative_z.png');</pre><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>In the <code class="literal">render</code> function, add the code to bind the cube map to the appropriate sampler:</li></ol></div><pre class="programlisting">gl.activeTexture(gl.TEXTURE1);
gl.bindTexture(gl.TEXTURE_CUBE_MAP, cubeTexture);
gl.uniform1i(program.uCubeSampler, 1);</pre><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>Turning to the shader now, we want to add a new varying to the vertex shader:</li></ol></div><pre class="programlisting">out vec3 vVertexNormal;</pre><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>We'll be using the vertex normals instead of a dedicated texture coordinate to do the cube map sampling, which will give us the mirror effect we're looking for. Unfortunately, the actual normals of each face on the cube point straight out. If we were to use them, we would only get a single color per face from the cube map. In this case, we can "cheat" and use the vertex position as the normal instead (for most models, using the normals would be appropriate):</li></ol></div><pre class="programlisting">vVertexNormal = (uNormalMatrix * vec4(-aVertexPosition, 1.0)).xyz;</pre><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>We need to define the following varying inside of the fragment shader:</li></ol></div><pre class="programlisting">in vec3 vVertexNormal;</pre><div class="orderedlist"><ol class="orderedlist arabic" start="7" type="1"><li>We also need to add the new sampler uniform inside of the fragment shader. Be sure to also include this in the <code class="literal">uniforms</code> list inside of the <code class="literal">configure</code> function:</li></ol></div><pre class="programlisting">uniform samplerCube uCubeSampler;</pre><div class="orderedlist"><ol class="orderedlist arabic" start="8" type="1"><li>And then, in the fragment shader's <code class="literal">main</code> function, add the code to actually sample the cube map and blend it with the base texture:</li></ol></div><pre class="programlisting">fragColor = texture(uSampler, vTextureCoords) * texture(uCubeSampler, vVertexNormal);</pre><div class="orderedlist"><ol class="orderedlist arabic" start="9" type="1"><li>We should now be able to reload the file in a browser and see the scene shown in the following screenshot:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788629690/graphics/8d359fec-e158-49a7-88fd-5c34167c38e3.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="10" type="1"><li>The completed example is available in <code class="literal">ch07_08_cubemap-final.html</code>.</li></ol></div><p><span class="emphasis"><em><span class="strong"><strong>What just happened?</strong></span></em></span></p><p>As you rotate the cube, you'll notice that the <span>scene</span><a id="id325647123" class="indexterm"></a> displayed on the cube map does not rotate along, creating a "mirror" effect on the cube faces. This is due to multiplication of the normals by the Normal matrix when assigning the <code class="literal">vVertexNormal</code> varying, which puts the normals in world space.</p><p>Using cube maps for reflective surfaces is a <span>common</span><a id="id325647137" class="indexterm"></a> technique, but it's not the only use for cube maps. Other common uses include skyboxes and advanced lighting models.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note74"></a>Note</h3><p><strong class="userinput"><code>Skybox</code></strong><span class="strong"><strong></strong></span> A skybox is a method that's used for creating backgrounds to make computer and video game levels look bigger than they really are. When a skybox is used, the level is enclosed in a cuboid. The sky, distant mountains, distant buildings, and other unreachable objects are projected onto the cube's faces (using a technique called cube mapping), hence creating the illusion of distant, three-dimensional surroundings. A skydome employs the same concept but uses either a sphere or a hemisphere instead of a cube. For more information, check out the following URL: <a class="ulink" href="https://en.wikipedia.org/wiki/Skybox_(video_games)" target="_blank">https://en.wikipedia.org/wiki/Skybox_(video_games)</a>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec132"></a>Have a Go: Shiny Logo</h3></div></div></div><p>In this example, we've created a reflective "mirrored" cube. But what if we only wanted the logo to be reflective? How could we constrain the cube map to only be displayed within the red portion of the texture?</p><p> </p><p> </p></div></div>