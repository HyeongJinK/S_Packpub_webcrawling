<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec69"></a>Timing Strategies</h2></div></div><hr /></div><p>If you've programmed <span>animations</span><a id="id325358908" class="indexterm"></a> in JavaScript before, you may have used either <code class="literal">setInterval</code> or <code class="literal">setTimeout</code> to get your drawing function to be called.</p><p> </p><p> </p><p>The problem with using these two <span>approaches</span><a id="id325614930" class="indexterm"></a> for drawing is that they have no relation to the browser's render cycle. That is, they aren't synced to when the browser is going to draw a new frame, which can leave the animation out of sync with the user's machine. For example, if you use <code class="literal">setInterval</code> or <code class="literal">setTimeout</code> and assume <code class="literal">60</code> frames a second, and the user's machine is actually running a different frame rate, you'll be out of sync with their machine.</p><p>Even though <code class="literal">requestAnimationFrame</code> is available on all WebGL-enabled browsers, we'll leverage our own animation JavaScript timers for educational purposes. In production, it is recommended that you leverage the browser's optimized version.</p><p>In this section, we will create a JavaScript timer that will allow us to control the animation. As we mentioned previously, we will implement a JavaScript timing strategy that provides <span>independence</span><a id="id325617278" class="indexterm"></a> between how fast your computer can render frames and how fast you want the animation to go. We will refer to this property as the <span class="strong"><strong>animation rate</strong></span>.</p><p>Before moving forward, we must address a caveat about working with timers: <span class="emphasis"><em>JavaScript is not a multithreaded language</em></span>. This means that if there are several asynchronous events occurring at the same time (blocking events), the browser will queue them for posterior execution. Each browser has a different mechanism to deal with blocking event queues.</p><p>There are two blocking event-handling alternatives for the purpose of developing an animation timer.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec88"></a>Animation Strategy</h3></div></div></div><p>The first alternative is to <span>calculate</span><a id="id325617303" class="indexterm"></a> the elapsed time <span>inside</span><a id="id325617353" class="indexterm"></a> the timer callback. The pseudocode looks like this:</p><pre class="programlisting">const animationRate = 30; // 30 ms

let initialTime, elapsedTime;

function animate(deltaT) {
// calculate object positions based on deltaT
}

function onFrame() {
const currentTime = new Date().getTime();
elapsedTime = currentTime - initialTime;
if (elapsedTime &lt; animationRate) return; // come back later
animate(elapsedTime);
initialTime = currentTime;
}

function startAnimation() {
setInterval(onFrame, animationRate / 1000);
}</pre><p>In doing so, we guarantee that the <span>animation</span><a id="id325617366" class="indexterm"></a> time is independent of how often the timer callback is actually executed. If there are big delays (due to other blocking events), this method may result in <span class="strong"><strong>dropped frames</strong></span>. This means that the object's positions in our scene will immediately be moved to the current position that they should be in according to the elapsed time (between consecutive animation timer callbacks), and then the intermediate positions will be ignored. The motion on screen may jump, but often, a dropped animation frame is an acceptable loss in a real-time application. One example is the movement of one object from point <code class="literal">A</code> to point <code class="literal">B</code> over a given period of time. However, if we used this strategy when shooting a target in a 3D shooting game, we could quickly run into problems. Imagine that you are trying to shoot a target where there is a delay. The next thing you know, the target is no longer there! Since we need to calculate a collision in this case, we cannot afford to miss frames. This is because the collision could occur in any of the frames that we would drop without analyzing. The following strategy solves this problem.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec89"></a>Simulation Strategy</h3></div></div></div><p>There are several applications, such as the <span>shooting</span><a id="id325617389" class="indexterm"></a> game example, that require all intermediate frames to ensure the integrity of the outcome. These applications include working with collision detection, physics simulations, or artificial intelligence for games. For games, we need to update the object's <span>positions</span><a id="id325631832" class="indexterm"></a> at a constant rate. We do so by directly calculating the next position for the objects inside the timer callback:</p><pre class="programlisting">const animationRate = 30; // 30 ms
const deltaPosition = 0.1;

function animate(deltaP) {
// Calculate object positions based on deltaP
}

function onFrame() {
animate(deltaPosition);
}

function startAnimation() {
setInterval(onFrame, animationRate / 1000);
}</pre><p>This may lead to <span class="strong"><strong>frozen frames</strong></span> that occur <span>when</span><a id="id325631885" class="indexterm"></a> there is a long list of blocking events because the object's positions would not be updated in a timely manner.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec90"></a>Combined Approach: Animation and Simulation</h3></div></div></div><p>Generally speaking, browsers can efficiently handle blocking events, and in most cases, performance would be similar regardless of the chosen strategy. Deciding to <span>calculate</span><a id="id325638038" class="indexterm"></a> the elapsed time or the next position in timer callbacks will then depend on your particular application.</p><p>Nonetheless, there are cases where it is desirable to <span>combine</span><a id="id325638049" class="indexterm"></a> both animation and simulation strategies. We can create a timer callback that calculates the elapsed time and updates the animation as many times as required per frame. The pseudocode looks like the following:</p><pre class="programlisting">const animationRate = 30; // 30 ms
const deltaPosition = 0.1;

let initialTime, elapsedTime;

function animate(delta) {
// Calculate object positions based on delta
}

function onFrame() {
const currentTime = new Date().getTime();
elapsedTime = currentTime - initialTime;
if (elapsedTime &lt; animationRate) return; // come back later!
let steps = Math.floor(elapsedTime / animationRate);
while (steps &gt; 0) {
animate(deltaPosition);
steps -= 1;
}
  initialTime = currentTime;
}

function startAnimation() {
  initialTime = new Date().getTime();
setInterval(onFrame, animationRate / 1000);
}</pre><p>The preceding code snippet demonstrates that the animation will always update at a fixed rate, regardless of how much time elapses between frames. If the app is running at <code class="literal">60</code> Hz, the animation will update once every other frame; if the app runs at <code class="literal">30</code> Hz, the animation will update once per frame; if the app runs at <code class="literal">15</code> Hz, the animation will update twice per frame. The animation remains far more stable and deterministic if it is always moved forward by a fixed amount.</p><p>The following sequence shows the responsibilities of each function in the call stack for the combined approach:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">render</code>:
<div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Starts the timer</li><li style="list-style-type: disc">Sets the animation rate</li><li style="list-style-type: disc">The timer callback is the <code class="literal">onFrame</code> function</li></ul></div></li><li style="list-style-type: disc"><code class="literal">onFrame</code>:
<div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Calculates the elapsed time since the last call.</li><li style="list-style-type: disc">If the elapsed time is less than the animation rate, then it returns without further processing. Otherwise, it calculates the number of frames that the animation needs to be updated.</li><li style="list-style-type: disc">Updates the animation by calling the <code class="literal">animate</code> function.</li></ul></div></li><li style="list-style-type: disc"><code class="literal">animate</code>:
<div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Updates the object positions by a fixed increment. In this example, the sphere is updated by <code class="literal">0.1</code> units every time <code class="literal">animate</code> is called.</li><li style="list-style-type: disc">It calls <code class="literal">draw</code> to update the object on screen. This is <span class="emphasis"><em>optional</em></span>, since the rendering loop calls <code class="literal">draw</code> periodically anyway.</li></ul></div></li><li style="list-style-type: disc"><code class="literal">draw</code>:
<div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Creates a local transformation using the new position calculated in <code class="literal">animate</code>, and it applies it to the corresponding object.</li></ul></div></li></ul></div><p>The code looks <span>something</span><a id="id325659911" class="indexterm"></a> like this:</p><pre class="programlisting">transforms.calculateModelView();
transforms.push();

if (object.alias === 'sphere') {
const sphereTransform = transforms.modelViewMatrix;
mat4.translate(sphereTransform, sphereTransform, [0, 0, spherePosition]);
}
else if (object.alias === 'cone') {
const coneTransform = transforms.modelViewMatrix;
mat4.translate(coneTransform, coneTransform, [conePosition, 0, 0]);
}

transforms.setMatrixUniforms();
transforms.pop();</pre><p>This approach may cause issues if an <span>animation</span><a id="id325662114" class="indexterm"></a> step actually takes longer to compute than the fixed step. If this occurs, you should simplify your animation code or release a recommended minimum system spec for your application.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec91"></a>Web Workers: Multithreading in JavaScript</h3></div></div></div><p>Though outside the scope of this book, you <span>should</span><a id="id325662129" class="indexterm"></a> consider using <span class="strong"><strong>Web Workers</strong></span> if performance is critical to you. Doing so will ensure that a particular update loop always fires at a consistent rate.</p><p>Web Workers is an API that allows web <span>applications</span><a id="id325662145" class="indexterm"></a> to spawn background processes that run scripts in parallel to their main page. This allows for thread-like operation with message-passing as the coordination mechanism.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note59"></a>Note</h3><p><strong class="userinput"><code>Web Workers</code></strong>
You can find the Web Workers specification at <a class="ulink" href="http://dev.w3.org/html5/workers/" target="_blank">http://dev.w3.org/html5/workers/</a>.</p></div></div></div>