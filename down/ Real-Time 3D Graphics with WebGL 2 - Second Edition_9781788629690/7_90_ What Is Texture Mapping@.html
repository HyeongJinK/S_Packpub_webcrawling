<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec95"></a>What Is Texture Mapping?</h2></div></div><hr /></div><p>Texture mapping is simply a method for <span>adding</span><a id="id325358908" class="indexterm"></a> detail to a geometry being rendered by displaying an image on the surface. Consider the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781788629690/graphics/a152b82b-99bb-44e4-bad5-7bac8b5da4bf.png" /></div><p>Using only the techniques we've learned so far, this relatively simple scene would be very difficult to build. The WebGL logo alone would have to be carefully constructed out of many triangle primitives. Although this is a possible approach, the additional geometry construction would be impractical for a marginally complex scene.</p><p>Fortunately, texture <span>mapping</span><a id="id325643370" class="indexterm"></a> makes such requirements incredibly simple. All that's required is an image in an appropriate file format, an additional vertex attribute on the mesh, and a few additions to our shader code.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec120"></a>Creating and Uploading a Texture</h3></div></div></div><p>Unlike traditional native OpenGL applications, browsers load textures "upside down". As a result, many WebGL applications set textures to be loaded with the <code class="literal">Y</code> coordinate flipped. This is done with a single call:</p><pre class="programlisting">gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip67"></a>Note</h3><p><strong class="userinput"><code>Inverted Textures</code></strong>
Textures can either be manually flipped or flipped via WebGL. We will programmatically flip them with WebGL.</p></div><p>The process of creating a <span>texture</span><a id="id325643403" class="indexterm"></a> is similar to <span>creating</span><a id="id325643412" class="indexterm"></a> a vertex or an index buffer. We start by creating the texture object, as follows:</p><pre class="programlisting">const texture = gl.createTexture();</pre><p>Textures, like buffers, must be bound before we can manipulate them:</p><pre class="programlisting">gl.bindTexture(gl.TEXTURE_2D, texture);</pre><p>The first parameter indicates the type of texture we're binding, or the texture target. For now, we'll focus on 2D textures, indicated with <code class="literal">gl.TEXTURE_2D</code>. More targets will be introduced later in this chapter.</p><p>Once we've bound the texture, we can provide it with image data. The simplest way to do that is to pass a DOM image into the <code class="literal">texImage2D</code> function, as shown in the following code snippet:</p><pre class="programlisting">const image = document.getElementById('texture-image');
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);</pre><p>In the previous snippet, we selected an image element from our page with the ID of <code class="literal">texture-image</code> as the source texture. This is <span class="strong"><strong>uploading</strong></span> the texture, since the image will be stored in the GPU's memory for fast access during rendering. The source can be in any image format that can be displayed on a web page, such as JPEG, PNG, GIF, and BMP files.</p><p>The image source for the texture is passed in as the last parameter of the <code class="literal">texImage2D</code> call. When <code class="literal">texImage2D</code> is called with an image, WebGL will automatically determine the dimensions of the provided texture. The remainder of the parameters instruct WebGL about the type of information the image contains and how to store it. Most of the time, the only values you need to worry about changing are the third and fourth parameters, which can also be <code class="literal">gl.RGB</code>, to indicate that your texture has no alpha (transparency) channel.</p><p>In addition to the image, we also need to instruct WebGL on how to filter the texture when rendering. We'll get into what filtering means and what the different filtering modes do in a bit. In the meantime, let's use the simplest one to get us started:</p><pre class="programlisting">gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);</pre><p>Just as with buffers, it's good practice to unbind a texture when you are finished using it. You can do so by binding <code class="literal">null</code> as the active texture:</p><pre class="programlisting">gl.bindTexture(gl.TEXTURE_2D, null);</pre><p>Of course, in many cases, you won't want to have all of the textures for your scene embedded in your web page, so it's often more convenient to create the element in JavaScript and load it without adding it to the document. Putting all of this together gives us a simple function that will load any image URL that we provide as a texture:</p><pre class="programlisting">const texture = gl.createTexture();

const image = new Image();

image.src = 'texture-file.png';

image.onload = () =&gt; {
  gl.bindTexture(gl.TEXTURE_2D, texture);
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, 
   image);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
gl.bindTexture(gl.TEXTURE_2D, null);
};</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip68"></a>Note</h3><p><strong class="userinput"><code>Asynchronous Loading</code></strong>
There is a slight gotcha when loading images this way. The image loading is <span class="strong"><strong>asynchronous</strong></span>, which means that your program won't stop and wait for the image to finish loading before continuing execution. So what happens if you try to use a texture before it's been populated with image data? Your scene will still render, but any texture values you sample will be black.</p></div><p>In short, creating <span>textures</span><a id="id325647130" class="indexterm"></a> follows the same <span>pattern</span><a id="id325647139" class="indexterm"></a> as using buffers. For every texture we create, we want to do the following:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Create a new texture</li><li>Bind it to make it the current texture</li><li>Pass the texture contents, typically from an image</li><li>Set the filter mode or other texture parameters</li><li>Unbind the texture</li></ol></div><p>If we reach a point where we no <span>longer</span><a id="id325647193" class="indexterm"></a> need a texture, we can remove it and free up the associated memory by using <code class="literal">deleteTexture</code>:</p><pre class="programlisting">gl.deleteTexture(texture);</pre><p>After this, the texture is no longer valid. Any attempt to use it will react as though <code class="literal">null</code> has been passed.</p></div></div>