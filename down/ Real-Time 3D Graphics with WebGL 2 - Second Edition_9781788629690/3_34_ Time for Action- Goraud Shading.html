<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec43"></a>Time for Action: Goraud Shading</h2></div></div><hr /></div><p>Let's cover an example <span>where</span><a id="id325358908" class="indexterm"></a> we implement lighting with Goraud shading:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Open the <code class="literal">ch03_03_goraud_phong.html</code> file in your browser. You will see something similar to the following screenshot:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788629690/graphics/3f829a9d-19c0-4223-8634-8242e7de4056.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>The interface looks a little bit more elaborate than the diffuse lighting example. Let's stop here for a moment to explain these widgets:
<div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><strong class="userinput"><code>Light Color</code></strong> (light diffuse term): As mentioned at the beginning of this chapter, we can have an example where our light is not white. We have included a color selector widget here for the light color so that you can experiment with different combinations.</li><li style="list-style-type: disc"><span class="strong"><strong><strong class="userinput"><code>Light Ambient Term</code></strong></strong></span>: The light <span>ambient</span><a id="id325359800" class="indexterm"></a> property. In this example, this is a gray value: <code class="literal">r = g = b</code>.</li><li style="list-style-type: disc"><strong class="userinput"><code>Light Specular Term</code></strong>: The light specular property. This is a gray value: <code class="literal">r = g = b</code>.
</li><li style="list-style-type: disc"><strong class="userinput"><code>Translate X,Y,Z</code></strong>: The coordinates that define the light's orientation.</li><li style="list-style-type: disc"><strong class="userinput"><code>Sphere Color</code></strong> (material diffuse term): The material diffuse property. We have included a color selector so that you can try different combinations for the <code class="literal">r</code>, <code class="literal">g</code>, and <code class="literal">b</code> channels.</li><li style="list-style-type: disc"><strong class="userinput"><code>Material Ambient Term</code></strong>: The material ambient property. We have included it just for the sake of it. But as you might have noticed in the diffuse example, this vector is not always used.</li><li style="list-style-type: disc"><strong class="userinput"><code>Material Specular Term</code></strong>: The material specular property. This is a gray value : r = g = b.</li><li style="list-style-type: disc"><strong class="userinput"><code>Shininess</code></strong>: The specular exponential factor for the Goraud model.</li><li style="list-style-type: disc"><strong class="userinput"><code>Background Color</code></strong> (<code class="literal">gl.clearColor</code>): This widget simply allows us to change the background color. </li></ul></div></li><li>The specular reflection in the Phong reflection model depends on the shininess, the specular property of the material, and the specular property of the light. When the specular property of the material is close to <code class="literal">0</code>, the material <span class="emphasis"><em>loses </em></span>its specular property. Check this behavior with the widget provided:
<div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">What happens when the specularity of the material is low and the shininess is high?</li><li style="list-style-type: disc">What happens when the specularity of the material is high and the shininess is low?</li><li style="list-style-type: disc">Using the widgets, try different combinations for the light and material properties.</li></ul></div></li></ol></div><p><span class="emphasis"><em><span class="strong"><strong>What just happened?</strong></span></em></span></p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">We saw how the different parameters of the Phong lighting model interact with each other.</li><li style="list-style-type: disc">We modified the light orientation, the properties of the light, and the material to observe different behaviors of the Phong lighting model.</li><li style="list-style-type: disc">Unlike the Lambertian reflection model, the Goraud lighting model has two extra terms: the ambient and specular components. We saw how these parameters affect the scene.</li></ul></div><p>Just like the Lambertian reflection model, the Phong reflection model obtains the vertex color in the vertex shader. This color is interpolated in the fragment shader to obtain the final pixel color. This is because, in both cases, we are using Goraud interpolation. Let's now move <span>the</span><a id="id325617358" class="indexterm"></a> heavy processing to the fragment shader and study how we implement the Phong interpolation method.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec57"></a>Phong Shading</h3></div></div></div><p>Unlike the Goraud interpolation, where we calculated <span>the</span><a id="id325617373" class="indexterm"></a> final color for each vertex, the Phong interpolation calculates the final color for every fragment. This means that <span>the</span><a id="id325617383" class="indexterm"></a> calculation of the ambient, diffuse, and specular terms in the Phong model are performed in the fragment shader instead of the vertex shader. As you can imagine, this is computationally more intensive than performing a simple interpolation like in the two previous scenarios where we were using Goraud interpolation. However, we obtain a scene that seems more realistic.</p><p>After this translation, you may be wondering what is left for the vertex shader to do. Well, in this case, we will create varyings that will allow us to do all of the calculations in the fragment shader. For example, the vertex normals are a great fit.</p><p>Whereas before we had a normal per vertex, now we need to generate a normal for every pixel so that we can calculate the Lambert coefficient for each fragment. We do so by interpolating the normals that we pass to the fragment shader. Nevertheless, the code is very simple. All we need to know is how to create a varying that stores the normal for the vertex we are processing in the vertex shader and to obtain the interpolated value in the fragment shader (courtesy of ESSL). That's all! Conceptually, this is represented in the following diagram:</p><div class="mediaobject"><img src="/graphics/9781788629690/graphics/c70460a5-8a43-4a61-939e-286ab3740641.png" /></div><p>Now, let's take a look at the vertex shader under Phong shading:</p><pre class="programlisting">#version 300 es
precision mediump float;

uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;
uniform mat4 uNormalMatrix;

in vec3 aVertexPosition;
in vec3 aVertexNormal;

out vec3 vNormal;
out vec3 vEyeVector;

void main(void) {
  vec4 vertex = uModelViewMatrix * vec4(aVertexPosition, 1.0);
  vNormal = vec3(uNormalMatrix * vec4(aVertexNormal, 1.0));
  vEyeVector = -vec3(vertex.xyz);
  gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aVertexPosition, 1.0);
}</pre><p>Unlike our examples with the Goraud interpolation, the vertex shader looks really simple. There is no final color calculation and we are using two varyings to pass information to the fragment shader. The fragment shader will now look like the following:</p><pre class="programlisting">#version 300 es
precision mediump float;

uniform float uShininess;
uniform vec3 uLightDirection;
uniform vec4 uLightAmbient;
uniform vec4 uLightDiffuse;
uniform vec4 uLightSpecular;
uniform vec4 uMaterialAmbient;
uniform vec4 uMaterialDiffuse;
uniform vec4 uMaterialSpecular;

in vec3 vNormal;
in vec3 vEyeVector;

out vec4 fragColor;

void main(void) {
  vec3 L = normalize(uLightDirection);
  vec3 N = normalize(vNormal);
  float lambertTerm = dot(N, -L);
  vec4 Ia = uLightAmbient * uMaterialAmbient;
  vec4 Id = vec4(0.0, 0.0, 0.0, 1.0);
  vec4 Is = vec4(0.0, 0.0, 0.0, 1.0);

  if (lambertTerm &gt; 0.0) {
    Id = uLightDiffuse * uMaterialDiffuse * lambertTerm;
    vec3 E = normalize(vEyeVector);
    vec3 R = reflect(L, N);
    float specular = pow( max(dot(R, E), 0.0), uShininess);
    Is = uLightSpecular * uMaterialSpecular * specular;
  }

  fragColor = vec4(vec3(Ia + Id + Is), 1.0);
}</pre><p>When we pass vectors as varyings, it is possible that <span>they</span><a id="id325631892" class="indexterm"></a> denormalize in the interpolation step. Therefore, you may have noticed that both <code class="literal">vNormal</code> and <code class="literal">vEyeVector</code> are <span>normalized</span><a id="id325638045" class="indexterm"></a> again in the fragment shader.</p><p>As we mentioned before, under Phong lighting, the Lambertian reflection model can be seen as a Phong reflection model where the ambient and specular components are set to <code class="literal">0</code>. Therefore, we will only cover the general case in the next section where we will see what the sphere scene looks like when using Phong shading and Phong lighting combined.</p></div></div>