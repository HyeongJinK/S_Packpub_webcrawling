<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec118"></a>Time for Action: Unique Object Labels</h2></div></div><hr /></div><p>This section is <span>divided</span><a id="id325357458" class="indexterm"></a> into two parts. In the first part, you will develop code to generate a random scene with cones and cylinders. Each object will be assigned a unique object label that will be used for coloring the object in the offscreen renderbuffer. In the second part, we will configure the picker to work with unique labels. Let's get started:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Open the <code class="literal">ch08_02_picking-initial.html</code> file in your browser. This is a scene that is only showing the floor object. We are going to create a scene that contains multiple objects that can be either balls or cylinders.</li><li>Open <code class="literal">ch08_02_picking-initial.html</code> in a source code editor.</li><li>We will write code so that each object in the scene can have the following:
<div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">A position assigned randomly</li><li style="list-style-type: disc">A unique object label color</li><li style="list-style-type: disc">A non-unique diffuse color</li><li style="list-style-type: disc">A scale factor that will determine the size of the object</li></ul></div></li><li>We have provided empty functions that you will implement in this section.</li><li>Let's write the <code class="literal">positionGenerator</code> function. Scroll down to it and add the following code:</li></ol></div><pre class="programlisting">function positionGenerator() {
const
flagX = Math.floor(Math.random() * 10),
flagZ = Math.floor(Math.random() * 10);

let x = Math.floor(Math.random() * 60),
z = Math.floor(Math.random() * 60);

if (flagX &gt;= 5) {
    x = -x;
}
if (flagZ &gt;= 5) {
    z = -z;
}

return [x, 0, z];
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>Here, we are using the <code class="literal">Math.random</code> function to generate the <code class="literal">x</code> and <code class="literal">z</code> coordinates for an object in the scene. Since <code class="literal">Math.random</code> always returns a positive number, we use the <code class="literal">flagX</code> and <code class="literal">flagZ</code> variables to randomly distribute the objects on the <code class="literal">x</code>-<code class="literal">z</code> plane (floor). Also, because we want all of the objects to be on the <code class="literal">x</code>-<code class="literal">z</code> plane, the <code class="literal">y</code> component is always set to <code class="literal">0</code> in the <code class="literal">return</code> statement.</li><li>Let's write a unique object label generator function. Scroll to the empty <code class="literal">objectLabelGenerator</code> function and add the following code:</li></ol></div><pre class="programlisting">const colorset = {};

function objectLabelGenerator() {
const
color = [Math.random(), Math.random(), Math.random(), 1],
key = color.toString();

if (key in colorset) {
return objectLabelGenerator();
}
else {
    colorset[key] = true;
return color;
}
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="8" type="1"><li>We create a random color using the <code class="literal">Math.random</code> function. If the <code class="literal">key</code> variable is already a property of the <code class="literal">colorset</code> object, then we call the <code class="literal">objectLabelGenerator</code> function recursively to get a new value; otherwise, we make <code class="literal">key</code> a property of <code class="literal">colorset</code> and then <code class="literal">return</code> the respective color. Notice how well the handling of JavaScript objects as sets allows us to resolve any possible key collision.</li><li>Write the <code class="literal">diffuseColorGenerator</code> function. We will use this function to assign diffuse properties to the objects:</li></ol></div><pre class="programlisting">function diffuseColorGenerator(index) {
const color = (index % 30 / 60) + 0.2;
return [color, color, color, 1];
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="10" type="1"><li>This function represents the case where we want to generate colors that are not unique. The index parameter represents the index of the object in the <code class="literal">scene.objects</code> list to which we are assigning the diffuse color. In this function, we are creating a gray-level color since the <code class="literal">r</code>, <code class="literal">g</code>, and <code class="literal">b</code> components in the <code class="literal">return</code> statement all have the same <code class="literal">color</code> value.</li><li>The <code class="literal">diffuseColorGenerator</code> function will create collisions every <code class="literal">30</code> indices. The remainder of the division of the index by <code class="literal">30</code> will create a loop in the sequence:</li></ol></div><pre class="programlisting">0 % 30 = 0
1 % 30 = 1
...
29 % 30 = 29
30 % 30 = 0
31 % 30 = 1
... </pre><div class="orderedlist"><ol class="orderedlist arabic" start="12" type="1"><li>Since this result is being divided by <code class="literal">60</code>, the result will be a number in the <code class="literal">[0, 0.5]</code> range. Then, we add <code class="literal">0.2</code> to make sure that the <span>minimum</span><a id="id325628805" class="indexterm"></a> value that <code class="literal">color</code> has is <code class="literal">0.2</code>. This way, the objects will not look too dark during the onscreen rendering (they would be black if the calculated diffuse color were <code class="literal">0</code>).</li><li>The last auxiliary function we will write is the <code class="literal">scaleGenerator</code> function:</li></ol></div><pre class="programlisting">function scaleGenerator() {
const scale = Math.random() + 0.3;
return [scale, scale, scale];
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="14" type="1"><li>This function will allow us to have objects of different sizes. <code class="literal">0.3</code> is added to control the minimum scaling factor that any object will have in the scene.</li><li>Let's load <code class="literal">100</code> objects to our scene. By the end of this section, you will be able to test picking on any of them!</li><li>Go to the <code class="literal">load</code> function and edit it so that it looks like this:</li></ol></div><pre class="programlisting">function load() {
  scene.add(new Floor(80, 20));

for (let i = 0; i &lt; 100; i++) {
const objectType = Math.floor(Math.random() * 2);

const options = {
position: positionGenerator(),
scale: scaleGenerator(),
diffuse: diffuseColorGenerator(i),
pcolor: objectLabelGenerator()
    };

switch (objectType) {
case 1:
return scene.load('/common/models/ch8/sphere.json', 
         `ball_${i}`, options);
case 0:
return scene.load('/common/models/ch8/cylinder.json', 
         `cylinder_${i}`, options);
}
  }
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="17" type="1"><li>The picking color is represented by the <code class="literal">pcolor</code> attribute. This attribute is passed in a list of attributes to the <code class="literal">scene.load</code> function. Once the object is loaded (using <span class="strong"><strong>JSON/Ajax</strong></span>), <code class="literal">load</code> uses this list of attributes and adds them as object properties.</li><li>The shaders in this exercise have already been set up for you. The <code class="literal">pcolor</code> property that corresponds to the unique object label is mapped to the <code class="literal">uPickingColor</code> uniform, and the <code class="literal">uOffscreen</code> uniform determines whether it is used in the fragment shader:</li></ol></div><pre class="programlisting">uniform vec4 uPickingColor;

void main(void) {

  if (uOffscreen) {
    fragColor = uPickingColor;
    return;
  }
  else {
    // on-screen rendering
  }

}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="19" type="1"><li>As described previously, we keep the offscreen and onscreen buffers in sync by using the <code class="literal">render</code> function as follows:</li></ol></div><pre class="programlisting">function render() {
// Off-screen rendering
gl.bindFramebuffer(gl.FRAMEBUFFER, picker.framebuffer);
gl.uniform1i(program.uOffscreen, true);
draw();

// On-screen rendering
gl.uniform1i(program.uOffscreen, showPickingImage);
gl.bindFramebuffer(gl.FRAMEBUFFER, null);
draw();
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="20" type="1"><li>Save your work as <code class="literal">ch08_03_picking-no-picker.html</code>.</li><li>Open <code class="literal">ch08_03_picking-no-picker.html</code> in your browser.</li><li>Click on <strong class="userinput"><code>Show Picking Image</code></strong>. What happens?</li><li>The scene is being rendered to both the offscreen and default onscreen framebuffer. However, we have not configured the <code class="literal">Picker</code> callbacks yet.</li><li>Open <code class="literal">ch08_03_picking-no-picker.html</code> in your source code editor.</li><li>Scroll down to the <code class="literal">configure</code> function. The picker is already set up for you:</li></ol></div><pre class="programlisting">picker = new Picker(canvas, {
hitPropertyCallback: hitProperty,
addHitCallback: addHit,
removeHitCallback: removeHit,
processHitsCallback: processHits,
moveCallback: movePickedObjects
});</pre><div class="orderedlist"><ol class="orderedlist arabic" start="26" type="1"><li>This code fragment maps functions in the web page to picker callback hooks. These callbacks are invoked according to the picking state.</li><li>We will now implement the necessary callbacks. Again, we have provided empty functions that you will need to code.</li><li>Let's create the <code class="literal">hitProperty</code> function. Scroll down to the empty <code class="literal">hitProperty</code> function and add the following code:</li></ol></div><pre class="programlisting">function hitProperty(obj) {
return obj.pcolor;
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="29" type="1"><li>We are returning the <code class="literal">pcolor</code> property to make the <span>comparison</span><a id="id325400924" class="indexterm"></a> with the color that will be read from the offscreen framebuffer. If these colors match, then we have a hit.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="30" type="1"><li>Write the <code class="literal">addHit</code> and <code class="literal">removeHit</code> functions. We want to create the effect where the diffuse color is changed to the picking color during picking. We need an extra property to temporarily save the original diffuse color so that we can restore it later:</li></ol></div><pre class="programlisting">function addHit(obj) {
  obj.previous = obj.diffuse.slice(0);
obj.diffuse = obj.pcolor;
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="31" type="1"><li>The <code class="literal">addHit</code> function stores the current diffuse color in an auxiliary property named <code class="literal">previous</code>. Then, it changes the diffuse color to <code class="literal">pcolor</code>, the object-picking label:</li></ol></div><pre class="programlisting">function removeHit(obj) {
  obj.diffuse = obj.previous.slice(0);
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="32" type="1"><li>The <code class="literal">removeHit</code> function restores the diffuse color.</li><li>Now, let's write the code for <code class="literal">processHits</code>:</li></ol></div><pre class="programlisting">function processHits(hits) {
  hits.forEach(hit =&gt; hit.diffuse = hit.previous);
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="34" type="1"><li>Remember that <code class="literal">processHits</code> is called upon exiting picking mode. This function will receive one parameter: the <code class="literal">hits</code> that the <code class="literal">picker</code> detected. Each element of the <code class="literal">hits</code> list is an object in <code class="literal">scene</code>. In this case, we want to give the hits their diffuse color back. For that, we use the previous property that we set in the <code class="literal">addHit</code> function.</li><li>The last picker callback we need to implement is the <code class="literal">movePickedObjects</code> function:</li></ol></div><pre class="programlisting">function movePickedObjects(dx, dy) {
const hits = picker.getHits();

if (!hits) return;

const factor = Math.max(
    Math.max(camera.position[0], camera.position[1]), 
     camera.position[2]
  ) / 2000;

hits.forEach(hit =&gt; {
const scaleX = vec3.create();
const scaleY = vec3.create();

if (controls.alt) {
      vec3.scale(scaleY, camera.normal, dy * factor);
}
else {
      vec3.scale(scaleY, camera.up, -dy * factor);
vec3.scale(scaleX, camera.right, dx * factor);
}

    vec3.add(hit.position, hit.position, scaleY);
vec3.add(hit.position, hit.position, scaleX);
});
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="36" type="1"><li>This function allows us to move the objects in the hits list interactively. The parameters that this callback function receives are as follows:
<div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">dx</code>: Displacement in the horizontal direction obtained from the mouse when it is dragged on <code class="literal">canvas</code></li><li style="list-style-type: disc"><code class="literal">dy</code>: Displacement in the vertical direction obtained from the mouse when it is dragged on <code class="literal">canvas</code></li></ul></div></li><li>Let's analyze the code. First, we retrieve all of the hits from the picker instance:</li></ol></div><pre class="programlisting">const hits = picker.getHits();</pre><div class="orderedlist"><ol class="orderedlist arabic" start="38" type="1"><li>If there are no hits, the function <code class="literal">returns</code> immediately:</li></ol></div><pre class="programlisting">if (!hits) return;</pre><div class="orderedlist"><ol class="orderedlist arabic" start="39" type="1"><li>We calculate a weighing factor that we will use later (the fudge factor):</li></ol></div><pre class="programlisting">const factor = Math.max(
  Math.max(camera.position[0], camera.position[1]), camera.position[2]
) / 2000;</pre><div class="orderedlist"><ol class="orderedlist arabic" start="40" type="1"><li>We create a loop to go through the hits list so that we can update each object's position:</li></ol></div><pre class="programlisting">hits.forEach(hit =&gt; {
const scaleX = vec3.create();
const scaleY = vec3.create();

  // ...
});</pre><div class="orderedlist"><ol class="orderedlist arabic" start="41" type="1"><li>The <code class="literal">scaleX</code> and <code class="literal">scaleY</code> variables are initialized for every hit.</li><li>The <span class="emphasis"><em>Alt</em></span> key is being used to <span>perform</span><a id="id325401204" class="indexterm"></a> dollying (moving the camera along its normal path). In this case, we want to move the objects that are in the picking list along the camera's normal direction when the user is pressing the <span class="emphasis"><em>Alt</em></span> key to provide a consistent user experience.</li><li>To move the hits along the camera normal, we use the <code class="literal">dy</code> (up-down) displacement, as follows:</li></ol></div><pre class="programlisting">if (controls.alt) {
  vec3.scale(scaleY, camera.normal, dy * factor);
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="44" type="1"><li>This creates a scaled version of <code class="literal">camera.normal</code> and <span>stores</span><a id="id325401238" class="indexterm"></a> it into the <code class="literal">scaleY</code> variable. Notice that <code class="literal">vec3.scale</code> is an operation that's available in the <span class="strong"><strong>glMatrix</strong></span> library.</li><li>If the user is not pressing the <span class="emphasis"><em>Alt</em></span> key, then we use <code class="literal">dx</code> (left-right) and <code class="literal">dy</code> (up-down) to move the hits in the camera plane. Here, we use the camera's up and right vectors to calculate the <code class="literal">scaleX</code> and <code class="literal">scaleY</code> parameters:</li></ol></div><pre class="programlisting">else {
  vec3.scale(scaleY, camera.up, -dy * factor);
vec3.scale(scaleX, camera.right, dx * factor);
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="46" type="1"><li>We update the position of the hit:</li></ol></div><pre class="programlisting">vec3.add(hit.position, hit.position, scaleY);
vec3.add(hit.position, hit.position, scaleX);</pre><div class="orderedlist"><ol class="orderedlist arabic" start="47" type="1"><li>Save the page as <code class="literal">ch08_04_picking-final.html</code> and open it using your browser.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="48" type="1"><li>You will see a scene like the one shown in the following screenshot:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788629690/graphics/0b800bf4-a1f9-4335-827c-dcf9f9234a32.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="49" type="1"><li>Click on <strong class="userinput"><code>Reset Scene</code></strong><span class="strong"><strong> </strong></span>several times and <span>verify</span><a id="id325401405" class="indexterm"></a> that you get a new scene every time.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="50" type="1"><li>In this scene, all of the objects have very similar colors. However, each one has a unique picking color. To verify this, click on the <strong class="userinput"><code>Show Picking Image</code></strong><span class="strong"><strong> </strong></span>button. You will see on the screen what is being rendered in the offscreen buffer:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788629690/graphics/3768249c-7571-4d96-b700-28f1f6866587.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="51" type="1"><li>Let's validate the changes that we made to the picker callbacks. Let's start by picking one object. As you can see, the object diffuse color <span>becomes</span><a id="id325401444" class="indexterm"></a> its picking color (this was the change you implemented in the <code class="literal">addHit</code> function):</li></ol></div><div class="mediaobject"><img src="/graphics/9781788629690/graphics/e600b49e-32cc-47fa-9b7b-f2fd62f68b13.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="52" type="1"><li>When the mouse is released, the object goes back to the original color. This is the change that was implemented in the <code class="literal">processHits</code> function.</li><li>While the mouse button is held down over an object, you can drag it around. When this is done, <code class="literal">movePickedObjects</code> is being invoked.</li><li>Pressing the <span class="emphasis"><em>Shift</em></span> key while objects are being selected will tell the picker <span>not</span><a id="id325358992" class="indexterm"></a> to exit <span class="strong"><strong>picking mode</strong></span>. This way, you can select and move more than one object at once:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788629690/graphics/441c72b0-c8d8-437e-855b-0bdc0c09df27.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="55" type="1"><li>You will exit picking mode if you select an object and the <span class="emphasis"><em>Shift</em></span> key is no longer pressed or if your next click does not produce any hits (in other words, clicking anywhere else).</li><li>If you have any problems with this <span>exercise</span><a id="id325359025" class="indexterm"></a> or missed one of the steps, we have included the complete exercise in the <code class="literal">ch08_03_picking-no-picker.html</code> and <code class="literal">ch08_04_picking-final.html</code> files.</li></ol></div><p><span class="emphasis"><em><span class="strong"><strong>What just happened?</strong></span></em></span></p><p>We have done the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Created the property-picking color. This property is unique for every object in the scene and allows us to implement picking based on it.</li><li style="list-style-type: disc">Modified the fragment shader to use the picking color property by including a new uniform, <code class="literal">uPickingColor</code>, and mapping this uniform to the <code class="literal">pcolor</code> object property.</li><li style="list-style-type: disc">Learned about the different picking states. We have also learned how to modify the <code class="literal">Picker</code> callbacks to perform specific application logic such as removing picked objects from the scene.</li></ul></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec137"></a>Have a Go: Clearing the Scene</h3></div></div></div><p>Rewrite the <code class="literal">processHits</code> function to <span>remove</span><a id="id325359077" class="indexterm"></a> the balls in the hit list from the scene. If the user has removed all of the balls from the scene, display a message with the elapsed time for accomplishing this task.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip77"></a>Note</h3><p><strong class="userinput"><code>Hint</code></strong>
Use <code class="literal">scene.remove(objectName)</code> in the <code class="literal">processHits</code> function if the alias starts with <code class="literal">ball_</code>.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip78"></a>Note</h3><p><strong class="userinput"><code>Hint</code></strong>
Once the hits are removed from the scene, revisit the <code class="literal">scene.objects</code> list and make sure that there are no objects whose alias starts with <code class="literal">ball_</code>.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip79"></a>Note</h3><p><strong class="userinput"><code>Hint</code></strong>
Use a JavaScript timer to measure and display the elapsed time until task completion.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec138"></a>Have a Go: Using Alternative Identifiers for Picking</h3></div></div></div><p>How would you uniquely identify objects <span>without</span><a id="id325359131" class="indexterm"></a> using colors? Since we are leveraging an offscreen framebuffer, we could identify each object with a unique ID rather than a color since the <span>visuals</span><a id="id325359140" class="indexterm"></a> of our offscreen render do not matter. Go ahead and implement an ID-based strategy for identifying each object.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note80"></a>Note</h3><p><strong class="userinput"><code>Packing Indices into RGBA Channels</code></strong><span class="strong"><strong></strong></span>
You can think of object <code class="literal">1</code> as being the index (or color) <code class="literal">[0, 0, 0, 1]</code>, object <code class="literal">2</code> as <code class="literal">[0, 0, 0, 2]</code>, all the way up to where object <code class="literal">1020</code> (that is, <code class="literal">255 * 4</code>) would be <code class="literal">[255, 255, 255, 255]</code>.</p></div><p>Since our RGBA channel is bound to a range of <code class="literal">[0-255]</code>, how could we pack more IDs into our four-based vector?</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip81"></a>Note</h3><p><strong class="userinput"><code>Different Base Numeral System</code></strong>
You may first think of leveraging decimals instead of whole numbers. This is a viable solution, especially after you account for the accuracy of floating points in ESSL. Another viable solution would be to use a <code class="literal">255</code> based numeral system rather than our traditional base <code class="literal">10</code>. With this approach, you could uniquely identify 4+ billions objects without decimals.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec139"></a>Have a Go: Decoupling WebGL Components</h3></div></div></div><p>Although we can <span>implement</span><a id="id325359208" class="indexterm"></a> <code class="literal">Controls</code> and <code class="literal">Picker</code> by <span>decoupling</span><a id="id325359223" class="indexterm"></a> them with a more scalable architecture, we opted for a simpler implementation for educational purposes.</p><p>That being said, how would you rebuild the examples in this chapter with the goal of decoupling classes from one another to minimize component interdependence?</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip82"></a>Note</h3><p><strong class="userinput"><code>Hint</code></strong>
One approach would be to leverage the pub/sub pattern discussed earlier for our <code class="literal">Clock</code>. That is, each component can extend the <code class="literal">EventEmitter</code> class – similar to <code class="literal">Clock</code> – to publish events that other components may subscribe to.</p></div></div></div>