<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec40"></a>OpenGL ES Shading Language (ESSL)</h2></div></div><hr /></div><p>The OpenGL ES Shading Language (ESSL) is the language we'll use to write our shaders. Its syntax and semantics are very similar to C/C++. However, it has <span>types</span><a id="id325357458" class="indexterm"></a> and built-in functions that make it easier to manipulate vectors and matrices. In this section, we will cover the basics of ESSL so that we can start using it right away.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note38"></a>Note</h3><p><strong class="userinput"><code>GLSL and ESSL</code></strong><span class="strong"><strong></strong></span> It’s quite common for developers to refer to the shading language used in WebGL as GLSL. However, it is technically ESSL. WebGl2 is built on the OpenGL ES 3.0 spec and therefore uses ESSL, which is a subset of GLSL (the shading language for OpenGL).
This section summarizes the official GLSL ES specifications. You can find the complete reference at <a class="ulink" href="https://www.khronos.org/registry/OpenGL/specs/es/3.0/GLSL_ES_Specification_3.00.pdf" target="_blank">https://www.khronos.org/registry/OpenGL/specs/es/3.0/GLSL_ES_Specification_3.00.pdf</a>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec45"></a>Storage Qualifier</h3></div></div></div><p>Variable declarations may <span>have</span><a id="id325358936" class="indexterm"></a> a storage qualifier <span>specified</span><a id="id325358945" class="indexterm"></a> in front of the type:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">attribute</code>: Data pulled from buffers that serve as the link between a vertex shader and a WebGL application for per-vertex data. This storage qualifier is only legal inside the vertex shader.</li><li style="list-style-type: disc"><code class="literal">uniform</code>: Value does not change across the object being processed. Uniforms form the link between a shader and a WebGL application. Uniforms are legal in both the vertex and fragment shaders. If a uniform is shared by the vertex and fragment shader, the respective declarations must match. Uniform values stay the same for all vertices of a single draw call.</li><li style="list-style-type: disc"><code class="literal">varying</code>: This is the link between a vertex shader and a fragment shader for interpolated data. By definition, varyings must be shared by the vertex shader and fragment shader. The declaration of varyings needs to match between the vertex and fragment shaders.</li><li style="list-style-type: disc"><code class="literal">const</code>: A compile-time constant, or a function parameter that is read-only. They can be used anywhere in the code of an ESSL program.</li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec46"></a>Types</h3></div></div></div><p>Here is a non-exhaustive <span>list</span><a id="id325359389" class="indexterm"></a> of the most common ESSL types:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">void</code>: For functions that do not return a value or for an empty parameter list</li><li style="list-style-type: disc"><code class="literal">bool</code>: A conditional type, taking on values of true or false</li><li style="list-style-type: disc"><code class="literal">int</code>: A signed integer</li><li style="list-style-type: disc"><code class="literal">float</code>: A single floating-point scalar</li><li style="list-style-type: disc"><code class="literal">vec2</code>: A two-component floating-point vector</li><li style="list-style-type: disc"><code class="literal">vec3</code>: A three-component floating-point vector</li><li style="list-style-type: disc"><code class="literal">vec4</code>: A four-component floating-point vector</li><li style="list-style-type: disc"><code class="literal">bvec2</code>: A two-component Boolean vector</li><li style="list-style-type: disc"><code class="literal">bvec3</code>: A three-component Boolean vector</li><li style="list-style-type: disc"><code class="literal">bvec4</code>: A four-component Boolean vector</li><li style="list-style-type: disc"><code class="literal">ivec2</code>: A two-component integer vector</li><li style="list-style-type: disc"><code class="literal">ivec3</code>: A three-component integer vector</li><li style="list-style-type: disc"><code class="literal">ivec4</code>: A four-component integer vector</li><li style="list-style-type: disc"><code class="literal">mat2</code>: A 2×2 floating-point matrix</li><li style="list-style-type: disc"><code class="literal">mat3</code>: A 3×3 floating-point matrix</li><li style="list-style-type: disc"><code class="literal">mat4</code>: A 4×4 floating-point matrix</li><li style="list-style-type: disc"><code class="literal">sampler2D</code>: A handle for accessing a 2D texture</li><li style="list-style-type: disc"><code class="literal">sampler3D</code>:  A handle for accessing a 3D texture</li><li style="list-style-type: disc"><code class="literal">samplerCube</code>: A handle for accessing a cube-mapped texture</li><li style="list-style-type: disc"><code class="literal">struct</code>: Used to declare custom data structures based on standard types</li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note39"></a>Note</h3><p><strong class="userinput"><code>ESSL</code></strong><span class="strong"><strong></strong></span> There are many other types and features that the OpenGL ES 3.0 shading language provides. Here is a useful guide that covers many of its core features: <a class="ulink" href="https://www.khronos.org/files/opengles3-quick-reference-card.pdf" target="_blank">https://www.khronos.org/files/opengles3-quick-reference-card.pdf</a>.</p></div><p>An input variable will have one of the qualifiers followed by one type. For example, we will declare our <code class="literal">uLightColor</code> variable as follows:</p><pre class="programlisting">uniform vec4 uLightColor;</pre><p>This means that the <code class="literal">uLightColor</code> variable is a <code class="literal">uniform</code> vector with four components.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note40"></a>Note</h3><p><strong class="userinput"><code>The GLSL and ESSL Naming Convention</code></strong><span class="strong"><strong></strong></span> Convention dictates that we prefix shader variables with their type. This makes for clear and readable shader code. For example, for a given color uniform, you would name the variable <code class="literal">uLightColor</code>. For a position varying, <code class="literal">vNormal</code>. For a normal attribute, <code class="literal">aVertexNormal</code>.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec47"></a>Vector Components</h3></div></div></div><p>We can refer to each <span>one</span><a id="id325617301" class="indexterm"></a> of the components of an ESSL vector by its index. For example, <code class="literal">uLightColor[3]</code> will refer to the fourth element of <span>the</span><a id="id325617354" class="indexterm"></a> vector (zero-based vectors). However, we can also refer to each component by a letter, as demonstrated in the following table:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">{ x, y, z, w }</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Useful when accessing vectors that represent points or vectors.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">{ r, g, b, a }</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Useful when accessing vectors that represent colors.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">{ s, t, p, q }</code></p></td><td style=""><p>Useful when accessing vectors that represent texture coordinates.</p></td></tr></tbody></table></div><p> </p><p>For example, if we want to set the <span class="emphasis"><em>alpha channel</em></span> (fourth component) of our <code class="literal">uLightColor</code> variable to <code class="literal">1.0</code>, we can do so by writing in any of the following formats:</p><pre class="programlisting">uLightColor[3] = 1.0;
uLightColor.w = 1.0;
uLightColor.a = 1.0;
uLightColor.q = 1.0;</pre><p>In all these of cases, we are referring to the same fourth component. However, given that <code class="literal">uLightColor</code> represents a color, it makes more sense to use the <code class="literal">r</code>, <code class="literal">g</code>, <code class="literal">b</code>, <code class="literal">a</code> notation.</p><p>It’s also possible to use the vector component notation to refer to subsets inside a vector. For example <span class="emphasis"><em>(taken from GLSL ES specification)</em></span>:</p><pre class="programlisting">vec4 v4;

v4.rgba;  // is a vec4 and the same as just using v4
v4.rgb;   // is a vec3
v4.b;     // is a float
v4.xy;    // is a vec2
v4.xgba;  // is illegal - the component names do not come from the same set</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec48"></a>Operators and Functions</h3></div></div></div><p>One of the major <span>advantages</span><a id="id325643491" class="indexterm"></a> of GLSL and ESSL are the powerful built-in mathematical operators. ESSL provides many useful operators and <span>functions</span><a id="id325643499" class="indexterm"></a> that simplify vector and matrix operations. According to the specifications, the arithmetic binary operators add (<code class="literal">+</code>), subtract (<code class="literal">-</code>), multiply (<code class="literal">*</code>), and divide (<code class="literal">/</code>) operate on integer and floating-point typed expressions, including vectors and matrices. The two operands must be the same type, or one can be a scalar float and the other a float vector or matrix, or one can be a scalar integer and the other an integer vector. Additionally, for multiply (<code class="literal">*</code>), one can be a vector and the other a matrix with the same dimensional size as the vector. These result in the same fundamental types (integer or float) as the expressions they operate on. If one operand is a scalar and the other is a vector or a matrix, the scalar is applied component-wise to the vector or the matrix, with the final result being of the same type as the vector or the matrix. It's important to note that dividing by zero does not cause an exception, but it does result in an unspecified value. Let's see a few examples of these operations:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">-x</code>: The negative of the <code class="literal">x</code> vector. It produces the same vector in the exact opposite direction.</li><li style="list-style-type: disc"><code class="literal">x + y</code>: Sum of the <code class="literal">x</code> and <code class="literal">y</code> vectors. Both vectors need to have the same number of components.</li><li style="list-style-type: disc"><code class="literal">x - y</code>: Subtraction of the <code class="literal">x</code> and <code class="literal">y</code> vectors. Both vectors need to have the same number of components.</li><li style="list-style-type: disc"><code class="literal">x * y</code>: If <code class="literal">x</code> and <code class="literal">y</code> are both vectors, this operator yields a component-wise multiplication. Multiplication applied to two matrices returns a linear algebraic matrix multiplication, not a component-wise multiplication.</li><li style="list-style-type: disc"><code class="literal">matrixCompMult(matX, matY)</code>: Component-wise multiplication of matrices. They need to have the same dimensions (<code class="literal">mat2</code>, <code class="literal">mat3</code>, or <code class="literal">mat4</code>).</li><li style="list-style-type: disc"><code class="literal">x / y</code>: The division operator behaves similarly to the multiplication operator.</li><li style="list-style-type: disc"><code class="literal">dot(x, y)</code>: Returns the dot product (scalar) of two vectors. They need to have the same dimensions.</li><li style="list-style-type: disc"><code class="literal">cross(vecX, vecY)</code>: Returns the cross product (vector) of two vectors. They must both be <code class="literal">vec3</code>.</li><li style="list-style-type: disc"><code class="literal">normalize(x)</code>: Returns a vector in the same direction but with a length of <code class="literal">1</code>.</li><li style="list-style-type: disc"><code class="literal">reflect(t, n)</code>: Reflects the <code class="literal">t</code><span class="emphasis"><em> </em></span>vector along the <code class="literal">n</code> vector.</li></ul></div><p>Shaders offer many more functions, including trigonometric and exponential functions. We will refer to them as needed in the development of different lighting models.</p><p>Let's see a quick example of the shader's ESSL code for a scene with the following properties:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Goraud shading</strong></span>: We will <span>interpolate</span><a id="id325652533" class="indexterm"></a> vertex colors to obtain fragment colors. Therefore, we need one <code class="literal">varying</code> to pass the vertex color information from the vertex shader to the fragment shader.</li><li style="list-style-type: disc"><span class="strong"><strong>Lambertian reflection model</strong></span>: We <span>account</span><a id="id325656613" class="indexterm"></a> for the diffuse interaction between one light source and our scene. This means that we will use uniforms to define the light properties that is, the material properties. We will follow <span class="emphasis"><em>Lambert's Emission Law </em></span>to calculate the final color for every vertex.</li></ul></div><p>First, let's dissect what the attributes, uniforms, and varyings will be.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec49"></a>Vertex Attributes</h3></div></div></div><p>We will start by <span>defining</span><a id="id325656667" class="indexterm"></a> two attributes in the <span>vertex</span><a id="id325656676" class="indexterm"></a> shader. Every vertex will have the following code:</p><pre class="programlisting">in vec3 aVertexPosition;
in vec3 aVertexNormal;</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip41"></a>Note</h3><p><span class="strong"><strong>Attributes</strong></span>
Remember that attributes are only available to use inside the vertex shader.</p></div><p>If you're curious as to why <code class="literal">in</code> is used instead of the <code class="literal">attribute</code> qualifier, we will cover this shortly. Right after the <code class="literal">in</code> keyword, we find the type of the variable. In this case, it is <code class="literal">vec3</code>, as each vertex position is determined by three elements (<code class="literal">x</code>, <code class="literal">y</code>, <code class="literal">z</code>). Similarly, the normals are also determined by three elements (<code class="literal">x</code>, <code class="literal">y</code>, <code class="literal">z</code>). Please note that a position is a <span class="emphasis"><em>point</em></span> in three-dimensional space that tells us where the vertex is, while a normal is a <span class="emphasis"><em>vector</em></span> that gives us information about the orientation of the surface that passes along that vertex.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec50"></a>Uniforms</h3></div></div></div><p>Uniforms are available to both the <span>vertex</span><a id="id325659879" class="indexterm"></a> shader and the fragment shader. While attributes differ every time the vertex shader is invoked, uniforms are <span>constant</span><a id="id325659888" class="indexterm"></a> throughout a rendering cycle – that is, during the <code class="literal">drawArrays</code> or <code class="literal">drawElements</code> WebGL call.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip42"></a>Note</h3><p><strong class="userinput"><code>Parallel Processing</code></strong>
We process vertices in parallel; therefore, each copy/thread of the vertex shader processes a different vertex.</p></div><p>We can use uniforms to pass along information about lights (such as diffuse color and direction), and materials (diffuse color):</p><pre class="programlisting">uniform vec3 uLightDirection;  // incoming light source direction
uniform vec4 uLightDiffuse;    // light diffuse component
uniform vec4 uMaterialDiffuse; // material diffuse color</pre><p>Again, the <code class="literal">uniform</code> keyword tells us that these variables are uniforms, and the <code class="literal">vec3</code> and <code class="literal">vec4</code> ESSL types tell us that these variables have three or four components. For the colors, these components are the red, blue, green, and alpha channels (RGBA), and for the light direction, these components are the <code class="literal">x</code>, <code class="literal">y</code>, and <code class="literal">z</code> coordinates that define the vector in which the light source is directed in the scene.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec51"></a>Varyings</h3></div></div></div><p>As described earlier, varyings allow for <span>the</span><a id="id325358996" class="indexterm"></a> vertex shader to pass information to the fragment shader. For example, if we want to carry the vertex color from <span>the</span><a id="id325359005" class="indexterm"></a> vertex shader to the fragment shader, we would first update our vertex shader:</p><pre class="programlisting">#version 300 es

out vec4 vVertexColor;

void main(void) {
  vVertexColor = vec4(1.0, 1.0, 1.0, 1.0);
}</pre><p>And we would reference that varying inside of our fragment shader as follows:</p><pre class="programlisting">in vec4 vVertexColor;</pre><p>Keep in the mind that the <span class="emphasis"><em>Storage Qualifier</em></span>, the declaration of varyings, needs to match between the vertex and fragment shaders.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec17"></a>The in and out variables</h4></div></div></div><p>These keywords describe <span>the</span><a id="id325359040" class="indexterm"></a> direction of the <span class="emphasis"><em>input</em></span> and <span class="emphasis"><em>output</em></span>. As seen with the <span class="emphasis"><em>attribute</em></span> and <span class="emphasis"><em>varying</em></span> declarations, when we use <code class="literal">in</code>, that variable is supplied to the shader. When we use <code class="literal">out</code>, the shader exposes that variable. Let's see how these keywords are used in earlier versions of WebGL within the vertex and fragment shader.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch03lvl4sec2"></a>Changing attribute to in</h5></div></div></div><p>In WebGL 1 with <span class="emphasis"><em>ESSL 100</em></span>, you <span>might</span><a id="id325359077" class="indexterm"></a> have this:</p><pre class="programlisting">attribute vec4 aVertexPosition;
attribute vec3 aVertexNormal;</pre><p>In WebGL 2 with <span class="emphasis"><em>ESSL 300</em></span>, this becomes the following:</p><pre class="programlisting">in vec4 aVertexPosition;
in vec3 aVertexNormal;</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch03lvl4sec3"></a>Changing varying to in / out</h5></div></div></div><p>WebGL 1 with <span class="emphasis"><em>ESSL 100</em></span>, you <span>declare</span><a id="id325359112" class="indexterm"></a> a varying in both the vertex and fragment shaders, like so:</p><pre class="programlisting">varying vec4 vVertexPosition;
varying vec3 vVertexNormal;</pre><p>In WebGL 2 with <span class="emphasis"><em>ESSL 300</em></span>, in the vertex shader, the varyings become this:</p><pre class="programlisting">out vec4 vVertexPosition;
out vec3 vVertexNormal;</pre><p>And in the fragment shader, they become this:</p><pre class="programlisting">in vec4 vVertexPosition;
in vec3 vVertexNormal;</pre><p>Now, let's plug the attributes, uniforms, and varyings into the code and see what the vertex shader and fragment shader look like.</p></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec52"></a>Vertex Shader</h3></div></div></div><p>Let's <span>cover</span><a id="id325359153" class="indexterm"></a> a sample <span>vertex</span><a id="id325359161" class="indexterm"></a> shader:</p><pre class="programlisting">#version 300 es

uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;
uniform mat4 uNormalMatrix;
uniform vec3 uLightDirection;
uniform vec3 uLightDiffuse;
uniform vec3 uMaterialDiffuse;

in vec3 aVertexPosition;
in vec3 aVertexNormal;

out vec4 vVertexColor;

void main(void) {
vec3 normal = normalize(vec3(uNormalMatrix * vec4(aVertexNormal, 1.0)));

vec3 lightDirection = normalize(uLightDirection);

float LambertianTerm = dot(normal, -lightDirection);

vVertexColor = vec4(uMaterialDiffuse * uLightDiffuse * LambertianTerm, 
   1.0);

gl_Position = uProjectionMatrix * uModelViewMatrix * 
   vec4(aVertexPosition, 1.0);
}</pre><p>On first inspection, we can identify the attributes, uniforms, and varyings that we will use, along with some matrices that we will discuss later. We can also see that the vertex shader has a <code class="literal">main</code> function that does not accept parameters and instead returns <code class="literal">void</code>. Inside, we can see some ESSL functions, such as <code class="literal">normalize</code> and <code class="literal">dot</code>, along with some arithmetical operators.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note43"></a>Note</h3><p><code class="literal">#version 300 es</code>
This string must be the very first line of your shader. No comments or blank lines are allowed before it! <code class="literal">#version 300 es</code> tells WebGL that you want to use WebGL 2's shader language (GLSL ES 3.00). If that isn’t written as the first line, the shader language defaults to WebGL 1.0's GLSL ES 1.00, which has fewer features.</p></div><p>There are three uniforms that we haven’t discussed yet:</p><pre class="programlisting">uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;
uniform mat4 uNormalMatrix;</pre><p>We can see that these three uniforms are <code class="literal">4x4</code> matrices. These matrices are required in the vertex shader to calculate the location for vertices and normals whenever we move the camera. There are a couple of operations here that involve using these matrices:</p><pre class="programlisting">vec3 normal = normalize(vec3(uNormalMatrix * vec4(aVertexNormal, 1.0)));
</pre><p>The previous line of code calculates the <span class="emphasis"><em>transformed normal</em></span>:</p><pre class="programlisting">gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aVertexPosition, 1.0);</pre><p>This line calculates the <span class="emphasis"><em>transformed vertex position</em></span>. <code class="literal">gl_Position</code> is a special output variable that stores the transformed vertex position.</p><p>We will come back to these operations in <a class="link" href="#" linkend="ch04">Chapter 4</a>, <span class="emphasis"><em>Cameras</em></span>. For now, we should acknowledge that these uniforms and operations deal with camera and world transformations (rotation, scale, and translation).</p><p>Returning to the main function’s code, we can clearly see that the Lambertian reflection model is being implemented. The <code class="literal">dot</code> product of the normalized normal and light direction vector is obtained and then multiplied by the light and material diffuse components. Finally, this result is passed into the <code class="literal">vVertexColor</code> varying to be used in the fragment shader, as follows:</p><pre class="programlisting">vVertexColor = vec4(uMaterialDiffuse * uLightDiffuse * LambertianTerm, 1.0);</pre><p>Also, as we are calculating the color in the vertex shader and then automatically interpolating it for the fragments of every triangle, we are using the Goraud interpolation method.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec53"></a>Fragment Shader</h3></div></div></div><p>The fragment <span>shader</span><a id="id325359850" class="indexterm"></a> is very simple. The first <span>three</span><a id="id325359859" class="indexterm"></a> lines define the precision of the shader. This is mandatory according to the ESSL specification. Similarly, for the vertex shader, we define our input; in this case, just one varying variable, and then we have the main function:</p><pre class="programlisting">#version 300 es

// Fragment shaders don't have a default precision so we need
// to pick one. mediump is a good default. It means "medium precision"
precision mediump float;

in vec4 vVertexColor;
// we need to declare an output for the fragment shader
out vec4 fragColor;

void main() {
  fragColor = vVertexColor;
}</pre><p>We just need to assign the <code class="literal">vVertexColor</code> varying to the <code class="literal">fragColor</code> output variable.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note44"></a>Note</h3><p><strong class="userinput"><code>No More <code class="literal">gl_FragColor</code></code></strong>
In WebGL 1, your fragment shader would set the <code class="literal">gl_FragColor</code> special variable to compute the output of the shader: <code class="literal">gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);</code>.
In WebGL 2, <span class="emphasis"><em>ESSL 300</em></span> forces you to declare your own output variable and then set it. You can pick any name you want, but names cannot begin with <code class="literal">gl_</code>.</p></div><p>Remember that the value of the <code class="literal">vVertexColor</code> varying will be different from the one calculated in the vertex shader since WebGL will interpolate it by taking the corresponding calculated colors for the vertices surrounding the correspondent fragment (pixel).</p></div></div>