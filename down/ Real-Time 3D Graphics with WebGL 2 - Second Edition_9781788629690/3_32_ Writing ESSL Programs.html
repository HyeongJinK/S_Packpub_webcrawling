<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec41"></a>Writing ESSL Programs</h2></div></div><hr /></div><p>Now, let's take a moment to <span>step</span><a id="id325358908" class="indexterm"></a> back and look at the big picture. ESSL allows us to implement a lighting strategy, provided that we define a shading method and a light reflection model. In this section, we will take a sphere as the object that we want to illuminate, and we will see how the selection of a lighting strategy changes the scene:</p><div class="mediaobject"><img src="/graphics/9781788629690/graphics/a6aef32a-8fac-485e-9060-2f1978a7d3e0.png" /></div><p>We will see two scenarios for Goraud interpolation: one with Lambertian and one with Phong reflections. We will only see one case for Phong interpolation; under Phong shading, the Lambertian reflection model is no different from a Phong reflection model where the ambient and specular components are set to <code class="literal">0</code>.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec54"></a>Goraud Shading with Lambertian Reflections</h3></div></div></div><p>The Lambertian reflection <span>model</span><a id="id325359782" class="indexterm"></a> only considers <span>the</span><a id="id325359790" class="indexterm"></a> interaction of diffuse material and diffuse light properties. In short, we assign the final color as follows:</p><pre class="programlisting">aVertexColor = Id;</pre><p>The following value is seen:</p><pre class="programlisting">Id = lightDiffuseProperty * materialDiffuseProperty * lambertCoefficient;</pre><p>Under Goraud shading, the <span class="strong"><strong>Lambert coefficient</strong></span> is <span>obtained</span><a id="id325359818" class="indexterm"></a> by calculating the dot product of the vertex normal and the inverse of the light-direction vector. Both vectors are normalized before finding the dot product.</p><p>Let's take a look at the vertex shader and the fragment shader from the provided example, <code class="literal">ch03_01_goraud_lambert.html</code>:</p><div class="mediaobject"><img src="/graphics/9781788629690/graphics/a9aef1ff-a29d-4f72-83c9-63a9981fa99f.png" /></div><p>Here's the vertex shader:</p><pre class="programlisting">#version 300 es
precision mediump float;

uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;
uniform mat4 uNormalMatrix;
uniform vec3 uLightDirection;
uniform vec3 uLightDiffuse;
uniform vec3 uMaterialDiffuse;

in vec3 aVertexPosition;
in vec3 aVertexNormal;

out vec4 vVertexColor;

void main(void) {
  // Calculate the normal vector
  vec3 N = normalize(vec3(uNormalMatrix * vec4(aVertexNormal, 1.0)));
  // Normalized light direction
  vec3 L = normalize(uLightDirection);
  // Dot product of the normal product and negative light direction vector
  float lambertTerm = dot(N, -L);
  // Calculating the diffuse color based on the Lambertian reflection model
  vec3 Id = uMaterialDiffuse * uLightDiffuse * lambertTerm;
  vVertexColor = vec4(Id, 1.0);
  // Setting the vertex position
  gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aVertexPosition, 1.0);
}</pre><p>Here's the fragment shader:</p><pre class="programlisting">#version 300 es
precision mediump float;

// Expect the interpolated value fro, the vertex shader
in vec4 vVertexColor;

// Return the final color as fragColor
out vec4 fragColor;

void main(void)  {
  // Simply set the value passed in from the vertex shader
  fragColor = vVertexColor;
}</pre><p>We can see that the final vertex color that we processed in the vertex shader is carried into a varying variable to the fragment shader. Remember that the value that arrives to the <span>fragment</span><a id="id325617282" class="indexterm"></a> shader is <span class="emphasis"><em>not</em></span> the original value that we calculated in the vertex shader. The <span>fragment</span><a id="id325617293" class="indexterm"></a> shader interpolates the <code class="literal">vVertexColor</code> variable to generate a final color for the respective fragment. This interpolation takes into account the vertices that enclose the current fragment.</p></div></div>