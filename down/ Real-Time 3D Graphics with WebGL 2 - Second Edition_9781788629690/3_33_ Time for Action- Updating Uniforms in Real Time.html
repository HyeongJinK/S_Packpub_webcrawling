<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec42"></a>Time for Action: Updating Uniforms in Real Time</h2></div></div><hr /></div><p>Let's cover an <span>example</span><a id="id325357458" class="indexterm"></a> of how we'd update shader uniforms interactively:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Open the <code class="literal">ch03_01_goraud_lambert.html</code> file in your browser:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788629690/graphics/9289c33e-81f5-4914-a790-f3808e36aeb5.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Notice that in this example, the controls<span class="emphasis"><em> </em></span>widget is at the top right of the page. If you're curious about how it works, you can check the <code class="literal">initControls</code> function inside of the example code.</li></ol></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note45"></a>Note</h3><p><strong class="userinput"><code>The Settings Widget</code></strong><span class="strong"><strong></strong></span>The settings widget was created using <span class="strong"><strong>DatGui</strong></span>, an open source library. While we won't cover the intuitive DatGui API, it may be useful to read the documentation and the code in the provided examples to see how it works. For more information, you can check out <a class="ulink" href="https://github.com/dataarts/dat.gui" target="_blank">https://github.com/dataarts/dat.gui.</a></p></div><p></p><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li><span class="strong"><strong>Translate X, Y, Z</strong></span>: These<span class="strong"><strong> </strong></span>control the direction of the light. By changing these sliders, you will modify the <code class="literal">uLightDirection</code> uniform:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788629690/graphics/6797ae44-dff3-4987-b8cb-1b18acd80a75.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li><span class="strong"><strong>Sphere Color</strong></span>: This changes the <code class="literal">uMaterialDiffuse</code> uniform, which represents the diffuse color of the sphere. Here, you use the color selection widget, which allows you to try different colors. <code class="literal">onChange</code> of <code class="literal">Sphere Color</code> in the <code class="literal">initControls</code> function receives the updates from the widget and updates the <code class="literal">uMaterialDiffuse</code> uniform.</li><li><span class="strong"><strong>Light Diffuse Color</strong></span>: This changes the <code class="literal">uLightDiffuse</code> uniform, which represents the diffuse color of the light source. There is no reason why the light color must be white. We achieve this by assigning the slider value to the RGB components of <code class="literal">uLightDiffuse</code> while we keep the alpha channel set to <code class="literal">1.0</code>. We do this inside the <code class="literal">onChange</code> function under the lights settings, which receives the slider updates.</li><li>Try different settings for the light source position, the diffuse material, and light properties.</li></ol></div><p><span class="emphasis"><em><span class="strong"><strong>What just happened?</strong></span></em></span></p><p>We’ve seen an <span>example</span><a id="id325659868" class="indexterm"></a> of a simple scene illuminated using Goraud interpolation and a Lambertian reflection model. We have also seen the immediate effects of changing uniform values for the Lambertian lighting model.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec55"></a>Have a Go: Moving Light</h3></div></div></div><p>We mentioned before that we use matrices to <span>move</span><a id="id325659883" class="indexterm"></a> the camera around the scene. We can also use matrices to move lights. To do this, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Open <code class="literal">ch03_02_moving-light.html</code> in your editor. The vertex shader is very similar to the previous diffuse model example. However, there is one extra line:</li></ol></div><pre class="programlisting">vec3 light = vec3(uModelViewMatrix * vec4(uLightDirection, 0.0));</pre><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Here, we are transforming the <code class="literal">uLightDirection</code> vector and assigning it to the <code class="literal">light</code> variable. Notice that the <code class="literal">uLightDirection</code> uniform is a vector with three components (<code class="literal">vec3</code>) and that the <code class="literal">uModelViewMatrix</code> is a 4x4 matrix. In order to complete the multiplication, we need to transform this uniform into a four-component vector (<code class="literal">vec4</code>). We achieve this with the following construct:</li></ol></div><pre class="programlisting">vec4(uLightDirection, 0.0);</pre><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>The <code class="literal">uModelViewMatrix</code> matrix contains the <span class="emphasis"><em>Model-View transformation matrix</em></span>. We will see how all this works in <a class="link" href="#" linkend="ch04">Chapter 4</a>, <span class="emphasis"><em>Cameras</em></span>. For now, suffice to say that this matrix allows us to update vertices’ positions, and in this example, the light's position as well.</li><li>Take another look at the vertex shader. In this example, we are rotating the sphere and the light. Every time the <code class="literal">draw</code> function is invoked, we rotate the <code class="literal">modelViewMatrix</code> matrix a little bit on the y-axis:</li></ol></div><pre class="programlisting">mat4.rotate(modelViewMatrix, modelViewMatrix, angle * Math.PI / 180, [0, 1, 0]);</pre><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>If you examine the code more closely, you will notice that the <code class="literal">modelViewMatrix</code> matrix is mapped to the <code class="literal">uModelViewMatrix</code> uniform:</li></ol></div><pre class="programlisting">gl.uniformMatrix4fv(program.uModelViewMatrix, false, modelViewMatrix);</pre><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>Run the example in your browser. You will see a sphere and a light source rotating on the y-axis:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788629690/graphics/e6289e69-c1a7-4fb4-bb58-ba6570721fb5.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="7" type="1"><li>Look for the <code class="literal">initLights</code> function and change the light orientation so that the light is pointing in the negative z-axis direction:</li></ol></div><pre class="programlisting">gl.uniform3f(program.uLightDirection, 0, -1, -1);</pre><div class="orderedlist"><ol class="orderedlist arabic" start="8" type="1"><li>Save the file and run it again. What happened? Change the light direction uniform so that it points to <code class="literal">[-1, 0, 0]</code>. Save the file and run it again on your browser. What happened? You should see that changing these values manipulates the light's orientation.</li><li>Set the light back to the 45-degree angle<span class="emphasis"><em> </em></span>by changing the <code class="literal">uLightDirection</code> uniform so that it returns to its initial value:</li></ol></div><pre class="programlisting">gl.uniform3f(program.uLightDirection, 0, -1, -1);</pre><div class="orderedlist"><ol class="orderedlist arabic" start="10" type="1"><li>Go to <code class="literal">draw</code> and find the following line:</li></ol></div><pre class="programlisting">mat4.rotate(modelViewMatrix, modelViewMatrix, angle * Math.PI / 180, [0, 1, 0]);</pre><div class="orderedlist"><ol class="orderedlist arabic" start="11" type="1"><li>Change it to this:</li></ol></div><pre class="programlisting">mat4.rotate(modelViewMatrix, modelViewMatrix, angle * Math.PI / 180, [1, 0, 0]);
</pre><div class="orderedlist"><ol class="orderedlist arabic" start="12" type="1"><li>Save the file and launch it again in your browser. What happens? You should notice that the light moves on a different axis.</li></ol></div><p><span class="emphasis"><em><span class="strong"><strong>What just happened?</strong></span></em></span></p><p>As you can see, the <span>vector</span><a id="id325359500" class="indexterm"></a> that is passed as the third argument to <code class="literal">mat4.rotate</code> determines the axis of the rotation. The first component corresponds to the x-axis, the second to the y-axis, and the third to the z-axis.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec56"></a>Goraud Shading with Phong Reflections</h3></div></div></div><p>Different from the Lambertian reflection model, the Phong reflection model <span>considers</span><a id="id325359554" class="indexterm"></a> three properties: the ambient, diffuse, and specular, and <span>ultimately</span><a id="id325359562" class="indexterm"></a> yields a more <span>realistic</span><a id="id325359571" class="indexterm"></a> reflection. Following the same analogy that we used in the previous section, consider the following example:</p><pre class="programlisting">finalVertexColor = Ia + Id + Is;</pre><p>Where:</p><pre class="programlisting">Ia = lightAmbient * materialAmbient;
Id = lightDiffuse * materialDiffuse * lambertCoefficient;
Is = lightSpecular * materialSpecular * specularCoefficient;</pre><p>Notice that:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">As we use Goraud interpolation, we still use vertex normals to calculate the diffuse term. This will change when using Phong interpolation, where we will use fragment normals.</li><li style="list-style-type: disc">Both light and material have three properties: the ambient, diffuse, and specular<span class="emphasis"><em> </em></span>colors.</li><li style="list-style-type: disc">On these equations, we can see that <code class="literal">Ia</code>, <code class="literal">Id</code>, and <code class="literal">Is</code> receive contributions from their respective light and material properties.</li></ul></div><p>Based on our knowledge of the Phong reflection model, let's see how to calculate the specular coefficient in ESSL:</p><pre class="programlisting">float specular = pow(max(dot(lightReflection, eyeVector), 0.0), shininess);</pre><p>Where:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">eyeVector</code> is the view vector or camera vector</li><li style="list-style-type: disc"><code class="literal">lightReflection</code> is the reflected light vector</li><li style="list-style-type: disc"><code class="literal">shininess</code> is the specular exponential factor or shininess</li><li style="list-style-type: disc"><code class="literal">lightReflection</code> is calculated as <code class="literal">lightReflection = reflect(lightDirection, normal);</code></li><li style="list-style-type: disc"><code class="literal">normal</code> is the vertex normal, and <code class="literal">lightDirection</code> is the light direction that we have been using to calculate the Lambert coefficient</li></ul></div><p>Let's take a look at the ESSL implementation for the vertex and fragment shaders. Here's the vertex shader:</p><pre class="programlisting">#version 300 es
precision mediump float;

uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;
uniform mat4 uNormalMatrix;
uniform vec3 uLightDirection;
uniform vec4 uLightAmbient;
uniform vec4 uLightDiffuse;
uniform vec4 uMaterialDiffuse;

in vec3 aVertexPosition;
in vec3 aVertexNormal;

out vec4 vVertexColor;

void main(void) {
vec3 N = vec3(uNormalMatrix * vec4(aVertexNormal, 1.0));
vec3 light = vec3(uModelViewMatrix * vec4(uLightDirection, 0.0));
vec3 L = normalize(light);
float lambertTerm = dot(N,-L);
vec4 Ia = uMaterialDiffuse * uLightAmbient;
vec4 Id =  uMaterialDiffuse * uLightDiffuse * lambertTerm;
vVertexColor = vec4(vec3(Ia + Id), 1.0);
gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aVertexPosition, 1.0);
}</pre><p>We can obtain negative dot products for the Lambert term when the geometry of our objects is concave or when the object is in the way between the <span>light</span><a id="id325359667" class="indexterm"></a> source and our point of view. In either case, the negative of the light-direction vector and the normals will <span>form</span><a id="id325359675" class="indexterm"></a> an obtuse angle, producing a negative dot product, as shown in the following diagram:</p><div class="mediaobject"><img src="/graphics/9781788629690/graphics/a0534565-9c1f-48be-94e6-3bc3a1640ade.png" /></div><p>For that reason, we are using the ESSL built-in clamp function to restrict the dot product to the positive range. If we obtain a negative dot product, the clamp function will set the lambert term to zero and the respective diffuse contribution will be discarded, generating the correct result.</p><p>Given that we are still using Goraud interpolation, the fragment shader is the same as before:</p><pre class="programlisting">#version 300 es
precision mediump float;

in vec4 vVertexColor;

out vec4 fragColor;

void main(void)  {
  fragColor = vVertexColor;
}</pre><p>In the next section, we <span>will</span><a id="id325358990" class="indexterm"></a> explore the <span>scene</span><a id="id325358999" class="indexterm"></a> to see what it looks like when we have negative Lambert coefficients that have been clamped to the <code class="literal">[0,1]</code> range.</p></div></div>