<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec75"></a>Optimization Strategies</h2></div></div><hr /></div><p>If you play around a little bit and <span>increase</span><a id="id325358908" class="indexterm"></a> the value of the <code class="literal">ballsCount</code> global constant from <code class="literal">50</code> to <code class="literal">500</code>, you will start to notice that the frame rate degrades:</p><div class="mediaobject"><img src="/graphics/9781788629690/graphics/552c2bad-f0ff-4765-8398-e7c7f2995046.png" /></div><p>In the preceding screenshot, the rendering hovered roughly around <code class="literal">30</code> frames per second. Depending on your computer, the average time for the <code class="literal">draw</code> function can be higher than the frequency at which the animation timer callback is invoked. This will result in dropped frames. To correct this, we need to make the <code class="literal">draw</code> function faster. Let's see a couple of strategies to do this.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec99"></a>Optimizing Batch Performance</h3></div></div></div><p>WebGL 2 adds some <span>interesting</span><a id="id325358957" class="indexterm"></a> features, such as <span class="strong"><strong>geometry-instancing.</strong></span> This feature allows us to render the same instance of a single mesh with differing shader attributes using <span class="strong"><strong>instancing</strong></span> and only one <code class="literal">render</code> call. Though instancing is limited, as it’s based on the same mesh only, it’s still a great way to improve <span>performance</span><a id="id325617256" class="indexterm"></a> if you have to draw the same meshes multiple times, especially if combined with shaders. While this functionality is provided in WebGL 2, we'll build our own geometry-optimization techniques for educational purposes. We will cover WebGL 2's geometry instancing feature in <a class="link" href="#" linkend="ch11">Chapter 11</a>, <span class="emphasis"><em>WebGL 2 Highlights</em></span>.</p><p>How do we optimize our scene <span>without</span><a id="id325617274" class="indexterm"></a> using the WebGL 2 geometry-instancing API? We can use geometry-caching as a way to optimize the animation of a scene full of similar objects. This is the case in the bouncing balls example. Each bouncing ball has a different position and color. These features are unique and independent for each ball. However, all of the balls share the same geometry.</p><p>In the <code class="literal">load</code> function, for <code class="literal">ch05_03_bouncing-balls.html</code>, we created <code class="literal">50</code> vertex buffer objects (VBOs) for each ball. Additionally, the same geometry is loaded <code class="literal">50</code> times, and on every rendering loop (<code class="literal">draw</code> function), a different VBO is bound, despite the geometry being the same for all the balls!</p><p>In <code class="literal">ch05_04_bouncing-balls-optimized.html</code>, we modified the <code class="literal">load</code> and <code class="literal">draw</code> functions to handle geometry-caching. In the first place, the geometry is loaded just once (<code class="literal">load</code> function):</p><pre class="programlisting">function load() {
  scene.add(new Floor(80, 2));
scene.add(new Axis(82));
scene.load('/common/models/geometries/ball.json', 'ball');
}</pre><p>Second, when the object with the <code class="literal">'ball'</code> alias is the current object in the rendering loop (the <code class="literal">draw</code> function), the <code class="literal">drawBalls</code> delegate function is invoked. This function sets some of the uniforms that are common to all bouncing balls (so that we do not waste time passing them every time to <code class="literal">program</code> for every ball). After that, the <code class="literal">drawBall</code> function is invoked. This function will set up those elements that are unique for each ball. In our case, we set up the <code class="literal">program</code> uniform that corresponds to the ball color and the Model-View matrix, which is unique for each ball because of the local transformation (ball position):</p><div class="mediaobject"><img src="/graphics/9781788629690/graphics/df143c28-27e6-4ea0-92c0-36b7e6b1198c.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec100"></a>Performing Translations in the Vertex Shader</h3></div></div></div><p>If you take a look at the code in <code class="literal">ch05_04_bouncing-balls-optimized.html</code>, you will see that we have taken an extra step to cache the Model-View matrix.</p><p>The basic idea <span>behind</span><a id="id325631876" class="indexterm"></a> this is to transfer the original matrix to the GPU (global) once and then perform the translation for each ball (local) inside the vertex shader. This change <span>significantly</span><a id="id325631884" class="indexterm"></a> improves the performance because of the parallel nature of the vertex shader.</p><p>This is what we do, step by step:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Create a new uniform that tells the vertex shader whether it should perform a translation (<code class="literal">uTranslate</code>).</li><li>Create a new uniform that contains the ball position for each ball (<code class="literal">uTranslation</code>).</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>Map these two new uniforms to JavaScript variables (we do this in the <code class="literal">configure</code> function):</li></ol></div><pre class="programlisting">// Create program variable that maps the uniform uTranslation
gl.uniform3fv(program.uTranslation, [0, 0, 0]);

// Create program variable that maps the uniform uTranslate
gl.uniform1i(program.uTranslate, false);</pre><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>Perform the translation inside the vertex shader. This part is probably the trickiest part since it requires a little bit of ESSL programming:</li></ol></div><pre class="programlisting">// Transformed vertex position
vec3 vecPosition = aVertexPosition;
if (uTranslate) {
  vecPosition += uTranslation;
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>In this code fragment, we are defining <code class="literal">vecPosition</code>, a variable of the <code class="literal">vec3</code> type. If the <code class="literal">uTranslate</code> uniform is <code class="literal">true</code> (meaning we are trying to render a bouncing ball), then we update <code class="literal">vecPosition</code> with the translation. This is implemented using vector-addition.</li><li>Make sure that the transformed vertex carries the translation in case of having one, so the following line looks like this:</li></ol></div><pre class="programlisting">vec4 vertex = uModelViewMatrix * vec4(vecPosition, 1.0);</pre><div class="orderedlist"><ol class="orderedlist arabic" start="7" type="1"><li>In <code class="literal">drawBall</code>, pass the current ball position as the content for the <code class="literal">uTranslation</code> uniform:</li></ol></div><pre class="programlisting">gl.uniform3fv(program.uTranslation, ball.position);</pre><div class="orderedlist"><ol class="orderedlist arabic" start="8" type="1"><li>In <code class="literal">drawBalls</code>, set the <code class="literal">uTranslate</code> uniform to <code class="literal">true</code>:</li></ol></div><pre class="programlisting">gl.uniform1i(program.uTranslate, true);</pre><div class="orderedlist"><ol class="orderedlist arabic" start="9" type="1"><li>In <code class="literal">draw</code>, pass the Model-View matrix once for all balls by using the following line of code:</li></ol></div><pre class="programlisting">transforms.setMatrixUniforms();</pre><div class="orderedlist"><ol class="orderedlist arabic" start="10" type="1"><li>Increase the <code class="literal">ballsCount</code> global variable from <code class="literal">50</code> to <code class="literal">500</code> and watch how the application continues to perform reasonably well, regardless of the increased scene complexity. The improvement in execution times is shown in the following screenshot:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788629690/graphics/c4060c75-65cc-4f5b-89b9-bce064bf9729.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="11" type="1"><li>After these optimizations, the example runs at a smooth <code class="literal">60</code> frames per second. The optimized source code is available at <code class="literal">ch05_bouncing-balls-optimized.html</code>.</li></ol></div></div></div>