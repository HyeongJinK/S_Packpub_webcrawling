<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec103"></a>Time for Action: Using Multi-Texturing</h2></div></div><hr /></div><p>Let's cover an <span>example</span><a id="id325358908" class="indexterm"></a> of multi-texturing in action:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Open the <code class="literal">ch07_05_multi-texture.html</code> file with your editor.</li><li>At the top of the script block, add another texture variable:</li></ol></div><pre class="programlisting">let texture2;</pre><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>At the bottom of the <code class="literal">configure</code> function, add the code to load the second texture. We're using a class to make this process easier, so the new code is as follows:</li></ol></div><pre class="programlisting">texture2 = new Texture();
texture2.setImage('/common/images/light.png');</pre><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>The texture we're using is a white radial gradient that simulates a spot light:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788629690/graphics/92d7874a-370e-4e51-a9ed-1348603fbc88.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>In the <code class="literal">render</code> function, directly below the code that binds the first texture, add the following to expose the new texture to the shader:</li></ol></div><pre class="programlisting">gl.activeTexture(gl.TEXTURE1);
gl.bindTexture(gl.TEXTURE_2D, texture2.tex);
gl.uniform1i(program.uSampler2, 1);</pre><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>We need to add the new sampler uniform to the fragment shader:</li></ol></div><pre class="programlisting">uniform sampler2D uSampler2;</pre><div class="orderedlist"><ol class="orderedlist arabic" start="7" type="1"><li>Don't forget to add the corresponding string to the uniforms list in the <code class="literal">configure</code> function.</li><li>We add the code to sample the new texture value and blend it with the first texture. Since we want the second texture to simulate a light, we multiply the two values together as we did with the per-vertex lighting in the first texture example:</li></ol></div><pre class="programlisting">fragColor = texture(uSampler2, vTextureCoords) * texture(uSampler, vTextureCoords);</pre><div class="orderedlist"><ol class="orderedlist arabic" start="9" type="1"><li>Note that we're re-using the same texture coordinate for both textures. This is more convenient but, if needed, a second texture coordinate attribute could be provided or we could calculate a new texture coordinate from the vertex position or some other criteria.</li><li>You should see a scene that looks like this when you open the file in your browser:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788629690/graphics/5357f44c-b7a0-4fff-80ab-3aab6ac2de70.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="11" type="1"><li>You can see the <span>completed</span><a id="id325647150" class="indexterm"></a> example in <code class="literal">ch07_06_multi-texture-final.html</code>.</li></ol></div><p><span class="emphasis"><em><span class="strong"><strong>What just happened?</strong></span></em></span></p><p>We've added a second texture to the <code class="literal">render</code> call and blended it with the first to create a new effect, which, in this case, simulates a simple static spotlight.</p><p>It's important to realize that the colors sampled from a texture are treated like any other color in the shaderâ€”that is, as a generic 4-dimensional vector. As a result, we can combine textures just as we would combine vertex and light colors, or any other color manipulation.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec130"></a>Have a Go: Moving Beyond Multiply</h3></div></div></div><p>Multiplication is one of the most <span>common</span><a id="id325647210" class="indexterm"></a> ways to blend colors in a shader, but there's really no limit to how you can combine color values. Try experimenting with different algorithms in the fragment shader to see what effect it has on the output. What happens when you add values instead of multiply? What if you use the red channel from one texture and the blue and green from the other? Try out the following algorithm and see what the result is:</p><pre class="programlisting">fragColor = vec4(texture(uSampler2, vTextureCoords).rgb - texture(uSampler, vTextureCoords).rgb, 1.0);</pre><p>The result is as follows:</p><div class="mediaobject"><img src="/graphics/9781788629690/graphics/3aa8f7f9-772c-4493-9335-d04164f68e5c.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec131"></a>Have a Go: Using Multi-Dimensional Textures</h3></div></div></div><p>As you may have noticed, the <span>challenges</span><a id="id325652533" class="indexterm"></a> in maintaining <span>multiple</span><a id="id325652541" class="indexterm"></a> textures resembles the same challenges we faced in <a class="link" href="#" linkend="ch06">Chapter 6</a>, <span class="emphasis"><em>Colors, Depth Testing, and Alpha Blending,</em></span> in managing multiple lights. That being said, does WebGL provide a similar feature as uniform arrays for managing multiple textures? Yes, of course! We can <span>leverage</span><a id="id325656620" class="indexterm"></a> two different solutions that WebGL 2 provides for <span>managing</span><a id="id325656665" class="indexterm"></a> multi-dimensional textures: <span class="strong"><strong>3D textures</strong></span> and <span class="strong"><strong>texture arrays</strong></span>.</p><p>Although, we will discuss these features in <a class="link" href="#" linkend="ch11">Chapter 11</a>, <span class="emphasis"><em>WebGL 2 Highlights,</em></span> it may be useful to think about how these features can be useful in reducing complexity, improving code maintainability, and increasing the number of textures that can be used.</p></div></div>