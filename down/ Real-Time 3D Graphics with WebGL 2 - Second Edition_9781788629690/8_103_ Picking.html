<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec107"></a>Picking</h2></div></div><hr /></div><p>Virtually any 3D computer-graphics <span>application</span><a id="id325358908" class="indexterm"></a> needs to provide mechanisms for the user to interact with the scene. For instance, in a game, you may want to point at your target and perform an action upon it. Or in a CAD system, you may want to be able to select an object in your scene and modify its properties. In this chapter, we’ll learn the basics of <span>implementing</span><a id="id325358921" class="indexterm"></a> these kinds of interactions in WebGL.</p><p>To start, we should point out that we can select objects by casting a ray (vector) from the camera position (also known as the eye position) into the scene and calculate the objects that lie along its path. This is known as <span class="strong"><strong>ray-casting</strong></span> and involves detecting intersections between the ray and object surfaces in the scene.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note75"></a>Note</h3><p><span class="strong"><strong><strong class="userinput"><code>Ray-Casting</code></strong></strong></span>
Ray-casting is the use of ray–surface intersection tests to solve a variety of problems in computer graphics and computational geometry. The term was first used in computer graphics in a 1982 paper by Scott Roth to describe a method for rendering constructive solid geometry models. If you're interested in learning more, check out <a class="ulink" href="https://en.wikipedia.org/wiki/Ray_casting" target="_blank">https://en.wikipedia.org/wiki/Ray_casting</a>.</p></div><p>That being said, in this chapter, we’ll implement picking <span>based</span><a id="id325617370" class="indexterm"></a> on object colors in an offscreen framebuffer, as it is a simpler and more foundational technique to help you understand how to interact with objects in a 3D application. If you're interested in ray-casting, you’ll find a section dedicated to this technique in <a class="link" href="#" linkend="ch10">Chapter 10</a>, <span class="emphasis"><em>Advanced Techniques</em></span>.</p><p>The basic idea behind picking is to assign a different identifier to every object in the scene and render the scene to an offscreen framebuffer. We will start by identifying objects with a unique color. When the user clicks on <code class="literal">canvas</code>, we go to the offscreen framebuffer and read the color of the pixel at the location of the click action. Since we assigned a unique color to each object in the offscreen buffer, we can use this color to <span>identify</span><a id="id325628652" class="indexterm"></a> the object that has been selected and perform an action upon it. The following diagram illustrates this concept:</p><div class="mediaobject"><img src="/graphics/9781788629690/graphics/1efb4114-3b7a-46dd-ac26-423c6e841119.png" /></div><p>An interesting example that may help explain picking is Duck Hunt, the popular Nintendo game from the 90s, where players used a physical plastic gun controller to hunt ducks:</p><div class="mediaobject"><img src="/graphics/9781788629690/graphics/e89eee5a-ba37-4294-91f8-6d96b114652d.png" /></div><p>Can you guess how the game <span>determined</span><a id="id325631893" class="indexterm"></a> whether the player hit a duck? That's right, picking! When the player points at a duck and pulls the trigger, the computer in the NES blacks out the screen and the Zapper diode in the gun begins reception. Then, the computer flashes a solid white block around the targets you’re supposed to be shooting at. The photodiode in the Zapper detects the change in light intensity and tells the computer that it’s pointed at a lit target block—in other words, you should receive a point because you hit the target. Of course, when you’re playing the game, you don’t notice the blackout and the targets flashing because it all happens in a fraction of a second. Pretty clever, right?</p><p>Let's break down the steps for implementing our own form of picking in WebGL.</p></div>