<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec49"></a>Time for Action: Positional Lights in Action</h2></div></div><hr /></div><p>Let's cover an <span>example</span><a id="id325358908" class="indexterm"></a> of positional lights in action:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Open the <code class="literal">ch03_07_positional_lighting.html</code> file in your browser. The page will look similar to the following screenshot:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788629690/graphics/f2378694-a372-46f1-b7bc-8a5375488420.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>The interface of this exercise is very simple. You can use the controls widget to interact with the scene. Unlike in previous exercises, the <span class="strong"><strong>Translate X</strong></span>, <span class="strong"><strong>Y</strong></span>, and <span class="strong"><strong>Z</strong></span> sliders do not represent light direction here. Instead, they allow us to set the light source position. Go ahead and play with them.</li><li>For clarity, a little sphere representing the position of the light source has been added to the scene to visualize the light source, but this is not generally required.</li><li>What happens when the light source is located on the surface of the cone versus on the surface of the sphere?</li><li>What happens when the light source is inside the sphere?</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>Let's take a look at the way we calculate the light rays by inspecting the vertex shader in the source code. The light ray calculation is performed in the following two lines of code:</li></ol></div><pre class="programlisting">vec4 light = uModelViewMatrix * vec4(uLightPosition, 1.0);
vLightRay = vertex.xyz - light.xyz;</pre><div class="orderedlist"><ol class="orderedlist arabic" start="7" type="1"><li>The first line allows us to obtain a transformed light position by multiplying the Model-View<span class="emphasis"><em> </em></span>matrix by the <code class="literal">uLightPosition</code> uniform. If you review the code in the vertex shader, you’ll note that we also use this matrix for calculating transformed vertices and normals. We will discuss these matrix operations in <a class="link" href="#" linkend="ch04">Chapter 4</a>, <span class="emphasis"><em>Cameras</em></span>. For now, we can just assume that this is necessary to obtain transformed vertices, normals, and light positions whenever we move the camera. To test this, modify this line by removing the matrix from the equation so that the line looks like the following:</li></ol></div><pre class="programlisting">vec4 light = vec4(uLightPosition, 1.0);</pre><div class="orderedlist"><ol class="orderedlist arabic" start="8" type="1"><li>Save the file and launch it in your browser. What is the effect of not transforming the light position? What you can see is that the camera is moving, but the light source position is not being updated!</li><li>We can see that the light ray is calculated as the vector that reaches from the transformed light position (light) to the vertex position.</li></ol></div><p>Thanks to the interpolation of varyings <span>that</span><a id="id325617369" class="indexterm"></a> is provided by ESSL, we automatically obtain all the light rays per pixel in the fragment shader:</p><div class="mediaobject"><img src="/graphics/9781788629690/graphics/7fbf4c2b-6f6f-4d01-8158-7b4f78d91ff2.png" /></div><p><span class="emphasis"><em><span class="strong"><strong>What just happened?</strong></span></em></span></p><p>We studied the difference between directional lights and positional lights. We also investigated the importance of the Model-View matrix for the correct calculation of positional lights when the camera is moving. Finally, we modeled the procedure to obtain per-vertex light rays.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec60"></a>Virtual Showroom Example</h3></div></div></div><p>In this chapter, we’ve included an <span>example</span><a id="id325631870" class="indexterm"></a> of the Nissan GTR exercise we saw in <a class="link" href="#" linkend="ch02">Chapter 2</a>, <span class="emphasis"><em>Rendering</em></span>. This time, we’ve used a Phong lighting model with a positional light to illuminate the scene. You can find this example in <code class="literal">ch03_08_showroom.html</code>:</p><div class="mediaobject"><img src="/graphics/9781788629690/graphics/9f1aaa43-31df-42f3-897c-73cd3b8da78c.png" /></div><p>Here, you can experiment with different light positions. Pay special attention to the nice specular reflections you obtain thanks to the specularity property of the car and the shininess of the light.</p></div></div>