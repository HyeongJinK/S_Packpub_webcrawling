<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec26"></a>Time for Action: Rendering a Square</h2></div></div><hr /></div><p>Follow the <span>given</span><a id="id325357458" class="indexterm"></a> steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Open the <code class="literal">ch02_01_square.html</code> file in a code editor (ideally one that supports syntax highlighting).</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Examine the structure of this file with the help of the following diagram:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788629690/graphics/b2c23611-aff7-4b0d-a50c-c2fac314bf18.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>The web page contains the following:</li></ol></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">The <code class="literal">&lt;script id="vertex-shader" type="x-shader/x-vertex"&gt;</code> script contains the vertex shader code.</li><li style="list-style-type: disc">The <code class="literal">&lt;script id="fragment-shader" type="x-shader/x-fragment"&gt;</code> script contains the fragment shader code. We won't pay attention to these two scripts as they will be the main point of study in the next chapter. For now, simply notice that we have a fragment shader and a vertex shader.</li><li style="list-style-type: disc">The next script on our web page, <code class="literal">&lt;script type="text/javascript"&gt;</code>, contains all the JavaScript WebGL code that we will need. This script is divided into the following functions:</li></ul></div><pre class="programlisting">// Global variables that are set and used
// across the application
let gl,
program,
squareVertexBuffer,
squareIndexBuffer,
indices;</pre><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">We list a few global variables that we use throughout our application:</li></ul></div><pre class="programlisting">// Given an id, extract the content's of a shader script
// from the DOM and return the compiled shader
function getShader(id) {
const script = document.getElementById(id);
const shaderString = script.text.trim();

// Assign shader depending on the type of shader
let shader;
if (script.type === 'x-shader/x-vertex') {
    shader = gl.createShader(gl.VERTEX_SHADER);
}
else if (script.type === 'x-shader/x-fragment') {
    shader = gl.createShader(gl.FRAGMENT_SHADER);
}
else {
return null;
}

// Compile the shader using the supplied shader code
gl.shaderSource(shader, shaderString);
gl.compileShader(shader);

// Ensure the shader is valid
if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.error(gl.getShaderInfoLog(shader));
return null;
}

return shader;
}</pre><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">getShader</code> extracts the contents of a shader present in the HTML web page <span>given</span><a id="id325617277" class="indexterm"></a> its <code class="literal">id</code>:</li></ul></div><pre class="programlisting">// Create a program with the appropriate vertex and fragment shaders
function initProgram() {
const vertexShader = getShader('vertex-shader');
const fragmentShader = getShader('fragment-shader');

// Create a program
program = gl.createProgram();
// Attach the shaders to this program
gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);
gl.linkProgram(program);

if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error('Could not initialize shaders');
}

// Use this program instance
gl.useProgram(program);
// We attach the location of these shader values to the program 
  // instance for easy access later in the code
program.aVertexPosition = gl.getAttribLocation(program, 'aVertexPosition');
}</pre><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">initProgram</code> obtains a reference for the vertex shader and the fragment shader present in the web page (that is, the first two scripts that we discussed) and passes them along to the GPU to be compiled. Lastly, we attach the location of the <code class="literal">aVertexPosition</code> attribute to the <code class="literal">program</code> object so that it can be easily referenced later. Looking up <code class="literal">attribute</code> and <code class="literal">uniform</code> locations is expensive; therefore, such operations should happen once during initialization. We will cover these techniques in later chapters:</li></ul></div><pre class="programlisting">// Set up the buffers for the square
function initBuffers() {
/*
    V0                    V3
    (-0.5, 0.5, 0)        (0.5, 0.5, 0)
    X---------------------X
    |                     |
    |                     |
    |       (0, 0)        |
    |                     |
    |                     |
    X---------------------X
    V1                    V2
    (-0.5, -0.5, 0)       (0.5, -0.5, 0)
  */
const vertices = [
    -0.5, 0.5, 0,
-0.5, -0.5, 0,
0.5, -0.5, 0,
0.5, 0.5, 0
];

// Indices defined in counter-clockwise order
indices = [0, 1, 2, 0, 2, 3];

// Setting up the VBO
squareVertexBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), 
   gl.STATIC_DRAW);

// Setting up the IBO
squareIndexBuffer = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, squareIndexBuffer);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), 
   gl.STATIC_DRAW);

// Clean
gl.bindBuffer(gl.ARRAY_BUFFER, null);
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
}</pre><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">initBuffers</code> contains the API calls to create and initialize buffers, as we discussed earlier in this chapter. In this example, we create a VBO to store coordinates for the square and an IBO to store the indices of the square:</li></ul></div><pre class="programlisting">// We call draw to render to our canvas
function draw() {
// Clear the scene
gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

// Use the buffers we've constructed
gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexBuffer);
gl.vertexAttribPointer(program.aVertexPosition, 3, gl.FLOAT, 
   false, 0, 0);
gl.enableVertexAttribArray(program.aVertexPosition);

// Bind IBO
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, squareIndexBuffer);

// Draw to the scene using triangle primitives
gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 
   0);

// Clean
gl.bindBuffer(gl.ARRAY_BUFFER, null);
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
}</pre><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">draw</code> maps the VBO to the respective vertex buffer attribute, <code class="literal">program.aVertexPosition</code>, and enables it by calling <code class="literal">enableVertexAttribArray</code>. It then binds the IBO and calls the <code class="literal">drawElements</code> function. We will cover this in more detail in later chapters:</li></ul></div><pre class="programlisting">// Entry point to our application
function init() {
// Retrieve the canvas
const canvas = utils.getCanvas('webgl-canvas');

// Set the canvas to the size of the screen
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// Retrieve a WebGL context
gl = utils.getGLContext(canvas);
// Set the clear color to be black
gl.clearColor(0, 0, 0, 1);

// Call the functions in an appropriate order
initProgram();
initBuffers();
draw();
}</pre><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">init</code> is the entry point for the entire application. When the page has loaded, <code class="literal">init</code> is invoked via <code class="literal">window.onload = init</code>. It's important to note that the order of functions invoked inside of <code class="literal">init</code> are important to set up and render the geometry. We also set the canvas dimension to take the size of the entire window (fullscreen). As mentioned previously, in the <code class="literal">draw</code> function, we are using <code class="literal">canvas.width</code> and <code class="literal">canvas.height</code> as the source of truth for our <span>drawing</span><a id="id325659861" class="indexterm"></a> dimensions.
</li></ul></div><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>Open the <code class="literal">ch02_01_square.html</code> file in the HTML5 browser of your preference (Firefox, Safari, Chrome, or Opera), and you should see the following:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788629690/graphics/8144b134-e02a-487a-b288-cac6d48782df.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>Open up the code for <code class="literal">ch02_01_square.html</code> and scroll down to the <code class="literal">initBuffers</code> function. Please pay attention to the diagram that appears as a comment inside of the function. This diagram describes how the vertices and indices are organized. You should see something like the following:</li></ol></div><pre class="programlisting">/*
  V0                    V3
  (-0.5, 0.5, 0)        (0.5, 0.5, 0)
  X---------------------X
  |                     |
  |                     |
  |       (0, 0)        |
  |                     |
  |                     |
  X---------------------X
  V1                    V2
  (-0.5, -0.5, 0)       (0.5, -0.5, 0)
*/</pre><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>Try to modify the existing buffers to turn the square into a pentagon. How would you do this?</li></ol></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip21"></a>Note</h3><p><strong class="userinput"><code>Updating the Geometry</code></strong> <strong class="userinput"><code>Definition</code></strong>
Modify the vertex buffer array and index array so that the resulting figure is a pentagon instead of a square. To do this, you need to add one vertex to the vertex array and define one more triangle in the index array.</p></div><p></p><div class="orderedlist"><ol class="orderedlist arabic" start="7" type="1"><li>Save the file with a different name and open it in the HTML5 browser of your preference to test it.</li></ol></div><p><span class="emphasis"><em><span class="strong"><strong>What just happened?</strong></span></em></span></p><p>You have learned about the different code elements that conform to a WebGL app. The <code class="literal">initBuffers</code> function has been examined closely and modified to <span>render</span><a id="id325662139" class="indexterm"></a> a different geometry.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec29"></a>Have a Go: Changing the Square Color</h3></div></div></div><p>Go to the fragment <span>shader</span><a id="id325662154" class="indexterm"></a> and change the color of your geometry.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip22"></a>Note</h3><p><strong class="userinput"><code>Four-Component Color Vector</code></strong>
The format is (red, green, blue, alpha). Alpha is always <code class="literal">1.0</code> (for now), and the first three arguments are float numbers in the range of <code class="literal">0.0</code> to <code class="literal">1.0</code>.</p></div><p>Remember to save the file after making the changes in your text editor before opening it in your browser.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec30"></a>Have a Go: Rendering Using drawArrays</h3></div></div></div><p>Our square was <span>defined</span><a id="id325662190" class="indexterm"></a> using <code class="literal">drawElements</code> via vertices and indices. Go ahead and render the same square using <code class="literal">drawArrays</code>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip23"></a>Note</h3><p><strong class="userinput"><code>Hint</code></strong>
Given that you don't use indices with <code class="literal">drawArrays</code>, you won't need an <code class="literal">IBO</code>. So, you will need to duplicate vertices to construct this geometry.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip24"></a>Note</h3><p><strong class="userinput"><code>Hint</code></strong><span class="strong"><strong></strong></span> For reference, you can find the source code for this exercise in <code class="literal">ch02_02_square-arrays.html</code>.</p></div></div></div>