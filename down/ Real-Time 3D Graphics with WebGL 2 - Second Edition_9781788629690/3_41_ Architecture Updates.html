<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec50"></a>Architecture Updates</h2></div></div><hr /></div><p>Let's cover some useful functions that we can refactor to use in later chapters:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>We've seen how to create and compile a program using shaders. We've also covered how to load and reference attributes and uniforms. Let's include a module that abstracts away this low-level functionality with a simpler API:</li></ol></div><pre class="programlisting">&lt;script type="text/javascript" src="/common/js/Program.js"&gt;&lt;/script&gt;</pre><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Like we did previously, we will include this script tag in the <code class="literal">&lt;head&gt;</code> of the HTML document. Be sure to include it after the other module scripts, since they may use the libraries and earlier modules we've covered.</li><li>Let's update our <code class="literal">initProgram</code> function inside of <code class="literal">ch03_08_showroom.html</code> so that we can use this module:</li></ol></div><pre class="programlisting">function initProgram() {
const canvas = document.getElementById('webgl-canvas');
utils.autoResizeCanvas(canvas);

gl = utils.getGLContext(canvas);
gl.clearColor(...clearColor, 1);
gl.enable(gl.DEPTH_TEST);
gl.depthFunc(gl.LEQUAL);

program = new Program(gl, 'vertex-shader', 'fragment-shader');

const attributes = [
'aVertexPosition',
'aVertexNormal'
];

const uniforms = [
'uProjectionMatrix',
'uModelViewMatrix',
'uNormalMatrix',
'uLightAmbient',
'uLightPosition',
'uMaterialSpecular',
'uMaterialDiffuse',
'uShininess'
];

program.load(attributes, uniforms);
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>All of the heavy lifting of creating a program, compiling shaders, and attaching uniforms and attributes to our program is done for us.</li><li>Let's inspect the <code class="literal">Program</code> class source code. Most of the operations should look familiar to you:</li></ol></div><pre class="programlisting">'use strict';

/*
* Program constructor that takes a WebGL context and script tag IDs
* to extract vertex and fragment shader source code from the page
*/
class Program {

constructor(gl, vertexShaderId, fragmentShaderId) {
this.gl = gl;
this.program = gl.createProgram();

if (!(vertexShaderId &amp;&amp; fragmentShaderId)) {
return console.error('No shader IDs were provided');
}

    gl.attachShader(this.program, utils.getShader(gl, 
     vertexShaderId));
gl.attachShader(this.program, utils.getShader(gl, 
     fragmentShaderId));
gl.linkProgram(this.program);

if (!this.gl.getProgramParameter(this.program, 
     this.gl.LINK_STATUS)) {
return console.error('Could not initialize shaders.');
}

this.useProgram();
}

// Sets the WebGL context to use current program
useProgram() {
this.gl.useProgram(this.program);
}

// Load up the given attributes and uniforms from the given values
load(attributes, uniforms) {
this.useProgram();
this.setAttributeLocations(attributes);
this.setUniformLocations(uniforms);
}

// Set references to attributes onto the program instance
setAttributeLocations(attributes) {
    attributes.forEach(attribute =&gt; {
this[attribute] = this.gl.getAttribLocation(this.program, 
       attribute);
});
}

// Set references to uniforms onto the program instance
setUniformLocations(uniforms) {
    uniforms.forEach(uniform =&gt; {
this[uniform] = this.gl.getUniformLocation(this.program, 
       uniform);
});
}

// Get the uniform location from the program
getUniform(uniformLocation) {
return this.gl.getUniform(this.program, uniformLocation);
}

}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>We initialize <code class="literal">Program</code> by passing in a reference to the <code class="literal">gl</code> context, the vertex, and the fragment shader <code class="literal">id</code>.</li><li>We load and reference the <code class="literal">attributes</code> and <code class="literal">uniforms</code> programs by supplying the <code class="literal">program</code> instance with the array of attributes and uniforms.</li><li>The other methods are helper functions that we'll use in later chapters.</li><li>You can find an example of these changes in <code class="literal">ch03_09_showroom-final.html</code>.</li><li>You may have caught two additional utils methods used throughout this chapter: <code class="literal">normalizeColor</code> and <code class="literal">denormalizeColor</code>. These two methods simply normalize colors from range <code class="literal">[0-255]</code> to <code class="literal">[0-1]</code> or denormalize from <code class="literal">[0-1]</code> to <code class="literal">[0-255]</code>:</li></ol></div><pre class="programlisting">const utils = {

// Normalize colors from 0-255 to 0-1
normalizeColor(color) {
return color.map(c =&gt; c / 255);
},

// De-normalize colors from 0-1 to 0-255
denormalizeColor(color) {
return color.map(c =&gt; c * 255);
},

// ...  
};</pre></div>