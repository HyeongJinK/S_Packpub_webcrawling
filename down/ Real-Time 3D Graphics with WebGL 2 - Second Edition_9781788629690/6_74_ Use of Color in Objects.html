<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec80"></a>Use of Color in Objects</h2></div></div><hr /></div><p>As earlier chapters have addressed, the final color of a pixel is <span>assigned</span><a id="id325357458" class="indexterm"></a> in the fragment shader by setting an out ESSL variable. If all the fragments in the object have the same color, we can say the object has a constant color. Otherwise, the object is generally understood as having per-vertex color.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec104"></a>Constant Coloring</h3></div></div></div><p>To obtain a constant color, we store the desired color in a <span>uniform</span><a id="id325358941" class="indexterm"></a> that is passed to the <span>fragment</span><a id="id325358950" class="indexterm"></a> shader. This uniform is usually called the object's <span class="strong"><strong>diffuse material property</strong></span>. We can also <span>combine</span><a id="id325358963" class="indexterm"></a> object normals and light-source information to obtain a Lambert coefficient. We can use the Lambert coefficient to proportionally change the reflecting color depending on the angle on which the light hits the object.</p><p>As the following diagram demonstrates, we lose depth perception when we do not use information about the normals to obtain a Lambert coefficient. Please note that we are using a diffusive lighting model:</p><div class="mediaobject"><img src="/graphics/9781788629690/graphics/cc42c4bd-fabe-446c-95b4-4d577ad90393.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec105"></a>Per-Vertex Coloring</h3></div></div></div><p>In medical and engineering <span>visualization</span><a id="id325617268" class="indexterm"></a> applications, it is common to find color maps that are associated with the vertices of the models we are rendering. These maps assign each vertex a color depending on its scalar value. An example of this idea includes the temperature charts that indicate cold temperatures as blue, and hot temperatures as red overlaid on a map.</p><p>To implement per-vertex coloring, we need to define an <span>attribute</span><a id="id325617278" class="indexterm"></a> that stores the color for the vertex in the vertex shader:</p><pre class="programlisting">in vec4 aVertexColor;</pre><p>The next step is to assign the <code class="literal">aVertexColor</code> attribute to a varying so that it can be passed to the fragment shader. Remember that varyings are automatically interpolated. Therefore, each fragment will have a color that is the weighted result of its contributing vertices.</p><p>If we want our color map to be sensitive to lighting conditions, we can multiply each vertex color by the diffuse component of the light. The result is then assigned to the varying that will transfer the result to the fragment shader.</p><p>The following diagram demonstrates two different possibilities for this case: on the left, the vertex color is multiplied by the light diffuse term without any weighting from the position of the light; on the right, the Lambert coefficient generates the expected shadows and gives information about the relative location of the light source:</p><div class="mediaobject"><img src="/graphics/9781788629690/graphics/ada6217d-df5d-4d1e-9860-d23ffa075f1d.png" /></div><p>Here, we are using a vertex buffer object that is mapped to the <code class="literal">aVertexColor</code> vertex shader attribute. We learned how to map VBOs in <a class="link" href="#" linkend="ch02">Chapter 2</a>, <span class="emphasis"><em>Rendering</em></span>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec106"></a>Per-Fragment Coloring</h3></div></div></div><p>We can also assign a <span>random</span><a id="id325643394" class="indexterm"></a> color to each pixel of the object we are rendering. Although ESSL does not have a pre-built random function, there are algorithms we can use to <span>generate</span><a id="id325643402" class="indexterm"></a> pseudo-random numbers. That being said, the purpose and usefulness of this technique are outside the scope of this book.</p></div></div>