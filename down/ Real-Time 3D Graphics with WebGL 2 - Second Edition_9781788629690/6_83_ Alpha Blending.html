<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec89"></a>Alpha Blending</h2></div></div><hr /></div><p>A fragment is <span>available</span><a id="id325358908" class="indexterm"></a> for alpha blending only if it has passed the depth test. By default, depth testing is disabled and makes all fragments available for alpha blending.</p><p>Alpha blending is enabled using the following line of code:</p><pre class="programlisting">gl.enable(gl.BLEND);</pre><p>For each available fragment, the alpha blending operation reads the color from the framebuffer by the appropriate fragment coordinates and creates a new color based on a linear interpolation between the previously calculated color in the fragment shader and the color from the framebuffer.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip66"></a>Note</h3><p><strong class="userinput"><code>Alpha Blending</code></strong>
Alpha blending is disabled by default in WebGL.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec115"></a>The Blending Function</h3></div></div></div><p>With blending enabled, the next step is to define a <span>blending</span><a id="id325617349" class="indexterm"></a> function. This function will determine how fragment colors from the object (source) are <span>combined</span><a id="id325617355" class="indexterm"></a> with the fragment colors present in the framebuffer (destination).</p><p>We combine source and destination colors as follows:</p><pre class="programlisting">color = S * sW + D * dW;</pre><p>More precisely:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">S</code>: Source color (vec4)</li><li style="list-style-type: disc"><code class="literal">D</code>: Destination color (vec4)</li><li style="list-style-type: disc"><code class="literal">sW</code>: Source scaling factor</li><li style="list-style-type: disc"><code class="literal">dW</code>: Destination scaling factor</li><li style="list-style-type: disc"><code class="literal">S.rgb</code>: RGB components of the source color</li><li style="list-style-type: disc"><code class="literal">S.a</code>: Alpha component of the source color</li><li style="list-style-type: disc"><code class="literal">D.rgb</code>: RGB components of the destination color</li><li style="list-style-type: disc"><code class="literal">D.a</code>: Alpha component of the destination color</li></ul></div><p>Itâ€™s important to note that the rendering order will determine the source and the destination fragments. Following the example from the previous section, if the sphere is rendered first, it will then become the destination of the blending operation because the sphere fragments are stored in the framebuffer at the time that the cone is rendered. In other words, alpha blending is a non-commutative operation with respect to rendering order:</p><div class="mediaobject"><img src="/graphics/9781788629690/graphics/305ff055-4395-477c-ba75-5a333c2dd601.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec116"></a>Separate Blending Functions</h3></div></div></div><p>It is also possible to determine how the RGB channels are going to be combined independently from the alpha channels. For that, we use the <code class="literal">gl.blendFuncSeparate</code> function.</p><p>We define two <span>independent</span><a id="id325628776" class="indexterm"></a> functions this way:</p><pre class="programlisting">color = S.rgb * sW.rgb + D.rgb * dW.rgb;
alpha = S.a * sW.a + D.a * dW.a;</pre><p>More precisely:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">sW.rgb</code>: Source scaling factor (only RGB)</li><li style="list-style-type: disc"><code class="literal">dW.rgb</code>: Destination scaling factor (only RGB)</li><li style="list-style-type: disc"><code class="literal">sW.a</code>: Source scaling factor for the source alpha value</li><li style="list-style-type: disc"><code class="literal">dW.a</code>: Destination scaling factor for the destination alpha value</li></ul></div><p>Then, we could have something such as the following:</p><pre class="programlisting">color = S.rgb * S.a + D.rbg * (1.0 - S.a);
alpha = S.a * 1.0 + D.a * 0.0;</pre><p>This would be translated into code as follows:</p><pre class="programlisting">gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ZERO);</pre><p>The parameters for the <code class="literal">gl.blendFuncSeparate</code> function are the same as <code class="literal">gl.blendFunc</code>. You can find more information on these functions later in this section.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec117"></a>The Blend Equation</h3></div></div></div><p>We could have a case where we do not want to <span>interpolate</span><a id="id325638052" class="indexterm"></a> the source and destination fragment colors with scale or add operations. For example, we may want to <span>subtract</span><a id="id325638060" class="indexterm"></a> one from the other. In this case, WebGL provides the <code class="literal">gl.blendEquation</code> function. This function receives one parameter that determines the operation on the scaled source and destination fragment colors. For example, <code class="literal">gl.blendEquation(gl.FUNC_ADD)</code> is calculated as such:</p><pre class="programlisting">color = S * sW + D * dW;</pre><p>And, <code class="literal">gl.blendEquation(gl.FUNC_SUBTRACT)</code> corresponds to the following:</p><pre class="programlisting">color = S * sW - D  * dW;</pre><p>There is a third option, <code class="literal">gl.blendEquation(gl.FUNC_REVERSE_SUBTRACT)</code>, that corresponds to the following:</p><pre class="programlisting">color = D* dw - S * sW;</pre><p>As expected, you can define the blending equation separately for the RGB channels and for the alpha channel. For that, we use the <code class="literal">gl.blendEquationSeparate</code> function.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec118"></a>The Blend Color</h3></div></div></div><p>WebGL provides the <code class="literal">gl.CONSTANT_COLOR</code> and <code class="literal">gl.ONE_MINUS_CONSTANT_COLOR</code> scaling factors. These scaling factors can be <span>used</span><a id="id325643410" class="indexterm"></a> with <code class="literal">gl.blendFunc</code> and <code class="literal">gl.blendFuncSeparate</code>. However, we <span>need</span><a id="id325628795" class="indexterm"></a> to first establish the blend color. We do so by invoking <code class="literal">gl.blendColor</code>.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec34"></a>WebGL Alpha-Blending API</h4></div></div></div><p>The following table <span>summarizes</span><a id="id325628811" class="indexterm"></a> the WebGL functions that are relevant to performing alpha-blending operations:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>WebGL function</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Description</strong></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">gl.enable|disable(gl.BLEND)</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Enable/disable blending.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">gl.blendFunc(sW, dW)</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Specify pixel arithmetic. Accepted values for <code class="literal">sW</code> and <code class="literal">dW</code> are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">ZERO</code></li><li style="list-style-type: disc"><code class="literal">ONE</code></li><li style="list-style-type: disc"><code class="literal">SRC_COLOR</code></li><li style="list-style-type: disc"><code class="literal">DST_COLOR</code></li><li style="list-style-type: disc"><code class="literal">SRC_ALPHA</code></li><li style="list-style-type: disc"><code class="literal">DST_ALPHA</code></li><li style="list-style-type: disc"><code class="literal">CONSTANT_COLOR</code></li><li style="list-style-type: disc"><code class="literal">CONSTANT_ALPHA</code></li><li style="list-style-type: disc"><code class="literal">ONE_MINUS_SRC_ALPHA</code></li><li style="list-style-type: disc"><code class="literal">ONE_MINUS_DST_ALPHA</code></li><li style="list-style-type: disc"><code class="literal">ONE_MINUS_SRC_COLOR</code></li><li style="list-style-type: disc"><code class="literal">ONE_MINUS_DST_COLOR</code></li><li style="list-style-type: disc"><code class="literal">ONE_MINUS_CONSTANT_COLOR</code></li><li style="list-style-type: disc"><code class="literal">ONE_MINUS_CONSTANT_ALPHA</code></li></ul></div><p>In addition, <code class="literal">sW</code> can also be <code class="literal">SRC_ALPHA_SATURATE</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">gl.blendFuncSeparate(sW_rgb, dW_rgb, sW_a, dW_a)</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Specify pixel arithmetic for RGB and alpha components separately.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">gl.blendEquation(mode)</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Specify the equation used for both the RGB blend equation and the alpha blend equation. Accepted values for mode are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">gl.FUNC_ADD</code></li><li style="list-style-type: disc"><code class="literal">gl.FUNC_SUBTRACT</code></li><li style="list-style-type: disc"><code class="literal">gl.FUNC_REVERSE_SUBTRACT</code></li></ul></div></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">gl.blendEquationSeparate(modeRGB, modeAlpha)</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Set the RGB blend equation and the alpha blend equation separately.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">gl.blendColor(red, green, blue, alpha)</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Set the blend color.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">gl.getParameter(name)</code></p></td><td style=""><p>Just like with other WebGL variables, it is possible to query blending parameters using <code class="literal">gl.getParameter</code>. Relevant parameters are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">gl.BLEND</code></li><li style="list-style-type: disc"><code class="literal">gl.BLEND_COLOR</code></li><li style="list-style-type: disc"><code class="literal">gl.BLEND_DST_RGB</code></li><li style="list-style-type: disc"><code class="literal">gl.BLEND_SRC_RGB</code></li><li style="list-style-type: disc"><code class="literal">gl.BLEND_DST_ALPHA</code></li><li style="list-style-type: disc"><code class="literal">gl.BLEND_SRC_ALPHA</code></li><li style="list-style-type: disc"><code class="literal">gl.BLEND_EQUATION_RGB</code></li><li style="list-style-type: disc"><code class="literal">gl.BLEND_EQUATION_ALPHA</code></li></ul></div></td></tr></tbody></table></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec119"></a>Alpha Blending Modes</h3></div></div></div><p>Depending on the <span>parameter</span><a id="id325629021" class="indexterm"></a> selection for <code class="literal">sW</code> and <code class="literal">dW</code>, we can create different blending modes. In this section, we will see how to create additive, subtractive, multiplicative, and interpolative blending modes. All blending modes are derived from the previous formula:</p><pre class="programlisting">color = S * (sW) + D * dW;</pre><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec35"></a>The Blending Function</h4></div></div></div><p>Additive <span>blending</span><a id="id325629048" class="indexterm"></a> simply adds the colors of the source and <span>destination</span><a id="id325629057" class="indexterm"></a> fragments, creating a lighter image. We obtain additive blending by writing the following:</p><pre class="programlisting">gl.blendFunc(gl.ONE, gl.ONE);</pre><p>This assigns the weights for source and destination fragments <code class="literal">sW</code> and <code class="literal">dW</code> to <code class="literal">1</code>. The color output will be as follows:</p><pre class="programlisting">color = S * 1.0 + D * 1.0;
color = S + D;</pre><p>Since each color channel is in the <code class="literal">[0, 1]</code> range, blending will clamp all values over <code class="literal">1</code>. When all channels are <code class="literal">1</code>, this results in a white color.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec36"></a>Subtractive Blending</h4></div></div></div><p>Similarly, we can <span>obtain</span><a id="id325629105" class="indexterm"></a> subtractive <span>blending</span><a id="id325629113" class="indexterm"></a> by writing the following:</p><pre class="programlisting">gl.blendEquation(gl.FUNC_SUBTRACT);
gl.blendFunc(gl.ONE, gl.ONE);</pre><p>This will change the blending equation to the following:</p><pre class="programlisting">color = S * 1.0 - D * 1.0;
color = S - D;</pre><p>All negative values will be set to <code class="literal">0</code>. When all channels are negative, the result is black.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec37"></a>Multiplicative Blending</h4></div></div></div><p>We <span>obtain</span><a id="id325629145" class="indexterm"></a> multiplicative <span>blending</span><a id="id325629154" class="indexterm"></a> by writing the following:</p><pre class="programlisting">gl.blendFunc(gl.DST_COLOR, gl.ZERO);</pre><p>This will be reflected in the blending equation as the following:</p><pre class="programlisting">color = S * D + D * 0.0;
color = S * D;</pre><p>The result will always be a darker blending.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec38"></a>Interpolative Blending</h4></div></div></div><p>If we set <code class="literal">sW</code> to <code class="literal">S.a</code> and <code class="literal">dW</code> to <code class="literal">1 - S.a</code>, then we get the following:</p><pre class="programlisting">color = S * S.a + D *(1 - S.a);</pre><p>This will create a linear <span>interpolation</span><a id="id325629237" class="indexterm"></a> between the source and <span>destination</span><a id="id325629245" class="indexterm"></a> color using the source alpha color, <code class="literal">S.a</code>, as the scaling factor. In code, this is translated as the following:</p><pre class="programlisting">gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);</pre><p>Interpolative blending allows us to create a transparency effect as long as the destination fragments have passed the depth test. As expected, this requires that the objects be rendered from back to front.</p><p>In the next section, we will play with different blending modes on a simple scene composed of a cone and sphere.</p></div></div></div>