<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch10lvl1sec131"></a>Time for Action: Post-Process Effects</h2></div></div><hr /></div><p>Let's see a <span>few</span><a id="id325358845" class="indexterm"></a> post-processing effects in action:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Open the <code class="literal">ch10_01_post-process.html</code> file in your browser, like so:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788629690/graphics/7394cf0e-ee94-4e48-a9a8-7cdc70502e66.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>The controls dropdown allows you to switch between different sample effects. Try them out to get a feel for the effects they have on the scene. We've already looked at grayscale, so let's examine the rest of the filters individually.</li><li>The <span class="strong"><strong>invert effect</strong></span>, similar to <span>grayscale</span><a id="id325643401" class="indexterm"></a> in that it only modifies the color output, inverts each color channel:</li></ol></div><pre class="programlisting">#version 300 es
precision mediump float;

uniform sampler2D uSampler;

in vec2 vTextureCoords;

out vec4 fragColor;

void main(void) {
  vec4 frameColor = texture(uSampler, vTextureCoords);
  fragColor = vec4(vec3(1.0) - frameColor.rgb, frameColor.a);
}</pre><div class="mediaobject"><img src="/graphics/9781788629690/graphics/9479ebac-7022-41ba-a013-2130b636c49c.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>The <span class="strong"><strong>wavy effect </strong></span>manipulates <span>the</span><a id="id325643467" class="indexterm"></a> texture coordinates to make the scene swirl and sway. In this effect, we also provide the current <span>time</span><a id="id325643474" class="indexterm"></a> to allow the distortion to change as time progresses:</li></ol></div><pre class="programlisting">#version 300 es
precision mediump float;

const float speed = 15.0;
const float magnitude = 0.015;

uniform sampler2D uSampler;
uniform float uTime;

in vec2 vTextureCoords;

out vec4 fragColor;

void main(void) {
  vec2 wavyCoord;
  wavyCoord.s = vTextureCoords.s + sin(uTime + vTextureCoords.t * 
   speed) * magnitude;
  wavyCoord.t = vTextureCoords.t + cos(uTime + vTextureCoords.s * 
   speed) * magnitude;
  fragColor = texture(uSampler, wavyCoord);
}</pre><div class="mediaobject"><img src="/graphics/9781788629690/graphics/8f31a7de-4a31-456f-9514-51c7dfb36364.png" /></div><p> </p><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>The <span class="strong"><strong>blur effect </strong></span>samples several pixels around <span>the</span><a id="id325647097" class="indexterm"></a> current pixel and uses a weighted blend to produce a fragment output that is the <span>average</span><a id="id325647104" class="indexterm"></a> of its neighbors. This gives a blurry feel to the scene. A new uniform, <code class="literal">uInverseTextureSize</code>, provides values that are<code class="literal">1</code>over the<code class="literal">width</code>and<code class="literal">height</code>of the viewport. We use these values to accurately target individual pixels within the texture. For example, <code class="literal">vTextureCoords.x + 2 * uInverseTextureSize.x</code> will be exactly 2 pixels to the left of the original texture coordinate:</li></ol></div><pre class="programlisting">#version 300 es
precision mediump float;

uniform sampler2D uSampler;
uniform vec2 uInverseTextureSize;

in vec2 vTextureCoords;

out vec4 fragColor;

vec4 offsetLookup(float xOff, float yOff) {
  return texture(
    uSampler, 
    vec2(
      vTextureCoords.x + xOff * uInverseTextureSize.x, 
      vTextureCoords.y + yOff * uInverseTextureSize.y
    )
  );
}

void main(void) {
  vec4 frameColor = offsetLookup(-4.0, 0.0) * 0.05;
  frameColor += offsetLookup(-3.0, 0.0) * 0.09;
  frameColor += offsetLookup(-2.0, 0.0) * 0.12;
  frameColor += offsetLookup(-1.0, 0.0) * 0.15;
  frameColor += offsetLookup(0.0, 0.0) * 0.16;
  frameColor += offsetLookup(1.0, 0.0) * 0.15;
  frameColor += offsetLookup(2.0, 0.0) * 0.12;
  frameColor += offsetLookup(3.0, 0.0) * 0.09;
  frameColor += offsetLookup(4.0, 0.0) * 0.05;
  fragColor = frameColor;
}</pre><div class="mediaobject"><img src="/graphics/9781788629690/graphics/0eb53366-e885-40a7-9a24-7d8d1a1581ba.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>Our final <span>example</span><a id="id325647150" class="indexterm"></a> is a <span class="strong"><strong>film grain </strong></span>effect. This uses a noisy texture to create a grainy scene, which simulates the <span>use</span><a id="id325647189" class="indexterm"></a> of an old camera. This example is significant because it demonstrates the use of a second texture besides the framebuffer when rendering:</li></ol></div><pre class="programlisting">#version 300 es
precision mediump float;

const float grainIntensity = 0.1;
const float scrollSpeed = 4000.0;

uniform sampler2D uSampler;
uniform sampler2D uNoiseSampler;
uniform vec2 uInverseTextureSize;
uniform float uTime;

in vec2 vTextureCoords;

out vec4 fragColor;

void main(void) {
  vec4 frameColor = texture(uSampler, vTextureCoords);
  vec4 grain = texture(
    uNoiseSampler,
    vTextureCoords * 2.0 + uTime * scrollSpeed * 
     uInverseTextureSize
  );
  fragColor = frameColor - (grain * grainIntensity);
}</pre><div class="mediaobject"><img src="/graphics/9781788629690/graphics/74328640-25c3-4325-988f-8f1fe2b64b18.png" /></div><p><span class="emphasis"><em><span class="strong"><strong>What just happened?</strong></span></em></span></p><p>All of these effects are achieved by manipulating the rendered image before it is outputted to the screen. Since the amount of geometry processed for these effects is small, they are efficient, regardless of the scene's complexity. That being said, performance may be affected as the size of the <code class="literal">canvas</code> or the complexity of the post-process shader increases.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec162"></a>Have a Go: Funhouse Mirror Effect</h3></div></div></div><p>What would it take to <span>create</span><a id="id325652489" class="indexterm"></a> a post-process effect that stretches the image near the center of the viewport and squashes it toward the edges?</p></div></div>