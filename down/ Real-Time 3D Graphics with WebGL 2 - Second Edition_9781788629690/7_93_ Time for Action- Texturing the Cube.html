<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec98"></a>Time for Action: Texturing the Cube</h2></div></div><hr /></div><p>Let's cover an example <span>where</span><a id="id325357458" class="indexterm"></a> we add a <span>texture</span><a id="id325358930" class="indexterm"></a> map to a cube:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Open the <code class="literal">ch07_01_textured-cube.html</code>file in your editor. If you open it in a browser, you should see a scene that looks like the following screenshot:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788629690/graphics/34933085-ce23-4210-bc68-0e63378fa754.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Let's load the texture image. At the top of the script block, add a new variable to hold the texture:</li></ol></div><pre class="programlisting">let texture;</pre><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>At the bottom of the <code class="literal">configure</code> function, add the following code, which creates the texture object, loads an image, and sets the image as the texture data. In this case, we'll use a PNG image with the WebGL logo as our texture:</li></ol></div><pre class="programlisting">texture = gl.createTexture();

const image = new Image();

image.src = '/common/images/webgl.png';

image.onload = () =&gt; {
  gl.bindTexture(gl.TEXTURE_2D, texture);
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, 
   gl.UNSIGNED_BYTE, image);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, 
   gl.NEAREST);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, 
   gl.NEAREST);
gl.bindTexture(gl.TEXTURE_2D, null);
};</pre><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>In the <code class="literal">render</code> function after the <code class="literal">vertexColors</code> binding block, add the following code to bind the texture to the shader <span>sampler</span><a id="id325652535" class="indexterm"></a> uniform:</li></ol></div><pre class="programlisting">if (object.textureCoords) {
  gl.activeTexture(gl.TEXTURE0);
gl.bindTexture(gl.TEXTURE_2D, texture);
gl.uniform1i(program.uSampler, 0);
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>Now we need to add the texture-specific code to the shader. In the vertex shader, add the following attribute and varying to the variable declarations:</li></ol></div><pre class="programlisting">in vec2 aVertexTextureCoords;
out vec2 vTextureCoords;</pre><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>At the end of the vertex shader's <code class="literal">main</code> function, make sure to copy the texture coordinate attribute into the varying so that the fragment shader can access it:</li></ol></div><pre class="programlisting">vTextureCoords = aVertexTextureCoords;</pre><div class="orderedlist"><ol class="orderedlist arabic" start="7" type="1"><li>The fragment shader also needs two new variable declarationsâ€”the sampler uniform and the varying from the vertex shader:</li></ol></div><pre class="programlisting">uniform sampler2D uSampler;
in vec2 vTextureCoords;</pre><div class="orderedlist"><ol class="orderedlist arabic" start="8" type="1"><li>We must also remember to add <code class="literal">aVertexTextureCoords</code> to the <code class="literal">attributes</code> list and <code class="literal">uSampler</code> to the <code class="literal">uniforms</code> list in the <code class="literal">configure</code> function so that the new variables can be accessed from our JavaScript binding code.</li><li>To access the texture color, we call <code class="literal">texture</code> with the sampler and the texture coordinates. Since we want the textured surface to retain the lighting, we'll multiply the lighting color and the texture color together, giving us the following line to calculate the fragment color:</li></ol></div><pre class="programlisting">fragColor = vColor * texture(uSampler, vTextureCoords);</pre><div class="orderedlist"><ol class="orderedlist arabic" start="10" type="1"><li>Open the file now in browser and you should see a scene like this one:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788629690/graphics/4aaab96e-cc73-4228-8f0d-09620fc67fa6.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="11" type="1"><li>If you're having trouble with a <span>particular</span><a id="id325659893" class="indexterm"></a> step and would like a reference, the completed code is available in <code class="literal">ch07_02_textured-cube-final.html</code>.</li></ol></div><p><span class="emphasis"><em><span class="strong"><strong>What just happened?</strong></span></em></span></p><p>We've just loaded a texture from a file, uploaded it to the GPU, rendered it on the cube geometry, and blended it with the lighting information that was already being calculated.</p><p>The remaining examples in this chapter will omit the calculation of lighting for simplicity and clarity, but lighting could be applied to all of them if desired.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec121"></a>Have a Go: Try a Different Texture</h3></div></div></div><p>Try one of your own <span>images</span><a id="id325662110" class="indexterm"></a> to see if you can get it to display as the texture. What happens if you provide a rectangular image rather than a square one?</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec122"></a>Texture Filter Modes</h3></div></div></div><p>So far, we've seen how <span>textures</span><a id="id325662126" class="indexterm"></a> can be used to sample image data in a fragment shader, but we've only used them in a limited context. Some interesting issues arise when you start to investigate textures more closely.</p><p>For example, if you were to zoom in on the cube from the previous demo, you would see that the texture begins to alias:</p><div class="mediaobject"><img src="/graphics/9781788629690/graphics/51a4c242-47f5-4041-bcdb-57b3dd62d0bd.png" /></div><p>As we zoom in, we can see that jagged edges develop around the WebGL logo. Similar problems become apparent when the texture is very small on the screen. Isolated to a single object, such artifacts are easy to overlook, but they can become very distracting in complex scenes. Why do we see these artifacts in the first place?</p><p>From the previous chapter, you should remember how vertex colors are interpolated so that the fragment shader is provided with a smooth gradient of color. Texture coordinates are interpolated in the exact same way, with the resulting coordinates being provided to the fragment shader and used to sample color values from the texture. In a perfect situation, the texture would display at a <code class="literal">1:1</code> ratio on screen, meaning each pixel of the texture (known as <span class="strong"><strong>texels</strong></span>) would take up <span>exactly</span><a id="id325662161" class="indexterm"></a> one pixel on screen. In this scenario, there would be no artifacts:</p><div class="mediaobject"><img src="/graphics/9781788629690/graphics/906500bf-d85b-49d8-a649-26d03a8a6568.png" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note71"></a>Note</h3><p><strong class="userinput"><code>Pixel Versus Texel</code></strong><span class="strong"><strong></strong></span>Sometimes, the pixels in a texture are called<span class="strong"><strong>texels</strong></span>. Pixel is short for Picture Element. Texel is short for Texture Element.</p></div><p>The reality of 3D applications, however, is that <span>textures</span><a id="id325662195" class="indexterm"></a> are almost never displayed at their native resolution. We refer to these scenarios as <span class="strong"><strong>magnification</strong></span> and <span class="strong"><strong>minification</strong></span>, depending on whether the texture has a lower or higher resolution than the screen space it occupies:</p><div class="mediaobject"><img src="/graphics/9781788629690/graphics/d60c969b-1273-4ed1-810f-e34519dad697.png" /></div><p>When a texture is magnified or minified, there can be some ambiguity about what color the texture sampler should return. For example, consider the following diagram of sample points against a slightly magnified texture:</p><div class="mediaobject"><img src="/graphics/9781788629690/graphics/9bc58e76-a50a-49fc-a916-e854ccb2354f.png" /></div><p>It's pretty obvious what color you would want the top left-hand side or middle sample points to return, but what about those texels in the middle? What color should they return? The answer is determined by your filter mode. Texture filtering allows us to control how textures are sampled and achieve the look we want.</p><p>Setting a texture's filter mode is very straightforward, and we already saw an example of how it works when we talked about creating textures:</p><pre class="programlisting">gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);</pre><p>As with most WebGL calls, <code class="literal">texParameteri</code> operates on the currently bound texture, and must be set for every texture you create. This also means that different <span>textures</span><a id="id325628665" class="indexterm"></a> can have different filters, which can be useful when trying to achieve specific effects.</p><p>In this example, we are setting both the magnification filter (<code class="literal">TEXTURE_MAG_FILTER</code>) and the minification filter (<code class="literal">TEXTURE_MIN_FILTER</code>) to <code class="literal">NEAREST</code>. There are several modes that can be passed for the third parameter, and the best way to understand the visual impact they have on a scene is to see the various filter modes in action.</p><p>Let's look at a demonstration of the filters in your browser while we discuss different parameters.</p></div></div>