<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec24"></a>WebGL Rendering Pipeline</h2></div></div><hr /></div><p>Although WebGL is often <span>thought</span><a id="id325357458" class="indexterm"></a> of as a comprehensive 3D API, it is, in reality, just a rasterization engine. It draws points, lines, and triangles based on the code you supply. Getting WebGL to do anything else requires you to provide code to use points, lines, and triangles to accomplish your task.</p><p>WebGL runs on the GPU on your computer. As such, you need to provide code that runs on that GPU. The code should be provided in the form of pairs of functions. Those two functions are <span>known</span><a id="id325617255" class="indexterm"></a> as the <span class="strong"><strong>vertex shader</strong></span> and <span class="strong"><strong>fragment shader</strong></span>, and <span>they</span><a id="id325617270" class="indexterm"></a> are each written in a very strictly-typed C/C++-like language called GLSL (GL Shader Language). Together, they are <span>called</span><a id="id325617277" class="indexterm"></a> a <span class="strong"><strong>program</strong></span>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note9"></a>Note</h3><p><strong class="userinput"><code>GLSL</code></strong><span class="strong"><strong></strong></span> GLSL is an acronym for the official OpenGL Shading Language. GLSL is a C/C++-like, high-level programming language for several parts of the graphic card. With GLSL, you can code short programs, called shaders, which are executed on the GPU. For more information, please check out <a class="ulink" href="https://en.wikipedia.org/wiki/OpenGL_Shading_Language" target="_blank">https://en.wikipedia.org/wiki/OpenGL_Shading_Language</a>.</p></div><p>A vertex shader's job is to compute vertex attributes. Based on various positions, the function outputs values that can be used to rasterize various kinds of primitives, including points, lines, and triangles. When rasterizing these primitives, it calls a second user-supplied function known as a fragment shader. A fragment shader's job is to compute a color for each pixel of the primitive currently being drawn.</p><p>Nearly all of the WebGL API is about setting up state for these pairs of functions to execute. For each thing you want to draw, you need to set up state to run these functions by invoking <code class="literal">gl.drawArrays</code> or <code class="literal">gl.drawElements</code>, which executes your shaders on the GPU.</p><p>Before going any further, let's examine what WebGL's rendering pipeline looks like. In subsequent chapters, we will discuss the pipeline in more detail. The following is a diagram of a simplified version of WebGL's rendering pipeline:</p><div class="mediaobject"><img src="/graphics/9781788629690/graphics/11b41f41-dd19-4e6a-810a-d3eaa2fcb0ba.png" /></div><p>Let's take a moment to describe each element.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec13"></a>Vertex Buffer Objects (VBOs)</h3></div></div></div><p><span class="strong"><strong>VBOs</strong></span> contain the data <span>that</span><a id="id325659786" class="indexterm"></a> is used to <span>describe</span><a id="id325659795" class="indexterm"></a> the geometry to be rendered. Vertex coordinates, which are points that define the vertices of 3D objects, are usually stored and processed in WebGL as VBOs. Additionally, there are several data elements, such as vertex normals, colors, and texture coordinates, that can be modeled as VBOs.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec14"></a>Index Buffer Objects (IBOs)</h3></div></div></div><p>While VBOs <span>contain</span><a id="id325659808" class="indexterm"></a> vertices describing a geometry, <span class="strong"><strong>IBOs</strong></span> contain information about the relationship of the vertices as the rendering <span>pipeline</span><a id="id325659820" class="indexterm"></a> constructs the drawing type primitives. It uses the index of each vertex in the vertex buffer as a value.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec15"></a>Vertex Shader</h3></div></div></div><p>The <span class="strong"><strong>vertex shader</strong></span> is <span>called</span><a id="id325659866" class="indexterm"></a> on each vertex. The shader manipulates <span class="emphasis"><em>per-vertex</em></span> data, such as vertex coordinates, normals, colors, and <span>texture</span><a id="id325659876" class="indexterm"></a> coordinates. This data is represented by attributes inside the vertex shader. Each attribute points to a VBO from where it reads vertex data.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec16"></a>Fragment Shader</h3></div></div></div><p>Every set of three vertices <span>defines</span><a id="id325659891" class="indexterm"></a> a triangle. Each element on the surface of that triangle needs to be assigned a color. Without this, our surfaces wouldn't have a color. Each surface <span>element</span><a id="id325659899" class="indexterm"></a> is called a <span class="strong"><strong>fragment</strong></span>. Since we are dealing with surfaces that will be displayed on your screen, these elements are more commonly <span>known</span><a id="id325659910" class="indexterm"></a> as <span class="strong"><strong>pixels</strong></span>.</p><p>The main goal of the <span class="strong"><strong>fragment shader</strong></span> is to <span>calculate</span><a id="id325628668" class="indexterm"></a> the color of <span class="emphasis"><em>individual pixels</em></span>. The following diagram illustrates this idea:</p><div class="mediaobject"><img src="/graphics/9781788629690/graphics/7440d4b3-5ace-4f0a-94e5-92898af18d69.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec17"></a>Framebuffer</h3></div></div></div><p>A two-dimensional buffer <span>contains</span><a id="id325628695" class="indexterm"></a> the fragments that have been processed by the fragment shader. Once all of the fragments have been processed, a 2D image is formed and <span>displayed</span><a id="id325628704" class="indexterm"></a> on screen. The <span class="strong"><strong>framebuffer</strong></span> is the final destination of the rendering pipeline.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec18"></a>Attributes</h3></div></div></div><p><span class="strong"><strong>Attributes</strong></span> are input variables that are used in the <span>vertex</span><a id="id325628727" class="indexterm"></a> shader. Attributes are used to specify how to pull data out of buffers and provide them to the <span>vertex</span><a id="id325628736" class="indexterm"></a> shader. For example, you may put positions in a buffer as three 32-bit floats per position. You would tell a particular attribute which buffer to pull the positions out of, what type of data it should pull out (3-component, 32-bit floating point numbers), what offset in the buffer the positions start at, and how many bytes to get from one position to the next. Since the vertex shader is called on each vertex, the attributes will be different every time the vertex shader is invoked.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec19"></a>Uniforms</h3></div></div></div><p><span class="strong"><strong>Uniforms</strong></span> are input variables that are available to both the <span>vertex</span><a id="id325628754" class="indexterm"></a> shader and the fragment shader. Unlike attributes, uniforms are constant during a rendering cycle. For example, the <span>position</span><a id="id325628763" class="indexterm"></a> of a light is often modeled as a uniform. Uniforms are effectively global variables that you set before executing your shader program.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec20"></a>Textures</h3></div></div></div><p><span class="strong"><strong>Textures</strong></span> are arrays of <span>data</span><a id="id325628781" class="indexterm"></a> that can be accessed in your shader program. Image data is the most common thing to put in a texture, but textures are simply <span>data</span><a id="id325628792" class="indexterm"></a> and can just as easily contain something other than an array of colors describing an image.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec21"></a>Varyings</h3></div></div></div><p><span class="strong"><strong>Varyings</strong></span> are <span>used</span><a id="id325628808" class="indexterm"></a> to <span class="emphasis"><em>pass data</em></span> from the <span>vertex</span><a id="id325628820" class="indexterm"></a> shader to the fragment shader. Depending on what is being rendered – points, lines, or triangles – the values set on a varying by a vertex shader will be interpolated while executing the fragment shader.</p><p>Now, let's cover the principles of creating a simple geometric object.</p></div></div>