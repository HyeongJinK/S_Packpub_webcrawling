<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec126"></a>Loading the Cars</h2></div></div><hr /></div><p>Inside of the <code class="literal">load</code> function, we will <span>download</span><a id="id325358833" class="indexterm"></a> some assets in the background that we can load into our application.</p><p>When the JSON files that describe the cars are available, we just use the <code class="literal">scene</code> instance to load these files. Keep in mind that it's uncommon to have ready-to-use JSON files. In such situations, there are specialized design tools, such as Blender, which can significantly help create and convert consumable models.</p><p>That said, we will use the pre-built models that are available on <a class="ulink" href="http://www.blendswap.org/" target="_blank">blendswap.org.</a> All of these models are publicly available, and are free of charge to use and distribute. Before we can use these models, we need to export them to an intermediate file format from where we can extract the geometry and material properties to <span>create</span><a id="id325400718" class="indexterm"></a> the appropriate JSON files. The file format we are going to use is <span class="strong"><strong>Wavefront OBJ</strong></span>.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec153"></a>Exporting the Blender Models</h3></div></div></div><p>All of the assets for this exercise are <span>provided</span><a id="id325400736" class="indexterm"></a> in this book's source code. However, if you want to go through the steps of converting the models, here are the steps. For this exercise, we will be using Blender (v2.6).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip86"></a>Note</h3><p><span class="strong"><strong><strong class="userinput"><code>Blender</code></strong></strong></span> If you do not have Blender, you can download it for your operating system from <a class="ulink" href="https://www.blender.org/download/" target="_blank">https://www.blender.org/download/</a>.</p></div><p> </p><p>Once you have loaded the car into Blender, you need to export it as an OBJ file. To do so, go to <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>Export</strong></span> | <span class="strong"><strong>Wavefront (.obj)</strong></span>, as shown in the <span>following</span><a id="id325400776" class="indexterm"></a> screenshot:</p><div class="mediaobject"><img src="/graphics/9781788629690/graphics/e80a640e-5cba-465c-9946-8cf65f1a707c.png" /></div><p>In the <span class="strong"><strong>Export OBJ</strong></span> panel, make sure that the following options are active:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Apply Modifiers</strong></span>: This will write the vertices in the scene that are the result of a mathematical operation instead of direct modeling. If you do not check this option, the model may appear incomplete in the WebGL scene.</li><li style="list-style-type: disc"><span class="strong"><strong>Write Materials</strong></span>: Blender will create the matching Material Template Library (MTL) file. We'll cover more on this in the following section.</li><li style="list-style-type: disc"><span class="strong"><strong>Triangulate Faces</strong></span>: Blender will write the indices as triangles. This is ideal for WebGL rendering.</li><li style="list-style-type: disc"><span class="strong"><strong>Entity as OBJ Objects</strong></span>: This configuration will identify every object in the Blender scene as an object in the OBJ file.</li><li style="list-style-type: disc"><span class="strong"><strong>Material Groups</strong></span>: If an object in the Blender scene has several materials, for example, a car tire that can be made of aluminum and rubber, then the object will be subdivided into groups, one per material in the OBJ file.</li></ul></div><p> </p><p>OBJ file. Then, click on <strong class="userinput"><code>Export</code></strong>. Once you have checked these export parameters, select the directory and name for your</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec154"></a>Understanding the OBJ Format</h3></div></div></div><p>There are several types of <span>definitions</span><a id="id325643367" class="indexterm"></a> in an OBJ file. Let's cover them line-by-line with a simple example. We are going to dissect a sample <code class="literal">square.obj</code> file that we will export from the Blender file called <code class="literal">square.blend</code>. This file represents a square divided into two parts, one painted red and the other <span>painted</span><a id="id325643382" class="indexterm"></a> blue, as shown in the following diagram:</p><div class="mediaobject"><img src="/graphics/9781788629690/graphics/418d0eac-f161-41a3-b815-5cf2af8b6b32.png" /></div><p>When we export Blender models to an OBJ format, the resulting file normally starts with a comment:</p><pre class="programlisting"># Blender v2.62 (sub 0) OBJ
File: 'squares.blend'
# www.blender.org</pre><p>These are comments, and they are denoted with a hash <code class="literal">#</code> symbol at the beginning of the line.</p><p>Next, we will usually find a line referring to the Material Template Library that this OBJ file is using. This line will begin with the keyword <code class="literal">mtllib</code>, followed by the name of the material's file:</p><pre class="programlisting">mtllib square.mtl</pre><p> </p><p>There are several ways that geometries can be grouped into entities in an OBJ file. We can find lines starting with the prefix <code class="literal">o</code>, followed by the object name, or by the prefix <code class="literal">g</code>, followed by the group name:</p><pre class="programlisting">o squares_mesh</pre><p>After object declaration, the following lines will refer to vertices, <code class="literal">v</code>, optionally to vertex normals, <code class="literal">vn</code>, and texture coordinates, <code class="literal">vt</code>. It’s important to note that vertices are shared by all groups in an object in the OBJ format. That is, you will not find lines referring to vertices when defining a group, because it's assumed that all vertex data was defined when the object was defined:</p><pre class="programlisting">v  1.0  0.0 -2.0
v  1.0  0.0  0.0
v -1.0  0.0  0.0
v -1.0  0.0 -2.0
v  0.0  0.0  0.0
v  0.0  0.0 -2.0
vn 0.0  1.0  0.0</pre><p>In our case, we have instructed Blender to export group materials. This means that each part of the object that has a different set of material properties will appear in the OBJ file as a group. In this example, we are defining an object with two groups (<code class="literal">squares_mesh_blue</code> and <code class="literal">squares_mesh_red</code>) and two <span>corresponding</span><a id="id325643501" class="indexterm"></a> materials (blue and red):</p><pre class="programlisting">g squares_mesh_blue</pre><p>If materials are being used, the line after the group declaration will be the material that's being used for that group. In this case, only the name of the material is required. It's assumed that the material properties for this material are defined in the MTL file that was declared at the beginning of the OBJ file:</p><pre class="programlisting">usemtl blue</pre><p>The lines that begin with the prefix <code class="literal">s</code> refer to smooth shading across polygons. Although mentioned here, we will not be using this definition when parsing the OBJ files into JSON files:</p><pre class="programlisting">s off</pre><p>The lines that start with <code class="literal">f</code> refer to faces. There are different ways to represent faces. Let's see them.</p><p> </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl3sec43"></a>Vertex</h4></div></div></div><pre class="programlisting">f i1 i2 i3...</pre><p>In this configuration, every face <span>element</span><a id="id325659827" class="indexterm"></a> corresponds to a vertex index. Depending on the number of indices per face, you could have triangular, rectangular, or polygonal faces. However, we have instructed Blender to use triangular faces to create the OBJ file. Otherwise, we would need to decompose the polygons into triangles before we could call <code class="literal">drawElements</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl3sec44"></a>Vertex/Texture Coordinate</h4></div></div></div><pre class="programlisting">f i1/t1 i2/t2 i3/t3...</pre><p>In this combination, every vertex <span>index</span><a id="id325659879" class="indexterm"></a> appears to be followed by a forward slash and texture coordinate index. You will normally find this combination when texture coordinates are defined at the object level with <code class="literal">vt</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl3sec45"></a>Vertex/Texture Coordinate/Normal</h4></div></div></div><pre class="programlisting">f i1/t1/n1 i2/t2/n2 i3/t3/n3...</pre><p>Here is a normal <span>index</span><a id="id325659902" class="indexterm"></a> that has been added as the third element in the configuration. If both texture coordinates and vertex normals are defined at the object level, you will most likely see this configuration at the group level.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl3sec46"></a>Vertex//Normal</h4></div></div></div><p>There can also be cases where <span>normals</span><a id="id325401397" class="indexterm"></a> are defined but texture coordinates are not. In this case, the second part of the face configuration is missing:</p><pre class="programlisting">f i1//n1 i2//n2 i3//n3...</pre><p>This is the case for <code class="literal">square.obj</code>, which looks like this:</p><pre class="programlisting">f 6//1 4//1 3//1
f 6//1 3//1 5//1</pre><p>Note that faces are defined using indices. In our example, we have defined a square divided into two parts. Here, we can see that all of the vertices share the same normal, which has been identified with index <code class="literal">1</code>.</p><p> </p><p>The remaining lines in this file represent the red group:</p><pre class="programlisting">g squares_mesh_red
usemtl red
f 1//1 6//1 5//1
f 1//1 5//1 2//1</pre><p>As we mentioned previously, groups belonging to the same object share indices.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec155"></a>Parsing the OBJ Files</h3></div></div></div><p>After <span>exporting</span><a id="id325401447" class="indexterm"></a> our cars into OBJ format, the next step is to parse the OBJ files to create JSON files that we can load into our scene. We have included the parser that we developed for this step in <code class="literal">common/models/obj-parser.py</code>. This parser has the following features:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">It's written in Python (quite common for OBJ parsers) and can be called in the command line with the following format:</li></ul></div><pre class="programlisting">obj-parser.py arg1 arg2</pre><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Where <code class="literal">arg1</code> is the name of the OBJ file to parse and <code class="literal">arg2</code> is the name of the MTL. The file extension is needed in both cases. For example:</li></ul></div><pre class="programlisting">obj-parser.py square.obj square.mtl</pre><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">It creates one JSON file per OBJ group.</li><li style="list-style-type: disc">It searches into the Material Template Library (if defined) for the material properties for each group and adds them to the corresponding JSON file.</li><li style="list-style-type: disc">It will calculate the appropriate indices for each group. Remember that OBJ groups share indices. Since we are creating one independent WebGL object per group, each object needs to have indices starting with <code class="literal">0</code>. The parser takes care of this for you.</li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note87"></a>Note</h3><p><span class="strong"><strong><strong class="userinput"><code>Python</code></strong></strong></span>
If you do not have Python installed in your system, you can get it from <a class="ulink" href="http://www.python.org/" target="_blank">http://www.python.org/</a> or<a class="ulink" href="https://anaconda.org/anaconda/python" target="_blank"> https://anaconda.org/anaconda/python</a>.</p></div><p> </p><p>The following diagram summarizes the procedure needed to create JSON files from Blender scenes:</p><div class="mediaobject"><img src="/graphics/9781788629690/graphics/eb2c8c25-e69c-43d3-aba4-765fe423258d.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec156"></a>Loading Cars into Our WebGL Scene</h3></div></div></div><p>Now that we have cars <span>stored</span><a id="id325628737" class="indexterm"></a> as JSON files, they are ready to be used in our WebGL scene. First, we have to let the user choose which car to visualize. That said, it's still a good idea to load one by default. To do so, we will write the following code inside the <code class="literal">load</code> function:</p><pre class="programlisting">function goHome() {
  camera.goHome([0, 0.5, 10]);
camera.setFocus([0, 0, 0]);
camera.setAzimuth(25);
camera.setElevation(-11);
}

function load() {
goHome();
loadCar('BMW i8');
}</pre><p>We call <code class="literal">goHome</code>, a helper function, that sets the <code class="literal">camera</code> position to a particular point in our scene. This is defined as a function, since we'll later use it as a way to reset our <code class="literal">camera</code> location, as needed. Then, we call <code class="literal">loadCar</code>, which is where we supply the <code class="literal">key</code> of the car (for example, <code class="literal">BMW i8</code>) we want to load from the <code class="literal">carModelData</code> that we <span>defined</span><a id="id325628779" class="indexterm"></a> inside of <code class="literal">configure</code>. Let's see what <code class="literal">loadCar</code> looks like:</p><pre class="programlisting">function loadCar(model) {
  scene.objects = [];
scene.add(floor);
const { path, partsCount } = carModelData[model];
scene.loadByParts(path, partsCount);
selectedCar = model;
}</pre><p>This function clears all of the objects in our <code class="literal">scene</code>, adds the already created <code class="literal">floor</code> instance, and extracts the necessary data from the <code class="literal">carModelData</code> object, such as the <code class="literal">path</code> to the model and the number of parts to load.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec157"></a>Rendering</h3></div></div></div><p>Let's take a step back and assess the big picture. We <span>previously</span><a id="id325628821" class="indexterm"></a> mentioned that, in our architecture, we have defined three main functions that define the life cycle of our WebGL application. These functions are <code class="literal">configure</code>, <code class="literal">load</code>, and <code class="literal">draw</code>.</p><p>Thus far, we've set up the scene by writing the code for the <code class="literal">configure</code> function. After that, we created our JSON cars and loaded them by writing the code for the <code class="literal">load</code> function. Now, we will implement the code for the third function: the <code class="literal">draw</code> function.</p><p>The code is pretty standard and almost identical to the <code class="literal">draw</code> functions that we've written in previous chapters. As the following code demonstrates, we set and clear the area that we are going to draw. Then, we check the camera's perspective and process every object in <code class="literal">scene</code>.</p><p>One important consideration is that we need to ensure that we are correctly mapping the material properties defined in our JSON objects to the appropriate shader uniforms.</p><p>Let's start implementing the <code class="literal">draw</code> function:</p><pre class="programlisting">function draw() {
  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
transforms.updatePerspective();

  // ...
}</pre><p>First, we set our viewport and clear the scene, followed by <span>applying</span><a id="id325628875" class="indexterm"></a> the perspective update by using the <code class="literal">transforms</code> instance we initialized inside of <code class="literal">configure</code>.</p><p>Then, we move to the objects in our scene:</p><pre class="programlisting">try {
  scene.traverse(object =&gt; {
if (!object.visible) return;

transforms.calculateModelView();
transforms.push();
transforms.setMatrixUniforms();
transforms.pop();

gl.uniform3fv(program.uKa, object.Ka);
gl.uniform3fv(program.uKd, object.Kd);
gl.uniform3fv(program.uKs, object.Ks);
gl.uniform1f(program.uNs, object.Ns);
gl.uniform1f(program.uD, object.d);
gl.uniform1i(program.uIllum, object.illum);

// Bind
gl.bindVertexArray(object.vao);
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, object.ibo);

if (object.wireframe) {
      gl.uniform1i(program.uWireframe, 1);
gl.drawElements(gl.LINES, object.indices.length, gl.UNSIGNED_SHORT, 
       0);
}
else {
      gl.uniform1i(program.uWireframe, 0);
gl.drawElements(gl.TRIANGLES, object.indices.length, 
       gl.UNSIGNED_SHORT, 0);
}

// Clean
gl.bindVertexArray(null);
gl.bindBuffer(gl.ARRAY_BUFFER, null);
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
});
}
catch (error) {
  console.error(error);
}</pre><p>It may be helpful to take a look at the list of uniforms that was defined in the earlier section on shaders. We need to make sure that all of the shader uniforms are paired with object attributes.</p><p>The following diagram shows the process that occurs inside the <code class="literal">draw</code> function:</p><div class="mediaobject"><img src="/graphics/9781788629690/graphics/7e7e9464-709d-4567-aaea-c28b881c8b77.png" /></div><p>Each car part is a different JSON file. The <code class="literal">draw</code> function iterates through all of these parts inside the <code class="literal">scene</code>. For each part, the material properties are passed as uniforms to the shaders and the geometry is passed as attributes (reading data from the respective VBOs). Finally, the draw call (<code class="literal">drawElements</code>) is executed. The result looks something like this:</p><div class="mediaobject"><img src="/graphics/9781788629690/graphics/5fe8132f-7226-46ba-b878-fd802bd61678.png" /></div><p>Here's the final JavaScript <span>source</span><a id="id325628972" class="indexterm"></a> code that can be found in <code class="literal">ch09_02_showroom.html</code>:</p><pre class="programlisting">&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Real-Time 3D Graphics with WebGL2&lt;/title&gt;
  &lt;link rel="shortcut icon" type="image/png" 
   href="/common/images/favicon.png" /&gt;

&lt;!-- libraries --&gt;
&lt;link rel="stylesheet" href="/common/lib/normalize.css"&gt;
  &lt;script type="text/javascript" src="/common/lib/dat.gui.js"&gt;&lt;/script&gt;
  &lt;script type="text/javascript" src="/common/lib/gl-matrix.js"&gt;&lt;/script&gt;

&lt;!-- modules --&gt;
&lt;script type="text/javascript" src="/common/js/utils.js"&gt;&lt;/script&gt;
  &lt;script type="text/javascript" src="/common/js/EventEmitter.js"&gt;&lt;/script&gt;
  &lt;script type="text/javascript" src="/common/js/Camera.js"&gt;&lt;/script&gt;
  &lt;script type="text/javascript" src="/common/js/Clock.js"&gt;&lt;/script&gt;
  &lt;script type="text/javascript" src="/common/js/Controls.js"&gt;&lt;/script&gt;
  &lt;script type="text/javascript" src="/common/js/Floor.js"&gt;&lt;/script&gt;
  &lt;script type="text/javascript" src="/common/js/Light.js"&gt;&lt;/script&gt;
  &lt;script type="text/javascript" src="/common/js/Program.js"&gt;&lt;/script&gt;
  &lt;script type="text/javascript" src="/common/js/Scene.js"&gt;&lt;/script&gt;
  &lt;script type="text/javascript" src="/common/js/Texture.js"&gt;&lt;/script&gt;
  &lt;script type="text/javascript" src="/common/js/Transforms.js"&gt;&lt;/script&gt;
</pre><p> </p><p>The following code is for the vertex shader:</p><pre class="programlisting">  &lt;script id="vertex-shader" type="x-shader/x-vertex"&gt;
#version 300 es
    precision mediump float;

    const int numLights = 4;

    uniform mat4 uModelViewMatrix;
    uniform mat4 uProjectionMatrix;
    uniform mat4 uNormalMatrix;
    uniform vec3 uLightPosition[numLights];

    in vec3 aVertexPosition;
    in vec3 aVertexNormal;

    out vec3 vNormal;
    out vec3 vLightRay[numLights];
    out vec3 vEye[numLights];

    void main(void) {
      vec4 vertex = uModelViewMatrix * vec4(aVertexPosition, 1.0);
      vec4 lightPosition = vec4(0.0);

      for(int i= 0; i &lt; numLights; i++) {
        lightPosition = vec4(uLightPosition[i], 1.0);
        vLightRay[i] = vertex.xyz - lightPosition.xyz;
        vEye[i] = -vec3(vertex.xyz);
      }

      vNormal = vec3(uNormalMatrix * vec4(aVertexNormal, 1.0));
      gl_Position = uProjectionMatrix * uModelViewMatrix * 
       vec4(aVertexPosition, 1.0);
    }
&lt;/script&gt;</pre><p>The following code is for the <span>fragment</span><a id="id325629000" class="indexterm"></a> shader:</p><pre class="programlisting">  &lt;script id="fragment-shader" type="x-shader/x-fragment"&gt;
#version 300 es
    precision mediump float;

    const int numLights = 4;

    uniform vec3 uLd[numLights];
    uniform vec3 uLs[numLights];
    uniform vec3 uLightPosition[numLights];
    uniform vec3 uKa;
    uniform vec3 uKd;
    uniform vec3 uKs;
    uniform float uNs;
    uniform float uD;
    uniform int uIllum;
    uniform bool uWireframe;

    in vec3 vNormal;
    in vec3 vLightRay[numLights];
    in vec3 vEye[numLights];

    out vec4 fragColor;

    void main(void) {
      if (uWireframe || uIllum == 0) {
        fragColor = vec4(uKd, uD);
        return;
      }

      vec3 color = vec3(0.0);
      vec3 light = vec3(0.0);
      vec3 eye = vec3(0.0);
      vec3 reflection = vec3(0.0);
      vec3 normal = normalize(vNormal);

      if (uIllum == 1) {
        for (int i = 0; i &lt; numLights; i++) {
          light = normalize(vLightRay[i]);
          normal = normalize(vNormal);
          color += (uLd[i] * uKd * clamp(dot(normal, -light), 0.0, 1.0));
        }
      }

      if (uIllum == 2) {
        for (int i = 0; i &lt; numLights; i++) {
          eye = normalize(vEye[i]);
          light = normalize(vLightRay[i]);
          reflection = reflect(light, normal);
          color += (uLd[i] * uKd * clamp(dot(normal, -light), 0.0, 1.0));
          color += (uLs[i] * uKs * pow(max(dot(reflection, eye), 0.0), uNs) 
           * 4.0);
        }
      }

      fragColor =  vec4(color, uD);
    }
&lt;/script&gt;
</pre><p> </p><p>The following is the <span>application</span><a id="id325629018" class="indexterm"></a> code with the appropriate global variable definitions:</p><pre class="programlisting">  &lt;script type="text/javascript"&gt;
'use strict';

let gl, program, scene, clock, camera, transforms, lights,
floor, selectedCar, lightPositions, carModelData,
clearColor = [0.9, 0.9, 0.9, 1];
</pre><p>The following is the configuration step:</p><pre class="programlisting">
function configure() {
const canvas = utils.getCanvas('webgl-canvas');
utils.autoResizeCanvas(canvas);

gl = utils.getGLContext(canvas);
gl.clearColor(...clearColor);
gl.clearDepth(1);
gl.enable(gl.DEPTH_TEST);
gl.depthFunc(gl.LESS);
gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

program = new Program(gl, 'vertex-shader', 'fragment-shader');

const attributes = [
'aVertexPosition',
'aVertexNormal',
'aVertexColor'
];

const uniforms = [
'uProjectionMatrix',
'uModelViewMatrix',
'uNormalMatrix',
'uLightPosition',
'uWireframe',
'uLd',
'uLs',
'uKa',
'uKd',
'uKs',
'uNs',
'uD',
'uIllum'
];

program.load(attributes, uniforms);

scene = new Scene(gl, program);
clock = new Clock();

camera = new Camera(Camera.ORBITING_TYPE);
new Controls(camera, canvas);

transforms = new Transforms(gl, program, camera, canvas);

lights = new LightsManager();

lightPositions = {
farLeft: [-1000, 1000, -1000],
farRight: [1000, 1000, -1000],
nearLeft: [-1000, 1000, 1000],
nearRight: [1000, 1000, 1000]
      };

Object.keys(lightPositions).forEach(key =&gt; {
const light = new Light(key);
light.setPosition(lightPositions[key]);
light.setDiffuse([0.4, 0.4, 0.4]);
light.setSpecular([0.8, 0.8, 0.8]);
lights.add(light)
      });

gl.uniform3fv(program.uLightPosition, lights.getArray('position'));
gl.uniform3fv(program.uLd, lights.getArray('diffuse'));
gl.uniform3fv(program.uLs, lights.getArray('specular'));

gl.uniform3fv(program.uKa, [1, 1, 1]);
gl.uniform3fv(program.uKd, [1, 1, 1]);
gl.uniform3fv(program.uKs, [1, 1, 1]);
gl.uniform1f(program.uNs, 1);

floor = new Floor(200, 2);

carModelData = {
'BMW i8': {
paintAlias: 'BMW',
partsCount: 25,
path: '/common/models/bmw-i8/part'
}
      };
}

function goHome() {
      camera.goHome([0, 0.5, 5]);
camera.setFocus([0, 0, 0]);
camera.setAzimuth(25);
camera.setElevation(-10);
}</pre><p>The following code is for loading the required assets:</p><pre class="programlisting">function loadCar(model) {
      scene.objects = [];
scene.add(floor);
const { path, partsCount } = carModelData[model];
scene.loadByParts(path, partsCount);
selectedCar = model;
}

function load() {
goHome();
loadCar('BMW i8');
}</pre><p>The following code states where we draw our scene:</p><pre class="programlisting">function draw() {
      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
transforms.updatePerspective();

try {
        scene.traverse(object =&gt; {
if (!object.visible) return;

transforms.calculateModelView();
transforms.push();
transforms.setMatrixUniforms();
transforms.pop();

gl.uniform3fv(program.uKa, object.Ka);
gl.uniform3fv(program.uKd, object.Kd);
gl.uniform3fv(program.uKs, object.Ks);
gl.uniform1f(program.uNs, object.Ns);
gl.uniform1f(program.uD, object.d);
gl.uniform1i(program.uIllum, object.illum);

// Bind
gl.bindVertexArray(object.vao);
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, object.ibo);

if (object.wireframe) {
            gl.uniform1i(program.uWireframe, 1);
gl.drawElements(gl.LINES, object.indices.length, 
             gl.UNSIGNED_SHORT, 0);
}
else {
            gl.uniform1i(program.uWireframe, 0);
gl.drawElements(gl.TRIANGLES, object.indices.length, 
             gl.UNSIGNED_SHORT, 0);
}

// Clean
gl.bindVertexArray(null);
gl.bindBuffer(gl.ARRAY_BUFFER, null);
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
});
}
catch (error) {
        console.error(error);
}
    }</pre><p>The initialization of our <span>application</span><a id="id325629053" class="indexterm"></a> after the document has loaded is performed with the following code:</p><pre class="programlisting">function init() {
configure();
load();
clock.on('tick', draw);
}

    window.onload = init;

&lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;

  &lt;canvas id="webgl-canvas"&gt;
Your browser does not support the HTML5 canvas element.
&lt;/canvas&gt;

&lt;/body&gt;
&lt;/html&gt;</pre><p> </p><p><span class="emphasis"><em><span class="strong"><strong>What just happened?</strong></span></em></span></p><p>We have covered a demo that uses many of the elements we've discussed throughout this book. We used the infrastructure code that we developed throughout the previous chapters and implemented the three main functions: <code class="literal">configure</code>, <code class="literal">load</code>, and <code class="literal">draw</code>. As we've seen, these functions define the life cycle of our application.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec158"></a>Have a Go: Interactive Controls</h3></div></div></div><p>Let's leverage <span class="strong"><strong>dat.GUI</strong></span> to add more <span>interactivity</span><a id="id325629097" class="indexterm"></a> and <span>customization</span><a id="id325629105" class="indexterm"></a> to our application. Go ahead and try and add the following functionality:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Create a dropdown so that you can select from the following car models provided in the <code class="literal">common/models/</code> directory: <code class="literal">bmw-i8</code>, <code class="literal">audi-r8</code>, <code class="literal">ford-mustang</code>, and <code class="literal">lamborghini-gallardo</code>.</li></ol></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip88"></a>Note</h3><p><span class="strong"><strong><strong class="userinput"><code>Hint</code></strong></strong></span> You can leverage <code class="literal">carModelData</code> to declaratively describe the car models and use the already created <code class="literal">loadCar</code> function with the appropriate information.</p></div><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Create a color picker to change the color of the loaded car.</li></ol></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip89"></a>Note</h3><p><span class="strong"><strong><strong class="userinput"><code>Hint</code></strong></strong></span> By inspecting the car data files, you will find various indicators that signify which parts are body panels. These are described as <code class="literal">paintAlias</code> in <code class="literal">carModelData</code>,  which can be used to change the <code class="literal">Kd</code> property of each individual item in the scene.</p></div><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>Create a slider to change the shininess of the selected car.</li></ol></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip90"></a>Note</h3><p><span class="strong"><strong><strong class="userinput"><code>Hint</code></strong></strong></span> You can use <code class="literal">paintAlias</code> once again and update the <code class="literal">Ks</code> property of each individual item in the scene.</p></div><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p>The following functionality has been implemented in <code class="literal">ch09_03_showroom-controls.html</code>, along with controls for each individual light, the background color, floor visibility, and so forth:</p><div class="mediaobject"><img src="/graphics/9781788629690/graphics/9fb24b02-5d9f-4e40-aedb-10cb0364b5a3.png" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip91"></a>Note</h3><p><code class="literal">utils.configureControls</code>
The <code class="literal">utils.configureControls</code> method is a simple abstraction on top of the dat.GUI interface to remove repetition and provide a more declarative way for describing our controls widget. You can use dat.GUI directly or build upon this simple helper function.</p></div></div></div>