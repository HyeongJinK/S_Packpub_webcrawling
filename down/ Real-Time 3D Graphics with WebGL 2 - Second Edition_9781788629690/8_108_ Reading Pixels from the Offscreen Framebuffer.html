<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec112"></a>Reading Pixels from the Offscreen Framebuffer</h2></div></div><hr /></div><p>We can now go to the <span>offscreen</span><a id="id325357458" class="indexterm"></a> buffer and <span>read</span><a id="id325358930" class="indexterm"></a> the color from the appropriate coordinates:</p><div class="mediaobject"><img src="/graphics/9781788629690/graphics/167682e2-bde8-4392-87f3-1e76b1bb5870.png" /></div><p>WebGL allows us to read back from a framebuffer using the <code class="literal">readPixels</code> function. As usual, having <code class="literal">gl</code> as the WebGL context variable within our context:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Function</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Description</strong></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">gl.readPixels(x, y, width, height, format, type, pixels)</code></p></td><td style=""><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">x</code> and <code class="literal">y</code>: Starting coordinates.</li><li style="list-style-type: disc"><code class="literal">width</code> and <code class="literal">height</code>: The extent of pixels to read from the framebuffer. In our example, we are just reading one pixel (where the user clicks), so this will be <code class="literal">1</code>, <code class="literal">1</code>.</li><li style="list-style-type: disc"><code class="literal">format</code>: Supports the <code class="literal">gl.RGBA</code> format.</li><li style="list-style-type: disc"><code class="literal">type:</code>: Supports the <code class="literal">gl.UNSIGNED_BYTE</code> type.</li><li style="list-style-type: disc"><code class="literal">pixels</code>: A typed array that will contain the results of querying the framebuffer. It needs to have sufficient space to store the results depending on the extent of the query (<code class="literal">x</code>, <code class="literal">y</code>, <code class="literal">width</code>, <code class="literal">height</code>). It supports the <code class="literal">Uint8Array</code> type.</li></ul></div></td></tr></tbody></table></div><p>Remember that WebGL works as a state machine; thus, many operations depend on the validity of its state. In this case, we need to ensure that the offscreen framebuffer that we want to read from is the currently bound one. To do so, we bind it by using <code class="literal">bindFramebuffer</code>. Putting <span>everything</span><a id="id325643405" class="indexterm"></a> together, the code looks like this:</p><pre class="programlisting">// read one pixel
const readout = new Uint8Array(1 * 1 * 4);
gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
gl.readPixels(coords.x, coords.y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, readout);
gl.bindFramebuffer(gl.FRAMEBUFFER, null);</pre><p>Here, the size of the readout array is <code class="literal">1 * 1 * 4</code>. This means that it has one pixel of width times one pixel height times four channels, since the format is RGBA. You do not need to specify the size this way; this was done to demonstrate why the size is <code class="literal">4</code> when we are just retrieving one pixel.</p></div>