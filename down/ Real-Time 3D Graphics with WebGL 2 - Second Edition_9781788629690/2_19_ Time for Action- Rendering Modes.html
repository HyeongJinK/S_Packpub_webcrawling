<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec29"></a>Time for Action: Rendering Modes</h2></div></div><hr /></div><p>Let's revisit the <span>signature</span><a id="id325359415" class="indexterm"></a> of the <code class="literal">drawElements</code> function:</p><pre class="programlisting">gl.drawElements(mode, count, type, offset)</pre><p>The first parameter determines the type of primitives that we are rendering. In the following section, we will see the different rendering modes with examples.</p><p>Follow the given steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Open the <code class="literal">ch02_04_rendering-modes.html</code> file in your browser. This example follows the same structure as in the previous section.</li><li>Open <code class="literal">ch02_04_rendering-modes.html</code> in your editor and scroll down to the <code class="literal">initBuffers</code> function:</li></ol></div><pre class="programlisting">function initBuffers() {
const vertices = [
    -0.5, -0.5, 0,
-0.25, 0.5, 0,
0.0, -0.5, 0,
0.25, 0.5, 0,
0.5, -0.5, 0
];

indices = [0, 1, 2, 0, 2, 3, 2, 3, 4];

// Create VAO
trapezoidVAO = gl.createVertexArray();

// Bind VAO
gl.bindVertexArray(trapezoidVAO);

const trapezoidVertexBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, trapezoidVertexBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), 
   gl.STATIC_DRAW);
// Provide instructions to VAO
gl.vertexAttribPointer(program.aVertexPosition, 3, gl.FLOAT, 
   false, 0, 0);
gl.enableVertexAttribArray(program.aVertexPosition);

trapezoidIndexBuffer = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, trapezoidIndexBuffer);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), 
   gl.STATIC_DRAW);

// Clean
gl.bindVertexArray(null);
gl.bindBuffer(gl.ARRAY_BUFFER, null);
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>Here, you will see that we are drawing a trapezoid. However, on screen, you will see two triangles! Later, we'll see how this happened.</li><li>At the top of the page, there is a settings controller that allows you to select the different rendering modes that WebGL provides:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788629690/graphics/f4821216-b507-4064-93da-5b50b26ca3b8.png" /></div><pre class="programlisting">let gl,
canvas,
program,
indices,
trapezoidVAO,
trapezoidIndexBuffer,
// Global variable that captures the current rendering mode type
<span class="strong"><strong>renderingMode = 'TRIANGLES';</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>When you select any option from the settings, you are changing the value of the <code class="literal">renderingMode</code> variable defined at the top of the code (scroll up if you want to see where it is defined). The code that sets up the settings controller is inside the <code class="literal">initControls</code> function. We will cover this functionality later.</li><li>To see how each <span>option</span><a id="id325617349" class="indexterm"></a> modifies the rendering, scroll to the <code class="literal">draw</code> function:</li></ol></div><pre class="programlisting">function draw() {
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

// Bind VAO
gl.bindVertexArray(trapezoidVAO);

gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, trapezoidIndexBuffer);

// Depending on the rendering mode type, we will draw differently
switch (renderingMode) {
case 'TRIANGLES': {
      indices = [0, 1, 2, 2, 3, 4];
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new 
       Uint16Array(indices), gl.STATIC_DRAW);
gl.drawElements(gl.TRIANGLES, indices.length, 
       gl.UNSIGNED_SHORT, 
       0);
break;
}
case 'LINES': {
      indices = [1, 3, 0, 4, 1, 2, 2, 3];
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new 
       Uint16Array(indices), gl.STATIC_DRAW);
gl.drawElements(gl.LINES, indices.length, gl.UNSIGNED_SHORT, 
       0);
break;
}
case 'POINTS': {
      indices = [1, 2, 3];
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new 
       Uint16Array(indices), gl.STATIC_DRAW);
gl.drawElements(gl.POINTS, indices.length, gl.UNSIGNED_SHORT, 
       0);
break;
}
case 'LINE_LOOP': {
      indices = [2, 3, 4, 1, 0];
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new 
       Uint16Array(indices), gl.STATIC_DRAW);
gl.drawElements(gl.LINE_LOOP, indices.length, 
       gl.UNSIGNED_SHORT, 0);
break;
}
case 'LINE_STRIP': {
      indices = [2, 3, 4, 1, 0];
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new 
       Uint16Array(indices), gl.STATIC_DRAW);
gl.drawElements(gl.LINE_STRIP, indices.length, 
       gl.UNSIGNED_SHORT, 0);
break;
}
case 'TRIANGLE_STRIP': {
      indices = [0, 1, 2, 3, 4];
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new 
       Uint16Array(indices), gl.STATIC_DRAW);
gl.drawElements(gl.TRIANGLE_STRIP, indices.length, 
       gl.UNSIGNED_SHORT, 0);
break;
}
case 'TRIANGLE_FAN': {
      indices = [0, 1, 2, 3, 4];
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new 
       Uint16Array(indices), gl.STATIC_DRAW);
gl.drawElements(gl.TRIANGLE_FAN, indices.length, 
       gl.UNSIGNED_SHORT, 0);
break;
}
  }

// Clean
gl.bindVertexArray(null);
gl.bindBuffer(gl.ARRAY_BUFFER, null);
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="7" type="1"><li>You will see that after binding the IBO <code class="literal">trapezoidIndexBuffer</code> with the following instruction:</li></ol></div><pre class="programlisting">gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, trapezoidIndexBuffer);</pre><div class="orderedlist"><ol class="orderedlist arabic" start="8" type="1"><li>You also have a switch statement where there is some code that executes, depending on the value of the <code class="literal">renderingMode</code> variable.</li><li>For each mode, we define the contents of the JavaScript array indices. Then, we pass this array to the currently-bound buffer, <code class="literal">trapezoidIndexBuffer</code>, by using the <code class="literal">bufferData</code> function. Finally, we call the <code class="literal">drawElements</code> function.</li><li>Let's see what each mode does:</li></ol></div><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Mode</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Description</strong></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">TRIANGLES</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>When you use the <code class="literal">TRIANGLES</code> mode, WebGL will use the first three indices defined in your IBO to construct the first triangle, the next three to construct the second triangle, and so on.</p><p>In this example, we are drawing two triangles, which can be verified by examining the JavaScript indices array that populates the IBO: <code class="literal">indices = [0, 1, 2, 2, 3, 4];</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">LINES</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>The <code class="literal">LINES</code> mode will instruct WebGL to take each consecutive pair of indices defined in the IBO and draw lines by taking the coordinates of the corresponding vertices.</p><p>For instance, <code class="literal">indices = [1, 3, 0, 4, 1, 2, 2, 3];</code> will draw four lines: from vertex number <code class="literal">1</code> to vertex number <code class="literal">3</code>, from vertex number <code class="literal">0</code> to vertex number <code class="literal">4</code>, from vertex number <code class="literal">1</code> to vertex number <code class="literal">2</code>, and from vertex number <code class="literal">2</code> to vertex number <code class="literal">3</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">POINTS</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>When we use the <code class="literal">POINTS</code> mode, WebGL will not generate surfaces. Instead, it will render the vertices that we had defined using the index array.</p><p>In this example, we will only render vertices number <code class="literal">1</code>, <code class="literal">2</code>, and <code class="literal">3</code> with <code class="literal">indices = [1, 2, 3];</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">LINE_LOOP</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">LINE_LOOP</code> draws a closed loop connecting the vertices defined in the IBO to the next one.</p><p>In our case, it will be <code class="literal">indices = [2, 3, 4, 1, 0];</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">LINE_STRIP</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">LINE_STRIP</code> is similar to <code class="literal">LINE_LOOP</code>. The difference is that WebGL does not connect the last vertex to the first one (not a closed loop).</p><p>The indices JavaScript array will be <code class="literal">indices = [2, 3, 4, 1, 0];</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">TRIANGLE_STRIP</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">TRIANGLE_STRIP</code> draws connected triangles. Every vertex is specified after the first three.</p><p>In our example, vertices number <code class="literal">0</code>, number <code class="literal">1</code>, and number <code class="literal">2</code> create a new triangle. If we have <code class="literal">indices = [0, 1, 2, 3, 4];</code>, then we will generate the triangles <span class="emphasis"><em>(0, 1, 2)</em></span>, <span class="emphasis"><em>(1, 2, 3)</em></span>, and <span class="emphasis"><em>(2, 3, 4)</em></span>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">TRIANGLE_FAN</code></p></td><td style=""><p><code class="literal">TRIANGLE_FAN</code> creates triangles in a similar way to <code class="literal">TRIANGLE_STRIP</code>. However, the first vertex defined in the IBO is taken as the origin of the fan (the only shared vertex among consecutive triangles).</p><p>In our example, <code class="literal">indices = [0, 1, 2, 3, 4];</code> will create the triangles <span class="emphasis"><em>(0, 1, 2)</em></span> and <span class="emphasis"><em>(0, 3, 4)</em></span>.</p></td></tr></tbody></table></div><div class="orderedlist"><ol class="orderedlist arabic" start="11" type="1"><li>The following diagram can be useful in visualizing these various rendering modes. That being said, it's easiest to see these modes in <span>action</span><a id="id325358887" class="indexterm"></a> by changing the setting's drop-down values and seeing the various results:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788629690/graphics/7969f8b5-05a0-461e-885a-7b6e43c5caa6.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="12" type="1"><li>Let's make some changes by editing <code class="literal">ch02_04_rendering-modes.html</code> so that when you select the <code class="literal">TRIANGLES</code> option, you render the trapezoid instead of two triangles.</li></ol></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip25"></a>Note</h3><p><strong class="userinput"><code><span class="strong"><strong><strong class="userinput"><code>Hint</code></strong></strong></span></code></strong>
You need one extra triangle in the indices array.</p></div><div class="orderedlist"><ol class="orderedlist arabic" start="13" type="1"><li>Save the file and test it in your browser.</li><li>Edit the web page so that you draw the letter <span class="strong"><strong>M</strong></span> using the <code class="literal">LINES</code> option.</li></ol></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip26"></a>Note</h3><p><strong class="userinput"><code>Hint</code></strong>
You need to define four lines in the indices array.</p></div><p></p><div class="orderedlist"><ol class="orderedlist arabic" start="15" type="1"><li>Just like before, save your changes and test them in your browser.</li><li>Using the <code class="literal">LINE_LOOP</code> mode, draw only the boundary of the trapezoid.</li></ol></div><p><span class="emphasis"><em><span class="strong"><strong>What just happened?</strong></span></em></span></p><p>This simple exercise helped us see the different rendering modes supported by WebGL. These different modes determine how to interpret vertex and index <span>data</span><a id="id325359012" class="indexterm"></a> to render an object.</p></div>