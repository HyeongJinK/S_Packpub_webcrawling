<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec86"></a>Time for Action: Directional Point Lights</h2></div></div><hr /></div><p>In <a class="link" href="#" linkend="ch03">Chapter 3</a>, <span class="emphasis"><em>Lights</em></span>, we <span>compared</span><a id="id325358935" class="indexterm"></a> directional and positional lights:</p><div class="mediaobject"><img src="/graphics/9781788629690/graphics/45b98035-4b9a-4566-904d-005a2527df95.png" /></div><p>In point lighting, for every point on the surface of our object, we compute the direction from the light to that point on the surface. We then do the same thing we did for directional lighting. Remember that we took the dot product of the surface normal (the direction the surface is facing) and the light direction. This gave us a value of <code class="literal">1</code> if the two directions matched, which means the fragment should be fully lit, <code class="literal">0</code> if the two directions were perpendicular, and <code class="literal">-1</code> if they were opposite. We directly used that value to multiply the color of the surface, which gave us lighting.</p><p>In this section, we will combine directional and positional lights. We are going to create a third type of light: a <span class="strong"><strong>directional point light</strong></span>, commonly referred to as a <span class="strong"><strong>spot light</strong></span>. This light has both positional and directional properties. We are ready to do this since our shaders can easily handle lights with multiple properties:</p><div class="mediaobject"><img src="/graphics/9781788629690/graphics/6aafb627-62bc-4e99-bbdf-5ba9df730315.png" /></div><p>The trick to creating these lights is to <span>subtract</span><a id="id325617269" class="indexterm"></a> the light-direction vector from the normal for each vertex. The resulting vector will create a different Lambert coefficient that will reflect into the cone generated by the light source:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Open <code class="literal">ch06_06_wall-spot-light.html</code> in your browser. As you can see, the three light sources now have a direction:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788629690/graphics/6df6f77d-fb26-42d1-8c17-78514c2a423e.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Open <code class="literal">ch06_06_wall-spot-light.html</code> in your source code editor.</li><li>To create a light cone, we need to obtain one Lambert coefficient per fragment. As we did in previous examples, we obtain these coefficients in the fragment shader by calculating the dot product between the inverted light ray and the normal that has been interpolated. Thus far, we have been using one varying to do this: <code class="literal">vNormal</code>.</li><li>So far, one varying has sufficed since we did not need to update the normals, regardless of how many lights we have in the scene. However, to create directional point lights, we do have to <span>update</span><a id="id325617354" class="indexterm"></a> the normals as the direction of each light will create a different normal. Therefore, we replace <code class="literal">vNormal</code> with a <span class="strong"><strong>varying array</strong></span>:</li></ol></div><pre class="programlisting">out vec3 vNormal[numLights];</pre><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>The line that subtracts the light <span>direction</span><a id="id325628672" class="indexterm"></a> from the normal occurs inside the <code class="literal">for</code> loop. This is because we do this for every light in the scene, as every light has its own light direction:</li></ol></div><pre class="programlisting">for(int i = 0; i &lt; numLights; i++) {
  vec4 positionLight = uModelViewMatrix * vec4(uLightPosition[i], 
   1.0);
  vec3 directionLight = vec3(uNormalMatrix * 
   vec4(uLightDirection[i], 1.0));
  vNormal[i] = normal - directionLight;
  vLightRay[i] = vertex.xyz - positionLight.xyz;
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>Here, the light direction is transformed by the Normal matrix while the light position is transformed by the Model-View matrix.</li><li>In the fragment shader, we calculate the Lambert coefficients: one per light and fragment. The key difference is this line in the fragment shader:</li></ol></div><pre class="programlisting">N = normalize(vNormal[i]);</pre><div class="orderedlist"><ol class="orderedlist arabic" start="8" type="1"><li>Here, we obtain the interpolated updated normal per light.</li><li>Let's create a cut-off by restricting the allowed Lambert coefficients. There are at least two different ways to obtain a light cone in the fragment shader. The first one consists of restricting the Lambert coefficient to be higher than the <code class="literal">uCutOff</code> uniform (cut-off value). Let's take a look at the fragment shader:</li></ol></div><pre class="programlisting">if (lambertTerm &gt; uCutOff) {
  finalColor += uLightDiffuse[i] * uMaterialDiffuse;
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="10" type="1"><li>The Lambert coefficient is the cosine of the angle between the reflected light and the surface normal. If the light ray is perpendicular to the surface, we obtain the highest Lambert coefficient, and as we move away from the center, the Lambert coefficients change following the cosine function until the light rays are completely parallel to the surface. This creates a cosine of <code class="literal">90</code> degrees between the normal and the light ray. This produces a Lambert coefficient of zero:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788629690/graphics/628a122f-21b2-4e2c-8238-bf69129fb3a3.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="11" type="1"><li>Open <code class="literal">ch06_06_wall-spot-light.html</code> in your browser if you haven’t done so yet. Use the cut-off slider on the page. Notice how this affects the light cone by making it wider or narrower. After playing with the slider, you’ll probably notice that these lights don’t look very realistic. The reason is that the final color is the same regardless of what Lambert coefficient you obtained: as long as the Lambert coefficient is higher than the set cut-off value, you will obtain the full diffuse contribution from the three light sources.</li><li>To refine the result, open the web page using your source code editor. Then, go to the fragment shader and multiply the Lambert coefficient in the line that <span>calculates</span><a id="id325643415" class="indexterm"></a> the final color:</li></ol></div><pre class="programlisting">finalColor += uLightDiffuse[i] * uMaterialDiffuse * lambertTerm;</pre><div class="orderedlist"><ol class="orderedlist arabic" start="13" type="1"><li>Save the web page with a different name (so you can keep the original) and then load it in your web browser. You will notice that the light colors are attenuated as you depart from the center of each light reflection on the wall. This may look better, but there’s a simpler way to create more realistic light cut-offs:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788629690/graphics/b61c8dd2-8230-4b15-8a36-900145c98d7f.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="14" type="1"><li>Let's create a cut-off by using an <span class="strong"><strong>exponential attenuation factor</strong></span>. In the <span>fragment</span><a id="id325656615" class="indexterm"></a> shader, find the following code:</li></ol></div><pre class="programlisting">if (lambertTerm &gt; uCutOff) {
  finalColor += uLightDiffuse[i] * uMaterialDiffuse * lambertTerm;
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="15" type="1"><li>Replace it with the following:</li></ol></div><pre class="programlisting">finalColor += uLightDiffuse[i] * uMaterialDiffuse * pow(lambertTerm, 10.0 * uCutOff);</pre><div class="orderedlist"><ol class="orderedlist arabic" start="16" type="1"><li>Notice that we’ve removed the <code class="literal">if</code> condition. This time, the attenuation factor is <code class="literal">pow(lambertTerm, 10.0 * uCutOff);</code>.</li><li>This modification works as the factor <span>attenuates</span><a id="id325659801" class="indexterm"></a> the final color exponentially. If the Lambert coefficient is close to zero, the final color will be heavily attenuated:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788629690/graphics/b0385fef-ff69-4e17-9f99-688a68f23ece.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="18" type="1"><li>Save the web page with a <span>different</span><a id="id325659827" class="indexterm"></a> name and load it in your browser. The improvement is dramatic:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788629690/graphics/072ead8d-86d1-4f72-8620-8a0680b63ebb.png" /></div><p>We’ve included the completed exercises here:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">ch06_07_wall-spot-light-proportional.html</code></li><li style="list-style-type: disc"><code class="literal">ch06_08_wall-spot-light-exponential.html</code></li></ul></div><p><span class="emphasis"><em><span class="strong"><strong>What just happened?</strong></span></em></span></p><p>We’ve learned how to implement directional point lights. We have also discussed attenuation factors that improve lighting effects.</p></div>