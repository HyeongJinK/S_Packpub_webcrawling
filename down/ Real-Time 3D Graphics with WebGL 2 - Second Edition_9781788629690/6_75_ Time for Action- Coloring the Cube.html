<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec81"></a>Time for Action: Coloring the Cube</h2></div></div><hr /></div><p>Let's cover a simple <span>example</span><a id="id325358908" class="indexterm"></a> of <span>coloring</span><a id="id325358921" class="indexterm"></a> a geometry:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Open the <code class="literal">ch06_01_cube.html</code> file using your browser. You will see a page similar to the following:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788629690/graphics/817db09c-d8ac-4697-a45c-3fbaea5c844f.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>In this exercise, weâ€™re going to compare constant versus per-vertex coloring. Let's talk about the page's widgets:
<div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><strong class="userinput"><code>Lambert</code></strong>: When selected, it will include the Lambert coefficient in the calculation of the final color.</li><li style="list-style-type: disc"><strong class="userinput"><code>Per Vertex</code></strong>: The two different coloring methods explained before: per-vertex or constant.</li><li style="list-style-type: disc"><strong class="userinput"><code>Complex Cube</code></strong>: Loads a JSON object where the vertices are repeated with the goal of obtaining multiple normals and multiple colors per vertex. We will explain how this works later on.</li><li style="list-style-type: disc"><strong class="userinput"><code>Alpha Value</code></strong>: This slider is mapped to the <code class="literal">uAlpha</code> float uniform in the vertex shader. <code class="literal">uAlpha</code> sets the alpha value for the vertex color.</li></ul></div></li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>Disable the use of the Lambert coefficient by clicking on <strong class="userinput"><code>Lambert</code></strong>. Rotate the cube by clicking and dragging. Notice the loss of depth perception when the Lambert coefficient is not <span>included</span><a id="id325638036" class="indexterm"></a> in the final color calculation. The <strong class="userinput"><code>Lambert</code></strong> button is mapped to the <code class="literal">uUseLambert</code> Boolean uniform. The code that calculates the Lambert coefficient can be found in the vertex shader included in the page:</li></ol></div><pre class="programlisting">float lambertTerm = 1.0;

if (uUseLambert) {
  vec3 normal = vec3(uNormalMatrix * vec4(aVertexNormal, 1.0));
  vec3 lightDirection = normalize(-uLightPosition);
  lambertTerm = max(dot(normal, -lightDirection), 0.20);
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>If the <code class="literal">uUseLambert</code> uniform is <code class="literal">false</code>, then <code class="literal">lambertTerm</code> remains as <code class="literal">1.0</code>, not affecting the final diffuse term here:</li></ol></div><pre class="programlisting">Id = uLightDiffuse * uMaterialDiffuse * lambertTerm;</pre><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>Otherwise, <code class="literal">Id</code> will have the Lambert coefficient factored in.</li><li>Having <strong class="userinput"><code>Lambert</code></strong> disabled, click on the <strong class="userinput"><code>Per Vertex</code></strong> button. Rotate the cube to see how ESSL interpolates the vertex colors. The vertex shader key code fragment that allows us to switch from a constant diffuse color to per-vertex colors uses the <code class="literal">uUseVertexColors</code> Boolean uniform and the <code class="literal">aVertexColor</code> attribute. This fragment is shown here:</li></ol></div><pre class="programlisting">if (uUseVertexColor) {
  Id = uLightDiffuse * aVertexColor * lambertTerm;
}
else {
  Id = uLightDiffuse * uMaterialDiffuse * lambertTerm;
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="7" type="1"><li>Take a look at the <code class="literal">common/models/geometries/cube-simple.json</code> file. There, the eight vertices of the cube are defined in the vertices array and there is an element in the scalars array for every vertex. As you may expect, each one of these elements corresponds to a respective vertex color, as shown in the following diagram:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788629690/graphics/aecf4c5b-6b51-4b7f-ad90-fa7e4d8fda8e.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="8" type="1"><li>Make sure that the <strong class="userinput"><code>Lambert</code></strong> button is not active and then click on the <strong class="userinput"><code>Complex Cube</code></strong> button. By repeating vertices in the vertex array in the corresponding JSON file, <code class="literal">common/models/geometries/cube-complex.json</code>, we can achieve independent face-coloring. The <span>following</span><a id="id325656677" class="indexterm"></a> diagram explains how the vertices are organized in <code class="literal">cube-complex.json</code>. Note that as the definition of colors occurs by vertex (since we are using the shader attribute), we need to repeat each color four times, because each face has four vertices. This idea is depicted in the following diagram:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788629690/graphics/9afca798-4565-4ca8-8375-56df9cd1344b.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="9" type="1"><li>Activate the <strong class="userinput"><code>Lambert</code></strong> button to see how the Lambert coefficient affects the color of the object. Try different button configurations to see what happens.</li><li>Let's quickly explore the effect of <span>changing</span><a id="id325659819" class="indexterm"></a> the alpha channel to a value less than <code class="literal">1.0</code>. What do you see? Notice that the object does not become transparent but instead starts losing its color. To obtain transparency, we need to activate blending. We will discuss blending in depth later in this chapter. For now, uncomment these lines in the <code class="literal">configure</code> function, in the source code:</li></ol></div><pre class="programlisting">// gl.disable(gl.DEPTH_TEST);
// gl.enable(gl.BLEND);
// gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);</pre><div class="orderedlist"><ol class="orderedlist arabic" start="11" type="1"><li>Save the page and reload it in your internet browser. If you select <strong class="userinput"><code>Per-Vertex</code></strong>, <strong class="userinput"><code>Complex Cube</code></strong> and reduce the alpha value to <code class="literal">0.5</code>, you will see something like the following screenshot:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788629690/graphics/929b43ea-3b68-4cab-a39a-4cead317947b.png" /></div><p><span class="emphasis"><em><span class="strong"><strong>What just happened?</strong></span></em></span></p><p>We have studied two different ways of coloring objects: <span class="strong"><strong>constant coloring</strong></span> and <span class="strong"><strong>per-vertex coloring</strong></span>. In both cases, the final color of each fragment is assigned by <span>exporting</span><a id="id325659911" class="indexterm"></a> a color variable via an <code class="literal">out</code> qualifier in the fragment shader.</p><p>We saw that by activating the calculation of the Lambert coefficient, we obtain sensory depth information.</p><p>We also saw that repeating vertices in our object allows us to obtain different coloring effects. For instance, we can color an object by faces instead of by vertices.</p></div>