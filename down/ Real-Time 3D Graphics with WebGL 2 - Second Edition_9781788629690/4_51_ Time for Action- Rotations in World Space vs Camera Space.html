<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec59"></a>Time for Action: Rotations in World Space vs Camera Space</h2></div></div><hr /></div><p>Let's cover an <span>example</span><a id="id325358908" class="indexterm"></a> showing the different rotations in different spaces:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Open <code class="literal">ch04_02_model-view-rotation.html</code> in your browser:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788629690/graphics/501c964d-cad0-4f4d-abe8-f98f96efdf6d.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>As we did in the previous example, we will see the following:
<div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">A cone at the origin of the world</li><li style="list-style-type: disc">The camera is located at <code class="literal">[0, 2, 50]</code> in world coordinates</li><li style="list-style-type: disc">Three sliders that allow us to rotate either the world or the camera</li><li style="list-style-type: disc">A matrix where we can see the result of different rotations</li></ul></div></li><li>Let's see what happens to the axis after we apply a rotation. With the <span class="strong"><strong>World </strong></span>coordinates selected, rotate the world <code class="literal">90</code> degrees around the x-axis. What does the Model-View matrix look like?</li><li>Let's see where the axes end up after a <code class="literal">90</code> degree rotation around the x-axis:
<div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">By looking at the first column, we can see that the x-axis has not changed. It's still <code class="literal">[1, 0, 0]</code>. This makes sense since we are rotating around this axis.
</li><li style="list-style-type: disc">The second column of the matrix indicates where the y-axis is after the rotation. In this case, we went from <code class="literal">[0, 1, 0]</code>, which is the original configuration, to <code class="literal">[0, 0, 1]</code>, which is the axis that is coming out of the screen. This is the z-axis in the initial configuration. This makes sense since we are now looking from above, down at the cone.</li><li style="list-style-type: disc">The third column of the matrix indicates the new location of the z-axis. It changed from <code class="literal">[0, 0, 1]</code>, which as we know, is the z-axis in the standard spatial configuration (without transforms), to <code class="literal">[0, -1, 0]</code>, which is the negative portion of the y-axis in the original configuration. This makes sense since we rotated around the x-axis:</li></ul></div></li></ol></div><div class="mediaobject"><img src="/graphics/9781788629690/graphics/9d0de387-2677-47a6-a84c-f51ebfdf3dcf.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>As we've just seen, understanding the <span>rotation</span><a id="id325617296" class="indexterm"></a> matrix (the 3x3 upper-left corner of the Model-View matrix) is simple: the first 3 columns always tell us where the axis is.</li><li>Where are the axes in the following transformation? Take a look at the following diagram:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788629690/graphics/58587cd2-ec19-4c08-b15b-1766cccdeeb6.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="7" type="1"><li>Check your answer by using the sliders to achieve the rotation that you believe produces this matrix.</li><li>Let's see how rotations work in <span class="strong"><strong>Camera </strong></span>space by changing the coordinates, selection.</li><li>Increase the angle of rotation in the x-axis by incrementing the slider position. What do you notice?</li><li>Using the sliders, try different rotations in camera space.</li><li>Are the rotations <span class="emphasis"><em>commutative</em></span>? That is, do you get the same result if you rotate, for example, <code class="literal">5</code> degrees on the x-axis and <code class="literal">90</code> degrees on the z-axis, compared to the case where you rotate <code class="literal">90</code> degrees on the z-axis and then <code class="literal">5</code> degrees on the x-axis?</li><li>Return to <strong class="userinput"><code>World </code></strong>space. Please remember that when you're in <strong class="userinput"><code>World </code></strong>space, you need to reverse the rotations to obtain the same pose, for example, if you were applying <code class="literal">5</code> degrees on the x-axis and <code class="literal">90</code> degrees on the z-axis, verify that when you apply <code class="literal">-5</code> degrees on the x-axis and <code class="literal">-90</code> degrees on the z-axis, you obtain the same result.</li></ol></div><p><span class="emphasis"><em><span class="strong"><strong>What just happened?</strong></span></em></span></p><p>We've just learned that the Camera matrix <span>rotation</span><a id="id325401511" class="indexterm"></a> is the inverse of the Model-View matrix rotation. We've also learned how to identify the orientation of our world or camera after analyzing the rotation matrix (3x3 upper-left corner of the correspondent transformation matrix).</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec74"></a>Have a Go: Combining Rotations and Translations</h3></div></div></div><p>Let's see how we can <span>combine</span><a id="id325401526" class="indexterm"></a> rotations and translations together:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>The <code class="literal">ch04_03_model-view.html</code> file contains the combination of rotations and translations. When you open it your browser, you will see something like this:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788629690/graphics/767406b8-7b2a-43af-a3ae-72684539881f.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Try different configurations of rotations and translations in both the <span class="strong"><strong>World </strong></span>and <span class="strong"><strong>Camera</strong></span> spaces.</li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec75"></a>Camera Matrix Is the Inverse of the Model-View Matrix</h3></div></div></div><p>These two scenarios <span>help</span><a id="id325662152" class="indexterm"></a> us appreciate that a Camera matrix is the exact opposite of the Model-View matrix. In linear algebra, this property is <span>known</span><a id="id325662162" class="indexterm"></a> as the <span class="strong"><strong>inverse</strong></span> of a matrix.</p><p>The inverse of a matrix is such that when multiplying it by the original matrix, we obtain the Identity matrix. In other words, if <code class="literal">M</code> is the Model-View matrix and <code class="literal">C</code> is the Camera matrix, we get the following:</p><pre class="programlisting"><div class="mediaobject"><img src="/graphics/9781788629690/graphics/50a7a7f5-1b10-4e40-a44a-0ec3c165c05b.png" /></div></pre><pre class="programlisting"><div class="mediaobject"><img src="/graphics/9781788629690/graphics/6c12f395-aa8b-4186-96e7-3f1fba220bc4.png" /></div></pre><pre class="programlisting"><div class="mediaobject"><img src="/graphics/9781788629690/graphics/ed41c65d-a4cf-47ee-af78-cf7e3301345c.png" /></div></pre><p>We can create the Camera matrix using <span class="strong"><strong>glMatrix</strong></span> by writing something like the following:</p><pre class="programlisting">const cameraMatrix = mat4.create();
mat4.invert(cameraMatrix, modelViewMatrix);</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec76"></a>Thinking About Matrix Multiplications in WebGL</h3></div></div></div><p>Before moving forward, we <span>should</span><a id="id325628661" class="indexterm"></a> note that in WebGL, matrix operations are written in the <span class="emphasis"><em>reverse order</em></span> in which they are applied to the vertices. This is an <span>important</span><a id="id325628673" class="indexterm"></a> note that's often confusing for developers new to 3D graphics.</p><p>Let's assume, for a moment, that you are writing the code to rotate/move the world; that is, you rotate your vertices around the origin and then you move away. The final transformation would look like this:</p><pre class="programlisting"><div class="mediaobject"><img src="/graphics/9781788629690/graphics/52e3a181-8b7d-490d-b08a-1aae18471ecd.png" /></div></pre><p>Here, <code class="literal">R</code> is the 4x4 matrix-encoding pure rotation;  <code class="literal">T</code> is the 4x4 matrix-encoding pure translation, and <code class="literal">v</code> corresponds to the vertices present in your scene (in Homogeneous coordinates).</p><p>Now, you should have noticed that the first transformation we apply to the vertices is the translation, and then we apply the rotation. Vertices need to be multiplied first by the matrix that is to the left. In this scenario, that matrix is <code class="literal">T</code>. Then, the result needs to be multiplied by <code class="literal">R</code>.</p><p>This fact is reflected in the order of the operations (here, <code class="literal">modelViewMatrix</code> is the Model-View matrix):</p><pre class="programlisting">mat4.identity(modelViewMatrix);
mat4.translate(modelViewMatrix, modelViewMatrix, position);
mat4.rotateX(modelViewMatrix, modelViewMatrix, rotation[0] * Math.PI / 180);</pre><pre class="programlisting">mat4.rotateY(modelViewMatrix, modelViewMatrix, rotation[1] * Math.PI / 180);
mat4.rotateZ(modelViewMatrix, modelViewMatrix, rotation[2] * Math.PI / 180);</pre><p>If we were working in camera coordinates and we wanted to apply the same transformation as before, we need to apply a bit of linear algebra first:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal"><div class="mediaobject"><img src="/graphics/9781788629690/graphics/b82380c5-1b50-4f6e-8850-f4995fe41952.png" /></div></code></p></td><td style="border-bottom: 0.5pt solid ; "><p>The Model-View <code class="literal">M</code> matrix is the result of multiplying rotation and translation together.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal"><div class="mediaobject"><img src="/graphics/9781788629690/graphics/a269b44b-f79f-4c7a-bf8f-d3954017a695.png" /></div></code></p></td><td style="border-bottom: 0.5pt solid ; "><p>We know that the Camera matrix is the inverse of the Model-View matrix.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal"><div class="mediaobject"><img src="/graphics/9781788629690/graphics/e266460c-625a-42a5-b4b3-23a40aaa0932.png" /></div></code></p></td><td style="border-bottom: 0.5pt solid ; "><p>By substitution.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal"><div class="mediaobject"><img src="/graphics/9781788629690/graphics/5d530693-bbd4-4e6a-845e-95a47100b569.png" /></div></code></p></td><td style=""><p>The inverse of a matrix product is the reverse product of the inverses.</p></td></tr></tbody></table></div><p> </p><p>Fortunately, when we're working in camera coordinates in this chapter's examples, we have the inverse translation and the inverse rotation already calculated in the global variables position and rotation. Therefore, we would write something such as this in the code (here, <code class="literal">cameraMatrix</code> is the Camera matrix):</p><pre class="programlisting">mat4.identity(cameraMatrix);
mat4.rotateX(cameraMatrix, cameraMatrix, rotation[0] * Math.PI / 180);
mat4.rotateY(cameraMatrix, cameraMatrix, rotation[1] * Math.PI / 180);
mat4.rotateZ(cameraMatrix, cameraMatrix, rotation[2] * Math.PI / 180);
mat4.translate(cameraMatrix, cameraMatrix, position);</pre></div></div>