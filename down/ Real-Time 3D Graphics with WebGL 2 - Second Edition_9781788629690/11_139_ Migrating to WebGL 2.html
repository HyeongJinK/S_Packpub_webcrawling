<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch11lvl1sec140"></a>Migrating to WebGL 2</h2></div></div><hr /></div><p>As we <span>described</span><a id="id325357458" class="indexterm"></a> previously, WebGL 2 is nearly 100 percent <span>backward</span><a id="id325358859" class="indexterm"></a> compatible with WebGL 1.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note98"></a>Note</h3><p><strong class="userinput"><code>Backward Compatibility</code></strong>
All exceptions to backward compatibility are recorded at the following link: <a class="ulink" href="https://www.khronos.org/registry/webgl/specs/latest/2.0/#BACKWARDS_INCOMPATIBILITY" target="_blank">https://www.khronos.org/registry/WebGL/specs/latest/2.0/#BACKWARDS_INCOMPATIBILITY</a>.</p></div><p>That being said, let's cover some key components of migrating a WebGL 1 application to WebGL 2.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec193"></a>Attaining context</h3></div></div></div><p>In WebGL 1, you'd attain a WebGL context <span>with</span><a id="id325358888" class="indexterm"></a> something that looks like the following:</p><pre class="programlisting">const names = ['WebGL', 'experimental-WebGL', 'webkit-3d', 'moz-WebGL'];

for (let i = 0; i &lt; names.length; ++i) {
try {
const context = canvas.getContext(names[i]);
// work with context
} catch (e) {
    console.log('Error attaining WebGL context', e);
}
}</pre><p>In WebGL 2, you'd simply attain the context <span>with</span><a id="id325359212" class="indexterm"></a> a single line, as follows:</p><pre class="programlisting">const context = canvas.getContext('WebGL 2');
</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec194"></a>Extensions</h3></div></div></div><p>While in WebGL many <span>optional</span><a id="id325359233" class="indexterm"></a><span class="emphasis"><em> </em></span>extensions were <span class="emphasis"><em>required</em></span> for more advanced functionality, in WebGL 2 you can remove most of those extensions, because they are available by <span class="emphasis"><em>default</em></span>. Some of these include the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Depth textures: <a class="ulink" href="https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/" target="_blank">https://www.khronos.org/registry/WebGL/extensions/WebGL_depth_texture</a></li><li style="list-style-type: disc">Floating point textures:
<div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><a class="ulink" href="https://www.khronos.org/registry/webgl/extensions/OES_texture_float" target="_blank">https://www.khronos.org/registry/WebGL/extensions/OES_texture_float</a></li><li style="list-style-type: disc"><a class="ulink" href="https://www.khronos.org/registry/webgl/extensions/OES_texture_float_linear" target="_blank">https://www.khronos.org/registry/WebGL/extensions/OES_texture_float_linear</a></li></ul></div></li><li style="list-style-type: disc">Vertex array objects: <a class="ulink" href="https://www.khronos.org/registry/webgl/extensions/OES_vertex_array_object" target="_blank">https://www.khronos.org/registry/WebGL/extensions/OES_vertex_array_object</a></li><li style="list-style-type: disc">Standard derivatives: <a class="ulink" href="https://www.khronos.org/registry/webgl/extensions/OES_standard_derivatives" target="_blank">https://www.khronos.org/registry/WebGL/extensions/OES_standard_derivatives</a></li><li style="list-style-type: disc">Instanced drawing: <a class="ulink" href="https://www.khronos.org/registry/webgl/extensions/ANGLE_instanced_arrays" target="_blank">https://www.khronos.org/registry/WebGL/extensions/ANGLE_instanced_arrays</a></li><li style="list-style-type: disc"><code class="literal">UNSIGNED_INT</code> indices: <a class="ulink" href="https://www.khronos.org/registry/webgl/extensions/OES_element_index_uint" target="_blank">https://www.khronos.org/registry/WebGL/extensions/OES_element_index_uint</a></li><li style="list-style-type: disc">Setting gl_FragDepth: <a class="ulink" href="https://www.khronos.org/registry/webgl/extensions/EXT_frag_depth" target="_blank">https://www.khronos.org/registry/WebGL/extensions/EXT_frag_depth</a></li><li style="list-style-type: disc">Blend equation <code class="literal">MIN</code>/<code class="literal">MAX</code>: <a class="ulink" href="https://www.khronos.org/registry/webgl/extensions/EXT_blend_minmax" target="_blank">https://www.khronos.org/registry/WebGL/extensions/EXT_blend_minmax</a></li><li style="list-style-type: disc">Direct texture LOD access: <a class="ulink" href="https://www.khronos.org/registry/webgl/extensions/EXT_shader_texture_lod" target="_blank">https://www.khronos.org/registry/WebGL/extensions/EXT_shader_texture_lod</a></li><li style="list-style-type: disc">Multiple draw buffers: <a class="ulink" href="https://www.khronos.org/registry/webgl/extensions/WEBGL_draw_buffers" target="_blank">https://www.khronos.org/registry/WebGL/extensions/WebGL_draw_buffers</a></li><li style="list-style-type: disc">Texture access in vertex shaders</li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec195"></a>Shader Updates</h3></div></div></div><p>While WebGL 2's shader language, based on GLSL 300, is <span>backward</span><a id="id325617361" class="indexterm"></a> compatible with WebGL 1's shader language, we need to make a few changes to ensure that our shaders compile. Let's cover them now.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch11lvl3sec47"></a>Shader Definitions</h4></div></div></div><p>With WebGL 2's shaders, we have to <span>prepend</span><a id="id325617376" class="indexterm"></a> all shaders with the following line of code: <code class="literal">#version 300 es</code>. It’s important to note that this <span class="emphasis"><em>must </em></span>be the very first line in the shader, otherwise the shader will not compile.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch11lvl3sec48"></a>Attribute Definitions</h4></div></div></div><p>Given that attributes are <span class="emphasis"><em>provided as inputs </em></span>to shaders, in GLSL 300 ES, the <code class="literal">attribute</code> qualifier is removed. For example, with WebGL's GLSL 100, you <span>might</span><a id="id325629092" class="indexterm"></a> have the following:</p><pre class="programlisting">attribute vec3 aVertexNormal;
attribute vec4 aVertexPosition;</pre><p>In GLSL 300 ES, this would be as follows:</p><pre class="programlisting">in vec3 aVertexNormal;
in vec4 aVertexPosition;</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch11lvl3sec49"></a>Varying Definitions</h4></div></div></div><p>While in GLSL 100, varyings are <span>often</span><a id="id325631883" class="indexterm"></a> defined in both the vertex and fragment shaders, the <code class="literal">varying</code> qualifier has been removed in GLSL 300 ES. That is, varying qualifiers are updated with their appropriate <code class="literal">in</code> and <code class="literal">out</code> qualifiers, depending on whether the values are provided as <span class="emphasis"><em>inputs</em></span> or returned as <span class="emphasis"><em>outputs</em></span>. For example, consider the following from GLSL 100:</p><pre class="programlisting">// inside of the vertex shader
varying vec2 vTexcoord;
varying vec3 vNormal;

// inside of the fragment shader
varying vec2 vTexcoord;
varying vec3 vNormal;</pre><p>This would be changed to the following in GLSL 300 ES:</p><pre class="programlisting">// inside of the vertex shader
out vec2 vTexcoord;
out vec3 vNormal;

// inside of the fragment shader
in vec2 vTexcoord;
in vec3 vNormal;</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch11lvl3sec50"></a>No More gl_FragColor</h4></div></div></div><p>While in GLSL 100 you'd ultimately <span>render</span><a id="id325638069" class="indexterm"></a> the color of the pixel by setting the <code class="literal">gl_FragColor</code> inside of the fragment shader, in GLSL 300 ES, you simply expose a value from your fragment shader. Consider, for example, the following in GLSL 100:</p><pre class="programlisting">void main(void) {
  gl_FragColor = vec4(1.0, 0.2, 0.3, 1.0);
}</pre><p>This would be updated by setting a defined custom output variable, as follows:</p><pre class="programlisting">out vec4 fragColor;

void main(void) {
  fragColor = vec4(1.0, 0.2, 0.3, 1.0);
}</pre><p>It's important to note that even though we declared a variable called <code class="literal">fragColor</code>, you can choose any name not starting with the prefix <code class="literal">gl_</code>, due to ambiguity. Throughout this book, we have defined this custom variable as <code class="literal">fragColor</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch11lvl3sec51"></a>Automatic Texture Type Detection</h4></div></div></div><p>While in GLSL 100 you'd get a <span>color</span><a id="id325643403" class="indexterm"></a> from a texture by using the appropriate methods, such as <code class="literal">texture2D</code>, in GLSL 300 ES, shaders automatically detect the type based on the sampler type in use. For example, consider the following in GLSL 100:</p><pre class="programlisting">uniform sampler2D uSome2DTexture;
uniform samplerCube uSomeCubeTexture;

void main(void) {
vec4 color1 = texture2D(uSome2DTexture, ...);
vec4 color2 = textureCube(uSomeCubeTexture, ...);
}</pre><p>This would be updated to the following in GLSL 300 ES:</p><pre class="programlisting">uniform sampler2D uSome2DTexture;
uniform samplerCube uSomeCubeTexture;

void main(void) {
vec4 color1 = texture(uSome2DTexture, ...);
vec4 color2 = texture(uSomeCubeTexture, ...);
}</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec196"></a>Non-Power of 2 Texture Support</h3></div></div></div><p>As demonstrated in <a class="link" href="#" linkend="ch07">Chapter 7</a>, <span class="emphasis"><em>Textures</em></span>, in WebGL 1, mipmaps don't exist <span>for</span><a id="id325643476" class="indexterm"></a> textures that don't conform to the <span class="emphasis"><em>power of 2</em></span> restriction. In WebGL 2, however, non-power of 2 textures work exactly the same as power of 2 textures.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec197"></a>Floating Point Framebuffer Attachments</h3></div></div></div><p>While in WebGL 1 a strange hack is <span>required</span><a id="id325643494" class="indexterm"></a> to check whether there is support for rendering to a floating point texture, in WebGL 2, this involves a simple check via standard methods.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec198"></a>Vertex Array Objects</h3></div></div></div><p>While using vertex array <span>objects</span><a id="id325647094" class="indexterm"></a> is not a <span class="emphasis"><em>necessary </em></span>requirement, it's a highly <span class="emphasis"><em>recommended </em></span>feature to use in your migration. By using vertex array objects, you can improve both the overall structure of your code and the performance of your application.</p></div></div>