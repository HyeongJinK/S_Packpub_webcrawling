<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec45"></a>Back to WebGL</h2></div></div><hr /></div><p>It’s time to go <span>back</span><a id="id325358908" class="indexterm"></a> to our JavaScript code, but we now need to consider how to close the gap between our JavaScript code and our ESSL code. First, we need to take a look at how we create a <span class="strong"><strong>program</strong></span> using our WebGL context. Please remember that we refer to both the vertex shader and fragment shader as the program. Second, we need to know how to initialize attributes and uniforms.</p><p>Let's take a look at the structure of the web apps we have developed so far:</p><div class="mediaobject"><img src="/graphics/9781788629690/graphics/5c995fc4-216c-4f8c-8016-b485097573ac.png" /></div><p>Each application has a vertex shader and a fragment shader embedded in the web page. In addition, there is a script section where we write all of our WebGL code. Finally, we have the HTML code that defines the page components, such as titles and the location of the widgets and the <code class="literal">canvas</code>.</p><p>In the JavaScript code, we are calling the <code class="literal">init</code> function on the <code class="literal">onload</code> event of the web page. This is the entry point for our application. The first thing that <code class="literal">init</code> does is obtain a WebGL context for the <code class="literal">canvas</code> within <code class="literal">initProgram</code>, and then calls a series of functions that initialize the program, the WebGL buffers, and the lights. Finally, it gets into a render loop where every time that the loop goes off, the <code class="literal">draw</code> function is invoked.</p><p>In this section, we will take a closer look at the <code class="literal">initProgram</code> and <code class="literal">initLights</code> functions. <code class="literal">initProgram</code> allows us to create and compile an ESSL program while <code class="literal">initLights</code> allows us to initialize and pass values to the uniforms defined in the programs. It is inside <code class="literal">initLights</code> where we will define the light's position, direction, and color components (ambient, diffuse, and specular) as well as default values for material properties.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec58"></a>Creating a Program</h3></div></div></div><p>To start, open up <code class="literal">ch03_05_wall.html</code> in an editor. Let's <span>take</span><a id="id325659865" class="indexterm"></a> a step-by-step look at <code class="literal">initProgram</code>:</p><pre class="programlisting">function initProgram() {
const canvas = utils.getCanvas('webgl-canvas');
utils.autoResizeCanvas(canvas);

gl = utils.getGLContext(canvas);
gl.clearColor(0.9, 0.9, 0.9, 1);
gl.clearDepth(100);
gl.enable(gl.DEPTH_TEST);
gl.depthFunc(gl.LEQUAL);

const vertexShader = utils.getShader(gl, 'vertex-shader');
const fragmentShader = utils.getShader(gl, 'fragment-shader');

program = gl.createProgram();
gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);
gl.linkProgram(program);

if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error('Could not initialize shaders');
}

  gl.useProgram(program);

program.aVertexPosition = gl.getAttribLocation(program, 
   'aVertexPosition');
program.aVertexNormal = gl.getAttribLocation(program, 'aVertexNormal');

program.uProjectionMatrix = gl.getUniformLocation(program, 
   'uProjectionMatrix');
program.uModelViewMatrix = gl.getUniformLocation(program, 
   'uModelViewMatrix');
program.uNormalMatrix = gl.getUniformLocation(program, 
   'uNormalMatrix');
program.uLightDirection = gl.getUniformLocation(program, 
   'uLightDirection');
program.uLightAmbient = gl.getUniformLocation(program, 'uLightAmbient');
program.uLightDiffuse = gl.getUniformLocation(program, 'uLightDiffuse');
program.uMaterialDiffuse = gl.getUniformLocation(program, 
   'uMaterialDiffuse');
}</pre><p>First, we retrieve a WebGL context, as we've seen in previous chapters. Then, we use the <code class="literal">utils.getShader</code> utility function to retrieve the contents of the vertex shader and the fragment shader:</p><pre class="programlisting">const canvas = utils.getCanvas('webgl-canvas');
utils.autoResizeCanvas(canvas);

gl = utils.getGLContext(canvas);
gl.clearColor(0.9, 0.9, 0.9, 1);
gl.clearDepth(100);
gl.enable(gl.DEPTH_TEST);
gl.depthFunc(gl.LEQUAL);

const vertexShader = utils.getShader(gl, 'vertex-shader');
const fragmentShader = utils.getShader(gl, 'fragment-shader');</pre><p>The program's creation occurs in the following lines:</p><pre class="programlisting">program = gl.createProgram();
gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);
gl.linkProgram(program);

if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
alert('Could not initialize shaders');
}

gl.useProgram(program);</pre><p>Here, we have used several functions <span>provided</span><a id="id325659902" class="indexterm"></a> by the WebGL context. These include the ones shown in the following table:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>WebGL Function</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Description</strong></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">createProgram()</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Creates a new program (<span class="emphasis"><em>program</em></span>).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">attachShader(program, shader)</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Attaches a shader to the current program.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">linkProgram(program)</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Creates executable versions of the vertex and fragment shaders that are passed to the GPU.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">getProgramParameter(program, parameter)</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>This is part of the WebGL state-machine query mechanism. It allows you to query the program parameters. We use this function to verify whether the program has been successfully linked.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">useProgram(program)</code></p></td><td style=""><p>It will load the program onto the GPU if the program contains valid code (that is, it has been successfully linked).</p></td></tr></tbody></table></div><p> </p><p>Finally, we <span>create</span><a id="id325662201" class="indexterm"></a> a <span class="strong"><strong>mapping</strong></span> between JavaScript variables and the program attributes and uniforms:</p><pre class="programlisting">program.aVertexPosition = gl.getAttribLocation(program, 'aVertexPosition');
program.aVertexNormal = gl.getAttribLocation(program, 'aVertexNormal');

program.uProjectionMatrix = gl.getUniformLocation(program, 'uProjectionMatrix');
program.uModelViewMatrix = gl.getUniformLocation(program, 'uModelViewMatrix');
program.uNormalMatrix = gl.getUniformLocation(program, 'uNormalMatrix');
program.uLightDirection = gl.getUniformLocation(program, 'uLightDirection');
program.uLightAmbient = gl.getUniformLocation(program, 'uLightAmbient');
program.uLightDiffuse = gl.getUniformLocation(program, 'uLightDiffuse');
program.uMaterialDiffuse = gl.getUniformLocation(program, 'uMaterialDiffuse');</pre><p>Instead of creating several JavaScript variables here (one per program <code class="literal">attribute</code> or <code class="literal">uniform</code>), we are attaching properties to the <code class="literal">program</code> object. This does not have anything to do with WebGL. It is just a convenience step to keep all of our JavaScript variables as part of the program object.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip46"></a>Note</h3><p><strong class="userinput"><code>WebGL Programs</code></strong><span class="strong"><strong></strong></span> Since we are attaching many of the important variables to our WebGL program, you may be wondering why we don't attach it to our WebGL context rather than the program. In our example, we're using a single <span class="strong"><strong>program</strong></span> because our example is small. As WebGL applications grow, you may find that you have several programs that you switch throughout your application with the <code class="literal">gl.useProgram</code> function.</p></div><p>All of this information pertains to <code class="literal">initProgram</code>. Here, we have used the following WebGL API functions:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>WebGL Function</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Description</strong></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">getAttribLocation(program, name)</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>This function receives the current program object and a string that contains the name of the attribute that needs to be retrieved. This function then returns a <span class="strong"><strong>reference</strong></span> to the respective <span class="strong"><strong>attribute</strong></span>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">getUniformLocation(program, name)</code></p></td><td style=""><p>This function receives the current program object and a string that contains the name of the uniform that needs to be retrieved. This function then returns a <span class="strong"><strong>reference</strong></span> to the respective <span class="strong"><strong>uniform</strong></span>.</p></td></tr></tbody></table></div><p> </p><p>Using this mapping, we can initialize the uniforms and attributes from our JavaScript code, as we will see in the next section.</p><p>Another addition to WebGL 2 is an increasingly optimized approach for getting item locations from the vertex shader. In our example, we use <code class="literal">getAttribLocation</code> and <code class="literal">getUniformLocation</code> for getting the locations of these items. If you inspect their return values, you'll see that they return <span class="emphasis"><em>whole numbers</em></span>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note47"></a>Note</h3><p>Whole numbers are simply the numbers 0, 1, 2, 3, 4, 5, ... (and so on).</p></div><p>Convention dictates that with large 3D applications, you can leverage tested design patterns and data structures to organize your code, which may include organizing shader resources in a predetermined or programmatic order.</p><p>One example would be to leverage the <span class="strong"><strong>layout qualifier </strong></span>to look up resource locations. Here's a simplified example from <a class="link" href="#" linkend="ch02">Chapter 2</a>, <span class="emphasis"><em>Rendering</em></span>, where we looked up and enabled both <code class="literal">aVertexPosition</code> and <code class="literal">aVertexColor</code> using <code class="literal">getAttribLocation</code>:</p><pre class="programlisting">const vertexPosition = gl.getAttribLocation(program, 'aVertexPosition');
gl.enableVertexAttribArray(vertexPosition);

const colorLocation = gl.getAttribLocation(program, 'aVertexColor');
gl.enableVertexAttribArray(colorLocation);</pre><p>And here is the associated vertex shader:</p><pre class="programlisting">#version 300 es

in vec4 aVertexPosition;
in vec3 aVertexColor;

out vec3 vVertexColor;

void main() {
  vVertexColor = aVertexColor;
gl_Position = aVertexPosition;
}</pre><p>These would turn into the following:</p><pre class="programlisting">const vertexPosition = 0;
gl.enableVertexAttribArray(vertexPosition);

const colorLocation = 1;
gl.enableVertexAttribArray(colorLocation);</pre><p>And here is the updated vertex shader:</p><pre class="programlisting">#version 300 es

<span class="strong"><strong>layout (location=0) in vec4 aVertexPosition;
layout (location=1) in vec3 aVertexColor</strong></span><span class="strong"><strong>;</strong></span>

out vec3 vVertexColor;

void main() {
  vVertexColor = aVertexColor;
gl_Position = aVertexPosition;
}</pre><p>As you can see, it's a subtle change <span>where</span><a id="id325359572" class="indexterm"></a> we define the locations using indices within the vertex shader and simply enable the items using those indices.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip48"></a>Note</h3><p><strong class="userinput"><code>Performance Hits</code></strong><span class="strong"><strong></strong></span> Every time we need to look up or set shader values from the JavaScript context, it comes at a performance cost. Because of this, we should always be careful of how often we perform such operations.</p></div><p>Although the layout qualifier is optimal, we will continue leveraging the traditional variable and definition lookup throughout this book, given that it’s more readable and requires less overhead.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note49"></a>Note</h3><p><strong class="userinput"><code>Layout Qualifiers</code></strong><span class="strong"><strong></strong></span> For more information on layout and other qualifiers, please visit <a class="ulink" href="https://www.khronos.org/opengl/wiki/Layout_Qualifier_(GLSL)" target="_blank">https://www.khronos.org/opengl/wiki/Layout_Qualifier_(GLSL)</a>.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec59"></a>Initializing Attributes and Uniforms</h3></div></div></div><p>Once we have compiled and <span>installed</span><a id="id325359613" class="indexterm"></a> the program, the next <span>step</span><a id="id325359657" class="indexterm"></a> is to initialize the attributes and variables. We will initialize our uniforms using the <code class="literal">initLights</code> function:</p><pre class="programlisting">function initLights() {
  gl.uniform3fv(program.uLightDirection, [0, 0, -1]);
gl.uniform4fv(program.uLightAmbient, [0.01, 0.01, 0.01, 1]);
gl.uniform4fv(program.uLightDiffuse, [0.5, 0.5, 0.5, 1]);
gl.uniform4f(program.uMaterialDiffuse, 0.1, 0.5, 0.8, 1);
}</pre><p>In this example, you can see that we’re using the references obtained with <code class="literal">getUniformLocation</code> (we did this in <code class="literal">initProgram</code>).</p><p>These are the functions that the WebGL API provides to set and get uniform values:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>WebGL Function</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Description</strong></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">uniform[1234][fi]</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Specifies 1-4 <code class="literal">float</code> or <code class="literal">int</code> values of a uniform variable.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">uniform[1234][fi]v</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Specifies the value of a uniform variable as an array of 1-4 <code class="literal">float</code> or <code class="literal">int</code> values.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">getUniform(program)</code></p></td><td style=""><p>Retrieves the contents of a uniform variable. The reference parameter has been previously obtained with <code class="literal">getUniformLocation</code>.</p></td></tr></tbody></table></div><p>In <a class="link" href="#" linkend="ch02">Chapter 2</a>, <span class="emphasis"><em>Rendering</em></span>, we learned that a four-step process is required to initialize and use attributes. Recall that we do the following:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Bind a VBO.</li><li>Point an attribute to the currently-bound VBO.</li><li>Enable the attribute.</li><li>Unbind the VBO.</li></ol></div><p>The key piece here is step <span class="emphasis"><em>2</em></span>. We do this with the following instruction:</p><pre class="programlisting">gl.vertexAttribPointer(index, size, type, normalize, stride, offset);</pre><p>If you check out the <code class="literal">ch03_05_wall.html</code> example, you will see that we do this inside the <code class="literal">draw</code> function:</p><pre class="programlisting">gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer);
gl.vertexAttribPointer(program.aVertexPosition, 3, gl.FLOAT, false, 0, 0);

gl.bindBuffer(gl.ARRAY_BUFFER, normalsBuffer);
gl.vertexAttribPointer(program.aVertexNormal, 3, gl.FLOAT, false, 0, 0);</pre></div></div>