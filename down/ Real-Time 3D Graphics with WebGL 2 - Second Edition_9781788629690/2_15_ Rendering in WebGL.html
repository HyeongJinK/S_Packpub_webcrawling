<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec25"></a>Rendering in WebGL</h2></div></div><hr /></div><p>WebGL handles geometry in a standard way, independent of the complexity and number of points that surfaces can have. There are two data types <span>that</span><a id="id325359442" class="indexterm"></a> are fundamental to represent the geometry of any 3D object: <span class="emphasis"><em>vertices</em></span> and <span class="emphasis"><em>indices</em></span>.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec22"></a>Vertices</h3></div></div></div><p><span class="strong"><strong>Vertices</strong></span> are the points <span>that</span><a id="id325617304" class="indexterm"></a> define the corners of 3D objects. Each <span>vertex</span><a id="id325617354" class="indexterm"></a> is represented by three floating-point numbers that correspond to the <code class="literal">x</code>, <code class="literal">y</code>, and <code class="literal">z</code> coordinates of the vertex. Unlike its cousin, OpenGL, WebGL does not provide API methods to pass independent vertices to the rendering pipeline; therefore, all of our vertices need to be written in a <span class="strong"><strong>JavaScript array</strong></span>, which <span>can</span><a id="id325617374" class="indexterm"></a> then be used to construct a WebGL vertex buffer.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec23"></a>Indices</h3></div></div></div><p><span class="strong"><strong>Indices</strong></span> are numeric <span>labels</span><a id="id325628653" class="indexterm"></a> for the vertices in a given 3D scene. Indices allow us to tell WebGL how to connect vertices in order to <span>produce</span><a id="id325631869" class="indexterm"></a> a surface. As with vertices, indices are stored in a JavaScript array and are then passed along to WebGL's rendering pipeline using a WebGL index buffer.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note10"></a>Note</h3><p><strong class="userinput"><code>VBOs Versus IBOs</code></strong>
There are two kinds of WebGL buffers used to describe and process geometry. Buffers that contain vertex data are known as <span class="strong"><strong>VBOs</strong></span>, and buffers that contain index data are known as <span class="strong"><strong>IBOs</strong></span>.</p></div><p>In this section, we will use the following steps to render an object in WebGL:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Define a geometry using JavaScript arrays</li><li>Create the respective WebGL buffers</li><li>Point a vertex shader attribute to a VBO from the previous step to store vertex coordinates</li><li>Use the IBO to render the geometry</li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec24"></a>Defining a Geometry Using JavaScript Arrays</h3></div></div></div><p>To practice using the <span>preceding</span><a id="id325638054" class="indexterm"></a> steps, let's use a <span>trapezoid</span><a id="id325638062" class="indexterm"></a> to see how we can define its vertices and indices. We need two JavaScript arrays – one for <span>the</span><a id="id325638071" class="indexterm"></a> vertices and one for the indices:</p><div class="mediaobject"><img src="/graphics/9781788629690/graphics/3ce3b4b6-11ad-4483-ac41-b4997065cc70.png" /></div><p>As you can see from the preceding illustration, we have placed the coordinates sequentially in the vertex array and then indicated how these coordinates are used to draw the trapezoid in the index array. So, the first triangle is formed with the vertices having the indices <code class="literal">0</code>, <code class="literal">2</code>, and <code class="literal">1</code>; the second, with the vertices having the indices <code class="literal">1</code>, <code class="literal">2</code>, and <code class="literal">3</code>; and finally, the third, with the vertices having the indices <code class="literal">2</code>, <code class="literal">4</code>, and <code class="literal">3</code>. We will follow the same procedure for all possible geometries.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip11"></a>Note</h3><p><strong class="userinput"><code>Index Array Order</code></strong>
Triangles in the index array are usually, but not necessarily, defined in counter-clockwise order. It's important to pick one approach and keep it consistent to help you determine the front and back sides of geometry primitives. Consistency is important, because programs may use the clockwise/counter-clockwise order to determine whether a face is facing forward or backward for <span class="strong"><strong>culling</strong></span> and rendering purposes.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note12"></a>Note</h3><p><strong class="userinput"><code>Culling</code></strong><span class="strong"><strong></strong></span>In computer graphics, back-face culling determines whether a polygon of a graphical object is visible. It is a step in the graphical pipeline that tests whether the points in the polygon appear in clockwise or counter-clockwise order when projected onto the screen. For more information, visit <a class="ulink" href="https://en.wikipedia.org/wiki/Back-face_culling" target="_blank">https://en.wikipedia.org/wiki/Back-face_culling</a><a class="ulink" href="https://en.wikipedia.org/wiki/Back-face_culling" target="_blank">.</a><span class="strong"><strong></strong></span></p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec25"></a>Creating WebGL Buffers</h3></div></div></div><p>Now that we understand how to define a geometry using vertices and indices, let's render a square. Once we have created the JavaScript arrays that define <span>the</span><a id="id325643482" class="indexterm"></a> vertices and indices for our geometry, the next step is to create the respective buffers. In this case, we have a <span>simple</span><a id="id325643492" class="indexterm"></a> square on the <code class="literal">x</code>-<code class="literal">y</code> plane with the z values set as <code class="literal">0</code>:</p><pre class="programlisting">const vertices = [
  -0.5,  0.5, 0,
-0.5, -0.5, 0,
0.5, -0.5, 0,
0.5,  0.5, 0
];

const positionBuffer = gl.createBuffer();</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note13"></a>Note</h3><p><strong class="userinput"><code>Clipspace Coordinates</code></strong>
These vertices are defined in clipspace coordinates, because WebGL only deals with clipspace coordinates. Clipspace coordinates always go from <code class="literal">-1</code> to <code class="literal">+1</code>, regardless of the size of the <code class="literal">canvas</code>. In later chapters, we will cover coordinates in more detail and learn how to convert between different coordinate systems.</p></div><p>In <a class="link" href="#" linkend="ch01">Chapter 1</a>, <span class="emphasis"><em>Getting Started</em></span>, you may remember learning that WebGL operates as a state machine. Now, when <code class="literal">positionBuffer</code> is made the currently-bound WebGL buffer, any subsequent buffer operation will be executed on this buffer until it is unbound, or another buffer is made the current one with a bound call. We can bind a buffer with the following instruction:</p><pre class="programlisting">gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);</pre><p>The first parameter is the type of buffer we are creating. We have two options for this parameter:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">gl.ARRAY_BUFFER</code>: Vertex data</li><li style="list-style-type: disc"><code class="literal">gl.ELEMENT_ARRAY_BUFFER</code>: Index data</li></ul></div><p>In the previous example, we created the buffer for vertex coordinates; therefore, we use <code class="literal">ARRAY_BUFFER</code>. For indices, the <code class="literal">ELEMENT_ARRAY_BUFFER</code> type is used.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip14"></a>Note</h3><p><strong class="userinput"><code><span class="strong"><strong>Bound Buffer Operations</strong></span></code></strong>
WebGL will always access the currently-bound buffer looking for the data. This means that we need to ensure that we always have bound a buffer before calling any other operation for geometry processing. If there is no buffer bound, you will obtain the <code class="literal">INVALID_OPERATION</code> error.</p></div><p>Remember that <code class="literal">drawArrays</code> uses VBOs<span class="emphasis"><em>.</em></span> Once we have bound a buffer, we need to pass along its contents. We do this with the <code class="literal">bufferData</code> function:</p><pre class="programlisting">gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);</pre><p>In this example, the vertices variable is a normal JavaScript array that contains the vertex coordinates. WebGL does not accept JavaScript arrays as a parameter for the <code class="literal">bufferData</code> method. Instead, WebGL requires JavaScript typed array so that the buffer data can be processed in its native binary form with the objective of speeding up geometry-processing performance.</p><p>The typed arrays used by WebGL include <code class="literal">Int8Array</code>, <code class="literal">Uint8Array</code>, <code class="literal">Int16Array</code>, <code class="literal">Uint16Array</code>, <code class="literal">Int32Array</code>, <code class="literal">Uint32Array</code>, <code class="literal">Float32Array</code>, and <code class="literal">Float64Array</code>.</p><p>It's important to note that vertex <span>coordinates</span><a id="id325628739" class="indexterm"></a> can be float, but <span>indices</span><a id="id325628747" class="indexterm"></a> are <span class="emphasis"><em>always</em></span> integers. Therefore, we will use <code class="literal">Float32Array</code> for VBOs and <code class="literal">Uint16Array</code> for IBOs in this book. These two types represent the largest typed arrays that you can use in WebGL <span class="emphasis"><em>per rendering call</em></span>. Other types may or may not be present in your browser, as this specification is not yet final at the time of this book's publication.</p><p>Since the indices support in WebGL is restricted to 16-bit integers, an index array can only be <code class="literal">65,535</code> elements in length. If you have a geometry that requires more indices, you will need to use several rendering calls. More about rendering calls will be presented <span>later</span><a id="id325628774" class="indexterm"></a> in this chapter.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note15"></a>Note</h3><p><strong class="userinput"><code>JavaScript Typed Arrays</code></strong>Specifications for typed arrays can be found at <a class="ulink" href="http://www.khronos.org/registry/typedarray/specs/latest/" target="_blank">http://www.khronos.org/registry/typedarray/specs/latest/</a>.</p></div><p>Finally, it is a good practice to unbind the buffer. We can achieve this by calling the following instruction:</p><pre class="programlisting">gl.bindBuffer(gl.ARRAY_BUFFER, null);</pre><p>We will repeat the same calls described here for every WebGL buffer (VBO or IBO) that we will use.</p><p>Let's review what we have just learned with an example. We are going to look at an example from <code class="literal">ch02_01_square.html</code> to see the definition of VBOs and IBOs for a square:</p><pre class="programlisting">// Set up the buffers for the square
function initBuffers() {
/*
    V0                    V3
    (-0.5, 0.5, 0)        (0.5, 0.5, 0)
    X---------------------X
    |                     |
    |                     |
    |       (0, 0)        |
    |                     |
    |                     |
    X---------------------X
    V1                    V2
    (-0.5, -0.5, 0)       (0.5, -0.5, 0)
  */
const vertices = [
    -0.5, 0.5, 0,
-0.5, -0.5, 0,
0.5, -0.5, 0,
0.5, 0.5, 0
];

// Indices defined in counter-clockwise order
indices = [0, 1, 2, 0, 2, 3];

// Setting up the VBO
squareVertexBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), 
   gl.STATIC_DRAW);

// Setting up the IBO
squareIndexBuffer = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, squareIndexBuffer);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), 
   gl.STATIC_DRAW);

// Clean
gl.bindBuffer(gl.ARRAY_BUFFER, null);
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
}</pre><p>If you want to see this scene in action, launch the <code class="literal">ch02_01_square.html</code> file in your browser.</p><p>To summarize, for <span>every</span><a id="id325628823" class="indexterm"></a> buffer, we <span>want</span><a id="id325628832" class="indexterm"></a> to do the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Create a new buffer</li><li style="list-style-type: disc">Bind it to make it the current buffer</li><li style="list-style-type: disc">Pass the buffer data using one of the typed arrays</li><li style="list-style-type: disc">Unbind the buffer</li></ul></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec4"></a>Operations to Manipulate WebGL Buffers</h4></div></div></div><p>The operations to <span>manipulate</span><a id="id325628858" class="indexterm"></a> WebGL buffers are summarized in the following table:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Method</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Description</strong></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">createBuffer()</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Creates a new buffer.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">deleteBuffer(buffer)</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Deletes the supplied buffer.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">bindBuffer(target, buffer)</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Binds a buffer object. The accepted values for target are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">ARRAY_BUFFER</code> (for vertices)</li><li style="list-style-type: disc"><code class="literal">ELEMENT_ARRAY_BUFFER</code> (for indices)</li></ul></div></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">bufferData(target, data, type)</code></p></td><td style=""><p>Provides the buffer data. The accepted values for target are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">ARRAY_BUFFER</code> (for vertices)</li><li style="list-style-type: disc"><code class="literal">ELEMENT_ARRAY_BUFFER</code> (for indices)</li></ul></div><p>As mentioned earlier, WebGL only accepts JavaScript typed arrays for the data.</p><p>The parameter type is a performance hint for WebGL. The accepted values for type are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">STATIC_DRAW</code>: Data in the buffer will not be changed (specified once and used many times)</li><li style="list-style-type: disc"><code class="literal">DYNAMIC_DRAW</code>: Data will be changed frequently (specified many times and used many times)</li><li style="list-style-type: disc"><code class="literal">STREAM_DRAW</code>: Data will change on every rendering cycle (specified once and used once)</li></ul></div></td></tr></tbody></table></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec26"></a>Associating Attributes to VBOs</h3></div></div></div><p>Once we have created the VBOs, we need to <span>associate</span><a id="id325359540" class="indexterm"></a> these buffers to <span>vertex</span><a id="id325359549" class="indexterm"></a> shader attributes. Each vertex shader attribute will refer to <span class="emphasis"><em>one</em></span> an<span class="emphasis"><em>d</em></span><span class="emphasis"><em>only one </em></span>buffer, depending on the correspondence that is established, as shown in the following diagram:</p><div class="mediaobject"><img src="/graphics/9781788629690/graphics/e96e7489-1d97-4c05-92cd-c058fbbb1acf.png" /></div><p>We can achieve this by following these steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Bind a VBO</li><li>Point an attribute to the currently-bound VBO</li><li>Enable the attribute</li><li>Unbind</li></ol></div><p>Let's take a look at the first step.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec5"></a>Binding a VBO</h4></div></div></div><p>We already <span>know</span><a id="id325359602" class="indexterm"></a> how to do this:</p><pre class="programlisting">gl.bindBuffer(gl.ARRAY_BUFFER, myBuffer);</pre><p>Where <code class="literal">myBuffer</code> is the buffer we want to map.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec6"></a>Pointing an Attribute to the Currently-Bound VBO</h4></div></div></div><p>The majority of the WebGL API is about <span>setting</span><a id="id325359662" class="indexterm"></a> up state to supply data to our GLSL programs. In this case, the only input to our GLSL program is <code class="literal">aVertexPosition</code>, which is an attribute. In <a class="link" href="#" linkend="ch03">Chapter 3</a>, <span class="emphasis"><em>Lights</em></span>, we will learn how to define and reference vertex and fragment shader attributes. For now, let's assume that we have the <code class="literal">aVertexPosition</code> attribute, which describes the vertex coordinates in the shader.</p><p>The WebGL function that allows pointing attributes to the currently-bound VBOs is <code class="literal">vertexAttribPointer</code>. The following is its signature:</p><pre class="programlisting">gl.vertexAttribPointer(index, size, type, normalize, stride, offset);</pre><p>Let’s describe each parameter individually:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Index</strong></span>: An attribute's index that we are going to map the currently-bound buffer to.</li><li style="list-style-type: disc"><span class="strong"><strong>Size</strong></span>: Indicates the number of values per vertex that are stored in the currently-bound buffer.</li><li style="list-style-type: disc"><span class="strong"><strong>Type</strong></span>: Specifies the data type of the values stored in the current buffer. It is one of the following constants: <code class="literal">FIXED</code>, <code class="literal">BYTE</code>, <code class="literal">UNSIGNED_BYTE</code>, <code class="literal">FLOAT</code>, <code class="literal">SHORT</code>, or <code class="literal">UNSIGNED_SHORT</code>.</li><li style="list-style-type: disc"><span class="strong"><strong>Normalize</strong></span>: This parameter can be set to <code class="literal">true</code> or <code class="literal">false</code>. It handles numeric conversions that are beyond the scope of this introductory guide. For our purposes, we will set this parameter to <code class="literal">false</code>.</li><li style="list-style-type: disc"><span class="strong"><strong>Stride</strong></span>: If stride is <code class="literal">0</code>, then we are indicating that elements are stored sequentially in the buffer.</li><li style="list-style-type: disc"><span class="strong"><strong>Offset</strong></span>: The position in the buffer from which we will start reading values for the corresponding attribute. It is usually set to <code class="literal">0</code> to indicate that we will start reading values from the first element of the buffer.</li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip16"></a>Note</h3><p><span class="strong"><strong><strong class="userinput"><code>Buffer Pointer</code></strong></strong></span><code class="literal">vertexAttribPointer</code> defines a pointer for reading information <span class="emphasis"><em>fro</em></span><span class="emphasis"><em>m the currently-bound buffer</em></span>. Remember that an error will be generated if there is no VBO currently bound.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec7"></a>Enabling the Attribute</h4></div></div></div><p>Finally, we need to <span>activate</span><a id="id325359796" class="indexterm"></a> the vertex shader attribute. Following our example, we just need to add <code class="literal">gl.enableVertexAttribArray(positionAttributeLocation);</code>.</p><p>The following diagram summarizes the mapping procedure:</p><div class="mediaobject"><img src="/graphics/9781788629690/graphics/641f509d-84cf-408e-833e-221dfda07140.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec8"></a>Unbinding a VBO</h4></div></div></div><p>As a rule of thumb, we <span>should</span><a id="id325359827" class="indexterm"></a> unbind our buffers after we're done using them. We can do so with:</p><p><code class="literal">gl.bindBuffer(gl.ARRAY_BUFFER, null);</code>.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec27"></a>Rendering</h3></div></div></div><p>Once we have defined our VBOs and we have mapped them to the corresponding vertex shader attributes, we are ready to render! To do this, we <span>can</span><a id="id325359847" class="indexterm"></a> use one of the two API functions: <code class="literal">drawArrays</code> or <code class="literal">drawElements</code>.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec9"></a>Drawing Functions</h4></div></div></div><p>The <code class="literal">drawArrays</code> and <code class="literal">drawElements</code> functions are <span>used</span><a id="id325359911" class="indexterm"></a> for writing to the framebuffer. <code class="literal">drawArrays</code> uses vertex data in the order in which it is defined in the buffer to create the geometry. In contrast, <code class="literal">drawElements</code> uses indices to access the vertex data buffers and create the geometry. Both <code class="literal">drawArrays</code> and <code class="literal">drawElements</code> will <span>only</span><a id="id325359932" class="indexterm"></a> use <span class="strong"><strong>enabled arrays</strong></span>. These are the vertex buffer objects that are mapped to active vertex shader attributes.</p><p>In our example, the buffer that contains the vertex coordinates is the only enabled array. However, in a more general scenario, there may be several enabled arrays at our disposal.</p><p>For instance, we can have arrays with information about vertex colors, vertex normals, texture coordinates, and any other per-vertex data required by the application. In this case, each one of them would be mapped to an active vertex shader attribute.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip17"></a>Note</h3><p><strong class="userinput"><code>Using Multiple VBOs</code></strong><span class="strong"><strong></strong></span>
In <a class="link" href="#" linkend="ch03">Chapter 3</a>, <span class="emphasis"><em>Lights</em></span>, we will learn how to use a vertex normal buffer and vertex coordinates to create a lighting model for our geometry. In that scenario, we will have two active arrays: vertex coordinates and vertex normals.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch02lvl4sec0"></a>Using drawArrays</h5></div></div></div><p>We will call <code class="literal">drawArrays</code> when information <span>about</span><a id="id325360009" class="indexterm"></a> indices is not available. In most cases, <code class="literal">drawArrays</code> is used when the geometry is simple enough that defining indices is overkill – for instance, when we want to render a triangle or a rectangle. In that case, WebGL will create the geometry in the order in which the vertex coordinates are defined in the VBO. If you have contiguous triangles (as we did in the trapezoid example), you will have to <span class="emphasis"><em>repeat</em></span> these coordinates in the VBO.</p><p>If you need to repeat many vertices to create the geometry, <code class="literal">drawArrays</code> is not the optimal method, because the more vertex data you duplicate, the more calls you will have on the vertex shader. This can reduce the overall performance, since the same vertices must go through the pipeline several times, one for each time that they are repeated in the respective VBO:</p><div class="mediaobject"><img src="/graphics/9781788629690/graphics/019fb2c8-2709-4c5a-b237-327de1a92061.png" /></div><p>The signature for <code class="literal">drawArrays</code> is as follows:</p><pre class="programlisting">gl.drawArrays(mode, first, count)</pre><p>Where:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">mode</code>: Represents the type of primitive that we are going to render. The possible values for mode are <code class="literal">gl.POINTS</code>, <code class="literal">gl.LINE_STRIP</code>, <code class="literal">gl.LINE_LOOP</code>, <code class="literal">gl.LINES</code>, <code class="literal">gl.TRIANGLE_STRIP</code>, <code class="literal">gl.TRIANGLE_FAN</code>, and <code class="literal">gl.TRIANGLES</code>.</li><li style="list-style-type: disc"><code class="literal">first</code>: Specifies the starting element in the enabled arrays.</li><li style="list-style-type: disc"><code class="literal">count</code>: The number of <span>elements</span><a id="id325360092" class="indexterm"></a> to be rendered.</li></ul></div><p></p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note18"></a>Note</h3><p><strong class="userinput"><code>WebGL drawArrays Specification</code></strong>
When <code class="literal">drawArrays</code> is called, it uses count sequential elements from each enabled array to construct a sequence of geometric primitives, beginning with the element <span class="emphasis"><em>first</em></span>. Mode specifies what kinds of primitives are constructed and how the array elements construct those primitives.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch02lvl4sec1"></a>Using drawElements</h5></div></div></div><p>Unlike the <span>previous</span><a id="id325360123" class="indexterm"></a> case where no IBO was defined, <code class="literal">drawElements</code> allows us to use the IBO to tell WebGL how to render the geometry. Remember that <code class="literal">drawArrays</code> uses VBOs, which means that the vertex shader will process the repeated vertices as many times as they appear in the VBO. On the other hand, <code class="literal">drawElements</code> uses indices. Therefore, vertices are only processed once, and can be used as many times as they are defined in the IBO. This feature reduces both the memory and processing required on the GPU.</p><p>Let's revisit the following diagram:</p><div class="mediaobject"><img src="/graphics/9781788629690/graphics/87f8a26c-a9a7-450d-9d97-f0c2bfc399af.png" /></div><p>When we use <code class="literal">drawElements</code>, we need at least two buffers: a VBO and an IBO. As the vertex shader gets executed on each vertex, the rendering pipeline assembles the geometry into triangles using the IBO.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip19"></a>Note</h3><p><strong class="userinput"><code>Binding the IBO with</code></strong><code class="literal"><strong class="userinput"><code>drawElements</code></strong></code>
When using <code class="literal">drawElements</code>, you need to make sure that the corresponding IBO is currently bound.</p></div><p>The signature for <code class="literal">drawElements</code> is as follows:</p><pre class="programlisting">gl.drawElements(mode, count, type, offset)</pre><p>Where:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">mode</code>: Represents the type of primitive we are going to render. The possible values for mode are <code class="literal">POINTS</code>, <code class="literal">LINE_STRIP</code>, <code class="literal">LINE_LOOP</code>, <code class="literal">LINES</code>, <code class="literal">TRIANGLE_STRIP</code>, <code class="literal">TRIANGLE_FAN</code>, and <code class="literal">TRIANGLES</code>.</li><li style="list-style-type: disc"><code class="literal">count</code>: Specifies the number of elements to be rendered.</li><li style="list-style-type: disc"><code class="literal">type</code>: Specifies the type of the values in indices. Must be <code class="literal">UNSIGNED_BYTE</code> or <code class="literal">UNSIGNED_SHORT</code>, as we are handling indices (integer numbers).</li><li style="list-style-type: disc"><code class="literal">offset</code>: Indicates which element in the <span>buffer</span><a id="id325632997" class="indexterm"></a> will be the starting point for rendering. It is usually the first element (zero value).</li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note20"></a>Note</h3><p><strong class="userinput"><code>WebGL</code></strong><strong class="userinput"><code>drawElements</code></strong><strong class="userinput"><code> Specification</code></strong>
When <code class="literal">drawElements</code> is called, it uses count sequential elements from an enabled array, starting at the offset to construct a sequence of geometric primitives. Mode specifies what kinds of primitives are constructed and how the array elements construct these primitives. If more than one array is enabled, each is used.</p></div></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec28"></a>Putting Everything Together</h3></div></div></div><p>Since you've probably been <span>waiting</span><a id="id325633028" class="indexterm"></a> to see how everything works together, let's go over a simple WebGL program that renders a square.</p></div></div>