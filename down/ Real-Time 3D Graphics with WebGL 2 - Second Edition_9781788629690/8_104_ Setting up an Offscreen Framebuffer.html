<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec108"></a>Setting up an Offscreen Framebuffer</h2></div></div><hr /></div><p>As shown in <a class="link" href="#" linkend="ch02">Chapter 2</a>, <span class="emphasis"><em>Rendering</em></span>, the <span>framebuffer</span><a id="id325358930" class="indexterm"></a> is the final rendering destination in WebGL. The results of the rendering on your screen are the contents of the framebuffer. Assuming that <code class="literal">gl</code> is our WebGL context, every call to <code class="literal">gl.drawArrays</code>, <code class="literal">gl.drawElements</code>, and <code class="literal">gl.clear</code> will change the contents of the framebuffer.</p><p>Instead of rendering to the default framebuffer, we can also render to a scene that is offscreen – we call this the offscreen framebuffer. This is the first step in implementing picking. To do so, we need to set up a new framebuffer and tell WebGL that we want to use it instead of the default one. Let's see how we can do that.</p><p>To set up a framebuffer, we need to create storage for at least two things: colors and depth information. We need to store the color for every fragment that is rendered in the <span>framebuffer</span><a id="id325358955" class="indexterm"></a> so we can create an image. Additionally, we need depth information to make sure that we have a scene where overlapping objects look consistent. If we do not have depth information, then we would not be able to tell, in the case of two overlapping objects, which object is at front and which one is at the back.</p><p>To store colors, we will use a WebGL texture; to store depth information, we will use a renderbuffer.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec133"></a>Creating a Texture to Store Colors</h3></div></div></div><p>The code to create a texture <span>should</span><a id="id325614930" class="indexterm"></a> be pretty straightforward after reading <a class="link" href="#" linkend="ch07">Chapter 7</a>, <span class="emphasis"><em>Textures</em></span>:</p><pre class="programlisting">const canvas = document.getElementById('webgl-canvas');
const { width, height } = canvas;

const texture = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, texture);
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);</pre><p>The only difference is that we do not have an image to bind to the texture, so when we call <code class="literal">gl.texImage2D</code>, the last argument is <code class="literal">null</code>. This is because we are allocating space to store colors for the offscreen framebuffer.</p><p>It's important to note that the <code class="literal">width</code> and <code class="literal">height</code> of the texture are set to the <code class="literal">canvas</code> size. This is because we want to ensure that the offscreen framebuffer resembles the dimensions of our 3D scene.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec134"></a>Creating a Renderbuffer to Store Depth Information</h3></div></div></div><p>Renderbuffers are used to <span>provide</span><a id="id325617303" class="indexterm"></a> storage for the individual buffers used in a framebuffer. The depth buffer (z-buffer) is an example of a renderbuffer. It is always attached to the screen framebuffer, which is the default rendering destination in WebGL.</p><p>The code to create a renderbuffer looks like the following code:</p><pre class="programlisting">const renderbuffer = gl.createRenderbuffer();
gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);</pre><p>The first line of code creates the renderbuffer. Similar to other WebGL buffers, the renderbuffer needs to be bound before we can operate on it. The third line of code determines the storage size of the renderbuffer.</p><p>Please note that the size of the storage is the same as with the texture. Similar to before, we need to ensure that for every fragment (pixel) in the framebuffer, we have a color (stored in the texture) and a depth value (stored in the renderbuffer).</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec135"></a>Creating a Framebuffer for Offscreen Rendering</h3></div></div></div><p>We need to create a <span>framebuffer</span><a id="id325643463" class="indexterm"></a> and attach the texture and the renderbuffer that we created in the previous example. Let's see how this works in code.</p><p>First, we need to create a new framebuffer:</p><pre class="programlisting">const framebuffer = gl.createFramebuffer();</pre><p>Similar to the VBO manipulation, we tell WebGL that we’re going to operate on this framebuffer by making it the currently bound framebuffer. We do so with the following instruction:</p><pre class="programlisting">gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);</pre><p>With the framebuffer bound, the texture is attached by calling the following method:</p><pre class="programlisting">gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);</pre><p>Then, the renderbuffer is attached to the bound framebuffer using the following:</p><pre class="programlisting">gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);</pre><p>Finally, we clean up the bound buffers as usual with the following code:</p><pre class="programlisting">gl.bindTexture(gl.TEXTURE_2D, null);
gl.bindRenderbuffer(gl.RENDERBUFFER, null);
gl.bindFramebuffer(gl.FRAMEBUFFER, null);</pre><p>When the previously created framebuffer is unbound, the WebGL state machine goes back to rendering into the default screen framebuffer.</p></div></div>