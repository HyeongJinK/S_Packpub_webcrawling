<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec64"></a>Structure of the WebGL Examples</h2></div></div><hr /></div><p>We have improved <span>the</span><a id="id325357458" class="indexterm"></a> structure of the code examples in this chapter. As the complexity of our WebGL applications increases, it is wise to have a good, maintainable, and clear design. We have saved this section until the end of this chapter so that you can use it as a reference when working on the exercises.</p><p>Just as in previous exercises, our entry point is the <code class="literal">init</code> function, which is called when the page is loaded. We have included several <code class="literal">scripts</code> in the <code class="literal">head</code> of our document that point to various components to build our 3D application.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec83"></a>Supporting Objects</h3></div></div></div><p>We have created <span>the</span><a id="id325358945" class="indexterm"></a> following components, each one in its own file inside the <code class="literal">common/js</code> directory:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">Program.js</code>: Creates the program using the shader definitions. Provides the mapping between JavaScript variables (<code class="literal">program.*</code>) and program attributes and uniforms.</li><li style="list-style-type: disc"><code class="literal">Scene.js</code>: Maintains a list of objects to be rendered. Contains the AJAX/JSON functionality to retrieve remote objects. It also allows us to add local objects to the scene.</li><li style="list-style-type: disc"><code class="literal">Floor.js</code>: Defines a grid on the X-Z plane. This object is added to <code class="literal">scene</code> to have a reference to the floor and its properties</li><li style="list-style-type: disc"><code class="literal">Axis.js</code>: Represents the axis in world space. When added to <code class="literal">scene</code>, we will have a reference to the origin.</li><li style="list-style-type: disc"><code class="literal">Camera.js</code>: Creates a camera instance to manipulate the various matrices and operations covered in this chapter with a simple interface.</li><li style="list-style-type: disc"><code class="literal">EventEmitter.js</code>: A simple pub-sub event emitter for decoupling various components in our WebGL application. Instead of passing hard references around between unrelated functionality, we can leverage the pub-sub pattern to emit and listen to actions.</li><li style="list-style-type: disc"><code class="literal">Clock.js</code>: A simple class that abstracts away the <code class="literal">requestAnimationFrame</code> API to have the entire WebGL application update from a single source of truth (such as <code class="literal">clock</code>).</li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note55"></a>Note</h3><p><strong class="userinput"><code>requestAnimationFrame</code></strong><span class="strong"><strong></strong></span>The <code class="literal">window.requestAnimationFrame()</code> method tells the browser that you wish to perform an animation and requests that the browser call a specified function to update an animation before the next repaint. This will request that your animation function be called before the browser performs the next repaint.</p></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">Controls.js</code>: Provides the ability to capture various <code class="literal">canvas</code> DOM events to drive interactions.</li><li style="list-style-type: disc"><code class="literal">utils.js</code>: Utility functions that we covered in earlier chapters.</li></ul></div><p>Although we have enough foundation to understand how each components works, we will cover each component in <a class="link" href="#" linkend="ch09">Chapter 9</a><span class="emphasis"><em>, Putting It All Together</em></span>. That being said, if you can't wait, feel free to inspect the source code to get an idea of what's to come.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec84"></a>Life Cycle Functions</h3></div></div></div><p>The following <span>functions</span><a id="id325631869" class="indexterm"></a> define <span>the</span><a id="id325631878" class="indexterm"></a> life cycle of a WebGLApp application.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec24"></a>The configure Function</h4></div></div></div><p>The <code class="literal">configure</code> function <span>sets</span><a id="id325631896" class="indexterm"></a> some parameters of our <code class="literal">gl</code> context, such as the color for clearing the <code class="literal">canvas</code>. After configuring the necessary states.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec25"></a>The load Function</h4></div></div></div><p>The <code class="literal">load</code> function <span>sets</span><a id="id325638059" class="indexterm"></a> up objects to be added to our <code class="literal">scene</code>. For example, the two locally-created objects, <code class="literal">floor</code> and <code class="literal">axis</code>, are added to <code class="literal">scene</code> by calling the <code class="literal">add</code> method. After that, a remote object (AJAX call) is loaded using the <code class="literal">scene.load</code> method.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec26"></a>The draw Function</h4></div></div></div><p>The <code class="literal">draw</code> function calls <code class="literal">updateTransforms</code> to <span>calculate</span><a id="id325643392" class="indexterm"></a> the matrices for the new position (that is, when we move), and then iterates over the objects in <code class="literal">scene</code> to render them. Inside this loop, it calls <code class="literal">setMatrixUniforms</code> for every object to be rendered.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec85"></a>Matrix-Handling Functions</h3></div></div></div><p>Open up <code class="literal">ch04_02_model-view-rotation.html</code> in <span>your</span><a id="id325647206" class="indexterm"></a> editor. The following are the functions that initialize, update, and pass matrices to the shaders.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec27"></a>initTransforms</h4></div></div></div><p>As you can see, the Model-View matrix, the Camera matrix, the Projection matrix, and <span>the</span><a id="id325647221" class="indexterm"></a> Normal matrix are set up here:</p><pre class="programlisting">function initTransforms() {
  mat4.identity(modelViewMatrix);
mat4.translate(modelViewMatrix, modelViewMatrix, home);

mat4.identity(cameraMatrix);
mat4.invert(cameraMatrix, modelViewMatrix);

mat4.identity(projectionMatrix);

mat4.identity(normalMatrix);
mat4.copy(normalMatrix, modelViewMatrix);
mat4.invert(normalMatrix, normalMatrix);
mat4.transpose(normalMatrix, normalMatrix);
}</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec28"></a>updateTransforms</h4></div></div></div><p>In <code class="literal">updateTransforms</code>, we use <span>the</span><a id="id325652534" class="indexterm"></a> contents of the global variables' position and rotation to update the matrices. This is, of course, as follows::</p><pre class="programlisting">function updateTransforms() {
  mat4.perspective(projectionMatrix, 45,canvas.width /gl.canvas.height, 
   0.1, 1000);

if (coordinates === WORLD_COORDINATES) {
    mat4.identity(modelViewMatrix);
mat4.translate(modelViewMatrix, modelViewMatrix, position);
mat4.rotateX(modelViewMatrix, modelViewMatrix, rotation[0] * Math.PI / 
     180);
mat4.rotateY(modelViewMatrix, modelViewMatrix, rotation[1] * Math.PI / 
     180);
mat4.rotateZ(modelViewMatrix, modelViewMatrix, rotation[2] * Math.PI / 
     180);
}
else {
    mat4.identity(cameraMatrix);
mat4.translate(cameraMatrix, cameraMatrix, position);
mat4.rotateX(cameraMatrix, cameraMatrix, rotation[0] * Math.PI / 180);
mat4.rotateY(cameraMatrix, cameraMatrix, rotation[1] * Math.PI / 180);
mat4.rotateZ(cameraMatrix, cameraMatrix, rotation[2] * Math.PI / 180);
}
}</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec29"></a>setMatrixUniforms</h4></div></div></div><p>This function performs <span>the</span><a id="id325656618" class="indexterm"></a> mapping:</p><pre class="programlisting">function setMatrixUniforms() {
if (coordinates === WORLD_COORDINATES) {
    mat4.invert(cameraMatrix, modelViewMatrix);
gl.uniformMatrix4fv(program.uModelViewMatrix, false, modelViewMatrix);
}
else {
    mat4.invert(modelViewMatrix, cameraMatrix);
}

  gl.uniformMatrix4fv(program.uProjectionMatrix, false, projectionMatrix);
gl.uniformMatrix4fv(program.uModelViewMatrix, false, modelViewMatrix);
mat4.transpose(normalMatrix, cameraMatrix);
gl.uniformMatrix4fv(program.uNormalMatrix, false, normalMatrix);
}</pre></div></div></div>