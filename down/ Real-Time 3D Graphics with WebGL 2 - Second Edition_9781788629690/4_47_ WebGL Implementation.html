<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec55"></a>WebGL Implementation</h2></div></div><hr /></div><p>Now, let's take a look at how we can implement vertex and normal transformations in WebGL. The following diagram shows the theory we have learned so far, along <span>with</span><a id="id325358908" class="indexterm"></a> the relationships <span>between</span><a id="id325358929" class="indexterm"></a> the steps in the theory and the implementation in WebGL:</p><div class="mediaobject"><img src="/graphics/9781788629690/graphics/3e10b4f3-dc73-4eaa-8316-ede6255f6e1d.png" /></div><p>In WebGL, the five transformations that we apply to object coordinates to obtain viewport coordinates are grouped into three matrices and one WebGL method:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">The <span class="strong"><strong>Model-View </strong></span>matrix that <span>groups</span><a id="id325656618" class="indexterm"></a> the <span class="emphasis"><em>model</em></span> and <span class="emphasis"><em>view</em></span> transform in one single matrix. When we multiply our vertices by this matrix, we end up in view coordinates.</li><li style="list-style-type: disc">The <span class="strong"><strong>Normal matrix </strong></span>is <span>obtained</span><a id="id325656676" class="indexterm"></a> by inverting and transposing the Model-View matrix. This matrix is applied to normal vectors to ensure that they continue to be perpendicular to the surface. This is very important in cases such as lighting.</li><li style="list-style-type: disc">The <span class="strong"><strong>Projection matrix </strong></span>groups the <span class="emphasis"><em>projection transformation</em></span> and <span class="emphasis"><em>the perspective division</em></span>, and as a result, we end up in <span>normalized</span><a id="id325659802" class="indexterm"></a> device coordinates.</li></ul></div><p>Finally, we use the <code class="literal">gl.viewport</code> operation to map NDCs to viewport coordinates:</p><pre class="programlisting">gl.viewport(minX, minY, width, height);</pre><p>The viewport coordinates originate in the lower-left corner of the HTML5 <code class="literal">canvas</code>.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec68"></a>JavaScript Matrices</h3></div></div></div><p>The WebGL JavaScript API does not provide its own methods to perform operations on matrices. WebGL simply provides a way to pass <span>matrices</span><a id="id325659862" class="indexterm"></a> to the shaders (as uniforms). So, we need to use a JavaScript library that enables us to manipulate matrices in JavaScript. In this book, we have used <span class="strong"><strong>glMatrix</strong></span> for all <span>matrix</span><a id="id325659875" class="indexterm"></a> operations. However, there are other libraries available online that can do this for you.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note52"></a>Note</h3><p><strong class="userinput"><code>glMatrix</code></strong>
We used <span class="strong"><strong>glMatrix</strong></span> for all matrix operations in this book. You can find more information about this library at <a class="ulink" href="https://github.com/toji/gl-matrix" target="_blank">https://github.com/toji/gl-matrix.</a></p></div><p>Here are some of the operations that you can perform with <span class="strong"><strong>glMatrix</strong></span>:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Operation</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Syntax</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Description</strong></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Creation</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">const m = mat4.create();</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Creates the <code class="literal">m</code> matrix.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Identity</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">mat4.identity(m);</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Sets <code class="literal">m</code> as the Identity matrix of rank 4.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Copy</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">mat4.copy(target, origin);</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Copies the matrix origin onto the matrix target.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Transpose</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">mat4.transpose(target, m);</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Transposes the <code class="literal">m</code> matrix onto the matrix target.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Invert</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">mat4.invert(target, m);</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Inverts <code class="literal">m</code> onto the matrix target.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Rotate</p></td><td style="border-right: 0.5pt solid ; "><p><code class="literal">mat4.rotate(target, m, r, a);</code></p></td><td style=""><p>Rotates the <code class="literal">m</code> matrix by <code class="literal">r</code> radians around the <code class="literal">a</code>  axis (this is a three-element array, <code class="literal">[x, y, z]</code>) onto the matrix target.</p></td></tr></tbody></table></div><p> </p><p>It's important to note that the <span class="strong"><strong>glMatrix</strong></span> provides <span>many</span><a id="id325662205" class="indexterm"></a> more functions to perform other linear algebra operations. To get the full list, visit <a class="ulink" href="http://glmatrix.net/docs/" target="_blank">http://glmatrix.net/docs/</a>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec69"></a>Mapping JavaScript Matrices to ESSL Uniforms</h3></div></div></div><p>Since the Model-View and Perspective matrices do not <span>change</span><a id="id325662225" class="indexterm"></a> during a single rendering step, they are passed as <span class="emphasis"><em>uniforms</em></span> to the shaders. For example, if we were applying a translation to an object in our scene, we would have to paint the whole object in the new coordinates given by the translation. Painting the whole object in the new position is achieved in exactly one rendering step.</p><p>However, before the rendering step is invoked (by calling <code class="literal">drawArrays</code> or <code class="literal">drawElements</code>), we need to make sure that the shaders have an updated version of our matrices. We already know how to do that for other uniforms, such as light and color properties. The method to map JavaScript matrices to uniforms is similar to the following:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Get a JavaScript reference to the uniform with the following code:</li></ol></div><pre class="programlisting">const reference = getUniformLocation(program, uniformName);</pre><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Use the reference to pass the matrix to the shader with the following code:</li></ol></div><pre class="programlisting">// Matrix is the JavaScript matrix variable
gl.uniformMatrix4fv(reference, transpose, matrix);</pre><p>As is the case for other uniforms, ESSL supports two-, three-, and four-dimensional matrices: <code class="literal">uniformMatrix[234]fv(reference, transpose, matrix)</code>. This will load 2x2, 3x3, or 4x4 matrices (corresponding to 2, 3, or 4 in the command name) of floating points into the uniform referenced by <code class="literal">reference</code>. The type of <code class="literal">reference</code> is <code class="literal">WebGLUniformLocation</code>. For practical purposes, it is an integer number. According to the specification, the transpose value must be set to <code class="literal">false</code>. The matrix uniforms are always of the floating point type (<code class="literal">f</code>). The matrices are passed as <code class="literal">4</code>, <code class="literal">9</code>, or <code class="literal">16</code> element vectors (<code class="literal">v</code>) and are always specified in a column-major order. The matrix parameter can also be of the <code class="literal">Float32Array</code> type. This is one of JavaScript's typed arrays. These arrays are included in the language to provide access to and the manipulation of raw binary data, and thus increase efficiency.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec70"></a>Working with Matrices in ESSL</h3></div></div></div><p>Let's revisit the Phong vertex shader, which <span>was</span><a id="id325628664" class="indexterm"></a> introduced in <a class="link" href="#" linkend="ch03">Chapter 3</a>, <span class="emphasis"><em>Lights</em></span>. Please remember that matrices are defined as uniform <code class="literal">mat4</code>.</p><p>In this shader, we have defined three matrices:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">uModelViewMatrix</code>: The Model-View matrix</li><li style="list-style-type: disc"><code class="literal">uProjectionMatrix</code>: The Projection matrix</li><li style="list-style-type: disc"><code class="literal">uNormalMatrix</code>: The Normal matrix</li></ul></div><pre class="programlisting">#version 300 es
precision mediump float;

uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;
uniform mat4 uNormalMatrix;

in vec3 aVertexPosition;
in vec3 aVertexNormal;

out vec3 vVertexNormal;
out vec3 vEyeVector;

void main(void) {
// Transformed vertex position
vec4 vertex = uModelViewMatrix * vec4(aVertexPosition, 1.0);

// Transformed normal position
vVertexNormal = vec3(uNormalMatrix * vec4(aVertexNormal, 0.0));

// Eye vector
vEyeVector = -vec3(vertex.xyz);

// Final vertex position
gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aVertexPosition, 1.0);
}</pre><p>In ESSL, the multiplication of matrices is straightforward; that is, you do not need to multiply element by element. ESSL knows that you are working with matrices, so it performs the multiplications for you:</p><pre class="programlisting">gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aVertexPosition, 1.0);
</pre><p>The last line of this shader assigns a value to the predefined <code class="literal">gl_Position</code> variable. This will contain the clipping coordinates for the vertex that is currently being processed by the shader. We need to remember that the shaders work in parallel: each vertex is processed by an instance of the vertex shader.</p><p>To obtain the clipping coordinates for a given vertex, we first need to multiply the Model-View matrix by the Projection matrix. To achieve this, we multiply from right to left, because matrix multiplication is not commutative and order matters.</p><p>Also, notice that we needed to augment the <code class="literal">aVertexPosition</code> attribute by including the Homogeneous coordinate. This is because we have defined our geometry in Euclidean space. Luckily, ESSL allows us to do this by simply adding the missing component and creating a <code class="literal">vec4</code> on the fly. We need to do this because both the Model-View matrix and the Projection matrix are described in Homogeneous coordinates (<code class="literal">4</code> rows by <code class="literal">4</code> columns).</p><p>Now that we've seen <span>how</span><a id="id325628740" class="indexterm"></a> to map JavaScript matrices to ESSL uniforms in our shaders, let's talk about how to operate with the three matrices: the Model-View matrix, the Normal matrix, and the Projection matrix.</p></div></div>