<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec84"></a>Time for Action: Adding a Blue Light to a Scene</h2></div></div><hr /></div><p>We’re ready to take a look at the first example in this chapter. We will work on a scene with <span class="strong"><strong>per-fragment</strong></span> lighting that has three light sources.</p><p>Each light has a <span>position</span><a id="id325358933" class="indexterm"></a> and a diffuse color property. This means we have two uniforms per light. Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>To keep things simple, we have assumed that the ambient color is the same for all three light sources. We have also removed the specular property. Open the <code class="literal">ch06_02_wall_initial.html</code> file in your browser.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>You will see a scene such as the one displayed in the following screenshot where two lights (red and green) illuminate a black wall:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788629690/graphics/c56e4d90-2bf8-49d7-b551-fe7db0192d90.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>Open the <code class="literal">ch06_02_wall-initial.html</code> file using your code editor. We will update the vertex shader, the fragment shader, the JavaScript code, and the HTML code to add the blue light.</li><li><span class="strong"><strong>Updating the vertex shader</strong></span>: Go to the vertex shader where you can see these two uniforms:</li></ol></div><pre class="programlisting">uniform vec3 uPositionRedLight; 
uniform vec3 uPositionGreenLight; </pre><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>Let's add the third uniform here:</li></ol></div><pre class="programlisting">uniform vec3 uPositionBlueLight;</pre><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>We also need to define a varying to carry the interpolated light ray direction to the fragment shader. Remember here that we are using per-fragment lighting. Check where the varyings are defined:</li></ol></div><pre class="programlisting">out vec3 vRedRay;
out vec3 vGreenRay;</pre><div class="orderedlist"><ol class="orderedlist arabic" start="7" type="1"><li>And, add the third varying there:</li></ol></div><pre class="programlisting">out vec3 vBlueRay;</pre><div class="orderedlist"><ol class="orderedlist arabic" start="8" type="1"><li>Let's take a look at the body of the vertex shader. We need to update each of the light locations according to our position in the scene. We achieve this by writing the following:</li></ol></div><pre class="programlisting">vec4 blueLightPosition = uModelViewMatrix * vec4(uPositionBlueLight, 1.0);</pre><div class="orderedlist"><ol class="orderedlist arabic" start="9" type="1"><li>Notice that the positions for the other two lights are also being calculated.</li><li>Let's calculate the light ray for the updated position from our blue light to the current vertex. We do that by writing the following code:</li></ol></div><pre class="programlisting">vBlueRay = vertex.xyz - blueLightPosition.xyz;</pre><div class="orderedlist"><ol class="orderedlist arabic" start="11" type="1"><li>That is all we need to modify in the vertex shader.</li><li>So far, we’ve included a new light position and we have calculated the light rays in the vertex shader. These rays will be interpolated by the fragment shader.</li><li>Let's work out how the colors on the wall will change by including our new blue source of light. Scroll down to the fragment shader and add a new uniform—the blue diffuse property. Look for these uniforms declared right before the <code class="literal">main</code> function:</li></ol></div><pre class="programlisting">uniform vec4 uDiffuseRedLight;
uniform vec4 uDiffuseGreenLight;</pre><div class="orderedlist"><ol class="orderedlist arabic" start="14" type="1"><li>Insert the following line of code:</li></ol></div><pre class="programlisting">uniform vec4 uDiffuseBlueLight;</pre><div class="orderedlist"><ol class="orderedlist arabic" start="15" type="1"><li>To calculate the contribution of the blue light to the final color, we need to obtain the light ray we defined previously in the vertex shader. This varying is available in the fragment shader. You also need to declare it before the <code class="literal">main</code> function. Look for the following:</li></ol></div><pre class="programlisting">in vec3 vRedRay;
in vec3 vGreenRay;</pre><div class="orderedlist"><ol class="orderedlist arabic" start="16" type="1"><li>Insert the following code right under it:</li></ol></div><pre class="programlisting">in vec3 vBlueRay;</pre><div class="orderedlist"><ol class="orderedlist arabic" start="17" type="1"><li>It is assumed that the ambient component is the same for all the lights. This is reflected in the code by having only one <code class="literal">uLightAmbient</code> variable. The ambient term, <code class="literal">Ia</code>, is the product of <code class="literal">uLightAmbient</code> and the wall's material ambient property:</li></ol></div><pre class="programlisting">// ambient Term
vec4 Ia = uLightAmbient * uMaterialAmbient;</pre><div class="orderedlist"><ol class="orderedlist arabic" start="18" type="1"><li>If <code class="literal">uLightAmbient</code> is set to <code class="literal">(1.0, 1.0, 1.0, 1.0)</code> and <code class="literal">uMaterialAmbient</code> is set to <code class="literal">(0.1, 0.1, 0.1, 1.0)</code>, then the resulting ambient term, <code class="literal">Ia</code>, will be really small. This means the contribution of the ambient light will be low in this scene. In contrast, the diffuse component will be different for every light.</li><li>Let's add the effect of the blue diffuse term. In the <span>fragment</span><a id="id325628734" class="indexterm"></a> shader main function, look for the following code:</li></ol></div><pre class="programlisting">// diffuse Term
vec4 Id1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 Id2 = vec4(0.0, 0.0, 0.0, 1.0);</pre><div class="orderedlist"><ol class="orderedlist arabic" start="20" type="1"><li>Add the following line immediately under it:</li></ol></div><pre class="programlisting">vec4 Id3 = vec4(0.0, 0.0, 0.0, 1.0);</pre><div class="orderedlist"><ol class="orderedlist arabic" start="21" type="1"><li>Scroll down to the following:</li></ol></div><pre class="programlisting">float lambertTermOne = dot(N, -normalize(vRedRay));
float lambertTermTwo = dot(N, -normalize(vGreenRay));</pre><div class="orderedlist"><ol class="orderedlist arabic" start="22" type="1"><li>Add the following line of code right under it:</li></ol></div><pre class="programlisting">float lambertTermThree = dot(N, -normalize(vBlueRay));</pre><div class="orderedlist"><ol class="orderedlist arabic" start="23" type="1"><li>Scroll to the following:</li></ol></div><pre class="programlisting">if (lambertTermOne &gt; uCutOff) {
  Id1 = uDiffuseRedLight * uMaterialDiffuse * lambertTermOne;
}

if (lambertTermTwo &gt; uCutOff) {
  Id2 = uDiffuseGreenLight * uMaterialDiffuse * lambertTermTwo;
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="24" type="1"><li>Insert the following code after it:</li></ol></div><pre class="programlisting">if (lambertTermThree &gt; uCutOff) {
  Id3 = uDiffuseBlueLight * uMaterialDiffuse * lambertTermTwo;
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="25" type="1"><li>Update <code class="literal">fragColor</code> so that it includes <code class="literal">Id3</code>:</li></ol></div><pre class="programlisting">fragColor = vec4(vec3(Ia + Id1 + Id2 + Id3), 1.0);</pre><div class="orderedlist"><ol class="orderedlist arabic" start="26" type="1"><li>That's all we need to do in the fragment shader. Let's move on to our JavaScript code. So far, we have written the code that is needed to handle one more light inside our shaders. Let's see how we create the blue light from the JavaScript side and how we map it to the shaders. Scroll down to the <code class="literal">configure</code> function and look for the following code:</li></ol></div><pre class="programlisting">const redLight = new Light('redLight');
redLight.setPosition(redLightPosition);
redLight.setDiffuse([1, 0, 0, 1]);

const greenLight = new Light('greenLight');
greenLight.setPosition(greenLightPosition);
greenLight.setDiffuse([0, 1, 0, 1]);</pre><div class="orderedlist"><ol class="orderedlist arabic" start="27" type="1"><li>Insert the following code:</li></ol></div><pre class="programlisting">const blue = new Light('blueLight');
blue.setPosition([-2.5, 3, 3]);
blue.setDiffuse([0.0, 0.0, 1.0, 1.0]);</pre><div class="orderedlist"><ol class="orderedlist arabic" start="28" type="1"><li>Scroll to the point where the <code class="literal">uniforms</code> list is defined. As mentioned earlier, this new mechanism makes it easier to obtain locations for the uniforms. Add the two new uniforms that we are using for the blue light: <code class="literal">uDiffuseBlueLight</code> and <code class="literal">uPositionBlueLight</code>. The list should look like the following code:</li></ol></div><pre class="programlisting">const uniforms = [
'uProjectionMatrix',
'uModelViewMatrix',
'uNormalMatrix',
'uMaterialDiffuse',
'uMaterialAmbient',
'uLightAmbient',
'uDiffuseRedLight',
'uDiffuseGreenLight',
<span class="strong"><strong>'uDiffuseBlueLight',
</strong></span>'uPositionRedLight',
'uPositionGreenLight',
<span class="strong"><strong>'uPositionBlueLight',
</strong></span>'uWireframe',
'uLightSource',
'uCutOff'
];</pre><div class="orderedlist"><ol class="orderedlist arabic" start="29" type="1"><li>Let's pass the <span>position</span><a id="id325400763" class="indexterm"></a> and diffuse values of our newly defined light to <code class="literal">program</code>. Find the following lines, after the line that loads <code class="literal">program</code>, and make these necessary changes:</li></ol></div><pre class="programlisting">gl.uniform3fv(program.uPositionRedLight, redLight.position);
gl.uniform3fv(program.uPositionGreenLight, greenLight.position);
<span class="strong"><strong>gl.uniform3fv(program.uPositionBlueLight, blueLight.position);
</strong></span>
gl.uniform4fv(program.uDiffuseRedLight, redLight.diffuse);
gl.uniform4fv(program.uDiffuseGreenLight, greenLight.diffuse);
<span class="strong"><strong>gl.uniform4fv(program.uDiffuseBlueLight, blueLight.diffuse);</strong></span></pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note64"></a>Note</h3><p><strong class="userinput"><code>Uniform Arrays</code></strong>
Coding one uniform per light makes the code quite verbose. Later on, we will cover how to simplify the code using uniform arrays.</p></div><div class="orderedlist"><ol class="orderedlist arabic" start="30" type="1"><li>Let's update the <code class="literal">load</code> function. We need a new sphere to represent the blue light, the same way we have two spheres in the scene: one for the red light and the other for the green light. Append the following line:</li></ol></div><pre class="programlisting">scene.load('/common/models/geometries/sphere3.json', 'blueLight');</pre><div class="orderedlist"><ol class="orderedlist arabic" start="31" type="1"><li>As we saw in the <code class="literal">load</code> function, we are loading the same geometry (sphere) three times. To differentiate the sphere that represents the light source, we are using local transforms for the sphere (initially centered at the origin). Scroll to the <code class="literal">render</code> function and find the following lines of code:</li></ol></div><pre class="programlisting">const modelViewMatrix = transforms.modelViewMatrix;

if (object.alias === 'redLight') {
  mat4.translate(
    modelViewMatrix, modelViewMatrix, 
program.getUniform(program.uPositionRedLight)
  );
object.diffuse = program.getUniform(program.uDiffuseRedLight);
gl.uniform1i(program.uLightSource, true);
}

if (object.alias === 'greenLight') {
  mat4.translate(
    modelViewMatrix, modelViewMatrix,
program.getUniform(program.uPositionGreenLight)
  );
object.diffuse = program.getUniform(program.uDiffuseGreenLight);
gl.uniform1i(program.uLightSource, true);
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="32" type="1"><li>Add the following code:</li></ol></div><pre class="programlisting">if (object.alias === 'blueLight') {
  mat4.translate(
    modelViewMatrix, modelViewMatrix,
program.getUniform(program.uPositionBlueLight)
  );
object.diffuse = program.getUniform(program.uDiffuseBlueLight);
gl.uniform1i(program.uLightSource, true);
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="33" type="1"><li>That’s it! Save the page with a different name and test it in your browser:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788629690/graphics/cfc63326-c21b-448e-882d-a40372d53985.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="34" type="1"><li>If you do not obtain the expected result, please go back and check the steps. You will find the <span>completed</span><a id="id325400877" class="indexterm"></a> exercise in the <code class="literal">ch06_03_wall-final.html</code> file.</li></ol></div><p><span class="emphasis"><em><span class="strong"><strong>What just happened?</strong></span></em></span></p><p>We have modified our sample scene by adding one more light: a blue light. We have updated the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">The vertex shader</li><li style="list-style-type: disc">The fragment shader</li><li style="list-style-type: disc">The <code class="literal">configure</code> function</li><li style="list-style-type: disc">The <code class="literal">load</code> function</li><li style="list-style-type: disc">The <code class="literal">draw</code> function</li></ul></div><p>As you can see, handling light properties one uniform at a time is not very efficient. Later in this chapter, we will study a more effective way to handle lights in a WebGL scene.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec109"></a>Have a Go: Adding Interactivity</h3></div></div></div><p>We are going to add an additional slider to our <span>controls</span><a id="id325400964" class="indexterm"></a> widget to interactively change the position of the blue light we just added.</p><p>We will use <span class="strong"><strong>dat.GUI</strong></span>, one for each one of the <span>blue</span><a id="id325400979" class="indexterm"></a> light coordinates.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note65"></a>Note</h3><p><strong class="userinput"><code>dat.GUI</code></strong>
You can find more information about dat.GUI on GitHub: <a class="ulink" href="https://github.com/dataarts/dat.gui" target="_blank">https://github.com/dataarts/dat.gui</a>.</p></div><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Create three sliders: one for the <code class="literal">X</code> coordinate, one for the <code class="literal">Y</code> coordinate, and a third one for the <code class="literal">Z</code> coordinate for the blue light.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>The final GUI should include the new blue light sliders, which should look like the following:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788629690/graphics/b59d502d-8002-401c-ae21-59ad890cc627.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>Use the sliders present in the page to guide your work.</li><li>You will find the completed exercise in the<code class="literal">ch06_03_wall-final.html</code>file.</li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec110"></a>Using Uniform Arrays to Handle Multiple Lights</h3></div></div></div><p>As we've seen, handling light <span>properties</span><a id="id325401050" class="indexterm"></a> with individual uniforms makes the code verbose and difficult to maintain. Fortunately, ESSL provides several mechanisms we can use to solve the problem of handling multiple lights. One of them is <span class="strong"><strong>uniform arrays</strong></span>.</p><p>This technique allows us to handle multiple lights by introducing enumerable arrays of vectors in the shaders. This allows us to calculate light contributions by iterating through the light arrays in the shaders. We still need to define each light in JavaScript, but the mapping to ESSL becomes simpler since we aren’t defining one uniform per light property. Let's see how this technique works. We just need to make two simple changes in our code.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec111"></a>Uniform Array Declaration</h3></div></div></div><p>First, we need to declare the light <span>uniforms</span><a id="id325401107" class="indexterm"></a> as arrays inside our ESSL shaders. For example, the light position that contains three lights would look like this:</p><pre class="programlisting">uniform vec3 uPositionLight[3];</pre><p>It’s important to note that ESSL does not support <span>dynamic</span><a id="id325401124" class="indexterm"></a> initialization of uniform arrays. We could try something such as this:</p><pre class="programlisting">uniform int numLights;
uniform vec3 uPositionLight[numLights]; // will not work</pre><p>If so, the shader will not compile, and you will obtain the following error:</p><pre class="programlisting">ERROR: 0:12 — constant expression required
ERROR: 0:12 — array size must be a constant integer expression</pre><p>However, this construct is valid:</p><pre class="programlisting">const int numLights = 3;
uniform vec3 uPositionLight[numLights]; // will work </pre><p>We declare one uniform array per light property, regardless of how many lights we’re going to have. As a result, if we want to pass information about diffuse and specular components of five lights, for example, we need to declare two uniform arrays, as follows:</p><pre class="programlisting">uniform vec4 uDiffuseLight[5];
uniform vec4 uSpecularLight[5];</pre><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec33"></a>JavaScript Array Mapping</h4></div></div></div><p>Next,we need to map the JavaScript <span>variables</span><a id="id325401202" class="indexterm"></a> where we <span>have</span><a id="id325401210" class="indexterm"></a> the light property information to the program. For example, we may want to map these three light positions:</p><pre class="programlisting">const lightPosition1 = [0, 7, 3];
const lightPosition2 = [2.5, 3, 3];
const lightPosition3 = [-2.5, 3, 3];</pre><p>If so, we need to retrieve the uniform array location (just like in any other case):</p><pre class="programlisting">const location = gl.getUniformLocation(program, 'uPositionLight');</pre><p>The one difference is that we map these positions as a concatenated flat array:</p><pre class="programlisting">gl.uniform3fv(location, [0, 7, 3, 2.5, 3, 3, -2.5, 3, 3]);</pre><p>There are two important points here:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">The name of the uniform that is passed to <code class="literal">getUniformLocation</code> is the same as before. The fact that <code class="literal">uPositionLight</code> is now an array does not change a thing when you locate the uniform with <code class="literal">getUniformLocation</code>.</li><li style="list-style-type: disc">The JavaScript array that we are passing to the uniform is a flat array. If you write something as follows, the mapping will not work:</li></ul></div><pre class="programlisting">gl.uniform3fv(location, [
  [0, 7, 3],
[2.5, 3, 3],
[-2.5, 3, 3]
]);</pre><p>So, if you have one variable per light, you should ensure that you concatenate them before passing them to the shader.</p></div></div></div>