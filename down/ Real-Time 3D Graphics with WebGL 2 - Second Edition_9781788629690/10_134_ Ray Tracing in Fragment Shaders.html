<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch10lvl1sec136"></a>Ray Tracing in Fragment Shaders</h2></div></div><hr /></div><p>A common (if somewhat impractical) technique <span>used</span><a id="id325357458" class="indexterm"></a> to demonstrate how powerful shaders can be is to use them to <span class="strong"><strong>ray trace</strong></span> a scene. Thus far, all of our rendering has been <span>done</span><a id="id325358864" class="indexterm"></a> with <span class="strong"><strong>polygon rasterization</strong></span>, which is the technical term for the triangle-based rendering that WebGL incorporates. Ray tracing is an alternate rendering technique that traces the path of light through a scene as it interacts with mathematically defined geometry.</p><p>Ray tracing has several advantages compared to traditional polygonal rendering. Primarily, this includes creating more realistic scenes due to a more accurate lighting model that can easily account for things like reflection and reflected lighting. That said, ray tracing tends to be considerably slower than polygonal rendering, which is the reason it's not often used for real-time applications.</p><p> </p><p>Ray tracing a scene is <span>achieved</span><a id="id325358882" class="indexterm"></a> by creating a series of rays (represented by an origin and direction) that start at the camera's location and pass through each pixel in the viewport. These rays are then tested against every object in the scene to determine whether there are any intersections. If an intersection occurs, the closest intersection to the ray origin is returned, determining the color of the rendered pixel:</p><div class="mediaobject"><img src="/graphics/9781788629690/graphics/9706867e-f093-460e-9d33-6cc4178d3c43.png" /></div><p>Although there are many algorithms that can be used to determine the color of the intersection point – ranging from simple diffuse lighting to multiple bounces of rays coming off other objects to simulate reflection – we'll keep our example simple. It's important to note that the rendered scene will entirely be the product of the shader code.</p></div>