<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec14"></a>WebGL Rendering</h2></div></div><hr /></div><p>WebGL is a 3D graphics library that enables modern web browsers to render 3D scenes in a standard and efficient manner. According to Wikipedia, <span class="strong"><strong>rendering</strong></span> is <span>the</span><a id="id325614926" class="indexterm"></a> process of generating an image from a model by means of computer programs. Since this is a process executed by a computer, there are different ways to produce such images. There are three main distinctions to make when discussing rendering: software-based and hardware-based rendering, server-based and client-based rendering, and retained-mode and immediate-mode rendering. As we will see, WebGL offers a unique approach to hardware and client based rendering with an immediate-mode API on the web.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec5"></a>Software and Hardware Based Rendering</h3></div></div></div><p>The first distinction <span>we</span><a id="id325617264" class="indexterm"></a> should make is whether <span>we</span><a id="id325617272" class="indexterm"></a> are using any special graphics hardware. On one hand, we can talk about <span class="strong"><strong>software-based rendering</strong></span> for cases <span>where</span><a id="id325617285" class="indexterm"></a> all required calculations to render 3D scenes are performed using the computer's <span class="strong"><strong>Central Processing Unit</strong></span> (<span class="strong"><strong>CPU</strong></span>). On the other hand, as is <span>the</span><a id="id325617300" class="indexterm"></a> case with WebGL, we use <span>the</span><a id="id325617348" class="indexterm"></a> term <span class="strong"><strong>hardware-based rendering</strong></span> for scenarios where there is a GPU performing 3D graphics computations. From a technical standpoint, hardware-based rendering is much more efficient than software-based rendering, because the former involves dedicated hardware handling the necessary operations. In contrast, a software-based rendering solution can be more common due to the lack of hardware dependencies.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec6"></a>Server and Client Based Rendering</h3></div></div></div><p>The second distinction to <span>make</span><a id="id325617365" class="indexterm"></a> is whether the <span>rendering</span><a id="id325617373" class="indexterm"></a> process is happening locally or remotely. When the image that needs to be rendered is too complex, the render will most likely occur remotely. This is the case for 3D animated movies where dedicated servers with lots of hardware resources render intricate scenes. We <span>call</span><a id="id325617382" class="indexterm"></a> this <span class="strong"><strong>server-based rendering</strong></span>. The opposite of this approach takes place when rendering occurs locally. We <span>call</span><a id="id325628661" class="indexterm"></a> this <span class="strong"><strong>client-based rendering</strong></span>. WebGL offers a client-based rendering approach: the elements that are a part of the 3D scene are usually downloaded from a server. However, the processing required to obtain an image is all performed locally using the client's graphics hardware. Although this is not a unique solution, compared to other technologies (such as Java 3D, Flash, and the Unity Web Player Plugin), WebGL presents several advantages:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>JavaScript programming</strong></span>: JavaScript is a <span>language</span><a id="id325647201" class="indexterm"></a> that is natural to both web developers and browsers. Working with JavaScript allows <span>you</span><a id="id325647209" class="indexterm"></a> to access all parts of the DOM and easily integrate WebGL applications with other JavaScript libraries such as jQuery, React, and Angular.</li><li style="list-style-type: disc"><span class="strong"><strong>Automatic memory management</strong></span>: WebGL—unlike other technologies, such as OpenGL, where memory allocation and <span>deallocation</span><a id="id325652481" class="indexterm"></a> are handled manually—follows the rules for JavaScript variable scoping and automatic memory management. This simplifies programming tremendously while reducing the code footprint. Ultimately, this simplification makes it easier to understand the application logic.</li><li style="list-style-type: disc"><span class="strong"><strong>Pervasiveness</strong></span>: Web <span>browsers</span><a id="id325652526" class="indexterm"></a> with JavaScript capabilities are installed in smartphones and tablet devices by default. This means you can leverage WebGL across a vast ecosystem of desktop and mobile devices.</li><li style="list-style-type: disc"><span class="strong"><strong>Performance</strong></span>: Performance of WebGL <span>applications</span><a id="id325652540" class="indexterm"></a> is comparable to equivalent standalone applications (with some exceptions). This is possible due to WebGL's ability to access the local graphics hardware. Until recently, many 3D web rendering technologies used software-based rendering.</li><li style="list-style-type: disc"><span class="strong"><strong>Zero compilation</strong></span>: WebGL is <span>written</span><a id="id325656617" class="indexterm"></a> in JavaScript; therefore, there is no need to compile your code before executing it on the web browser. This empowers you to make changes in real-time and see how those changes affect your 3D web application. Nevertheless, when we cover shader programs, we will understand that some compilation is needed. However, this occurs in your graphics hardware and not in your browser.</li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec7"></a>Retained and Immediate Mode Rendering</h3></div></div></div><p>The third distinction to <span>make</span><a id="id325656668" class="indexterm"></a> is that WebGL is an <span>immediate</span><a id="id325656677" class="indexterm"></a> mode 3D rendering API designed for the web. Graphics APIs can be divided into retained-mode APIs and immediate-mode APIs.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec1"></a>Retained-Mode Rendering</h4></div></div></div><p>A <span class="strong"><strong>retained-mode</strong></span> API is declarative. The <span>application</span><a id="id325659804" class="indexterm"></a> builds a scene from primitives, such as shapes and lines, and then the graphics library maintains a scene model in memory. To change what is rendered, the application issues a command to update the scene, which could include, for example, adding or removing a shape; the library is then responsible for managing and redrawing the scene:</p><div class="mediaobject"><img src="/graphics/9781788629690/graphics/c2dba237-a335-421b-b217-18c1822e461b.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec2"></a>Immediate-Mode Rendering</h4></div></div></div><p>An <span class="strong"><strong>immediate-mode</strong></span> API is procedural. Immediate mode rendering requires the <span>application</span><a id="id325659861" class="indexterm"></a> to directly manage rendering. In this case, the graphics library does not maintain a scene model. Each time a new frame is drawn, the application issues all drawing commands required to describe the entire scene, regardless of actual changes. This method provides the maximum amount of control and flexibility to the application program:</p><div class="mediaobject"><img src="/graphics/9781788629690/graphics/dc2f5bdd-06d1-4b67-982b-ecf6ed5eb21c.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec3"></a>Retained Versus Immediate Mode Rendering</h4></div></div></div><p>Retained-mode rendering can be <span>simpler</span><a id="id325659886" class="indexterm"></a> to use, because the API does more of the work for you, such as initialization, state maintenance, and cleanup. However, it is <span>often</span><a id="id325659896" class="indexterm"></a> less flexible since the API forces its own particular scene model; it can also have higher memory prerequisites because it needs to provide a general-purpose scene model. Immediate-mode rendering, on the other hand, as offered with WebGL, is much more flexible and can implement targeted optimizations.</p></div></div></div>