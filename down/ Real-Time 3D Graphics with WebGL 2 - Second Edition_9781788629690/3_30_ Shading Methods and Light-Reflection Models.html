<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec39"></a>Shading Methods and Light-Reflection Models</h2></div></div><hr /></div><p>Although <span>the</span><a id="id325358908" class="indexterm"></a> terms <span class="emphasis"><em>shading</em></span> and <span class="emphasis"><em>lighting</em></span> are often ambiguously interchanged, they refer to two different concepts.</p><p>Shading refers to <span>the</span><a id="id325359420" class="indexterm"></a> type of <span class="emphasis"><em>interpolation</em></span> that is performed to obtain the final color for every fragment in the scene. Later, we will explain how the type of shading determines where the final color is calculated – in the vertex shader or in the fragment shader.</p><p>Once the shading model is established, the lighting model determines <span class="emphasis"><em>how</em></span> the normals, materials, and lights need to be combined to produce the final color. Since the equations for lighting models use the physical principles of light reflection, lighting models are also referred to as <span class="emphasis"><em>reflection models</em></span>.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec40"></a>Shading/Interpolation Methods</h3></div></div></div><p>In this section, we will analyze two basic <span>types</span><a id="id325631896" class="indexterm"></a> of interpolation methods: <span class="strong"><strong>Goraud</strong></span> and <span class="strong"><strong>Phong</strong></span> shading.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec12"></a>Goraud Interpolation</h4></div></div></div><p>The <span class="strong"><strong>Goraud</strong></span> interpolation method <span>calculates</span><a id="id325638062" class="indexterm"></a> the final color in the <span class="emphasis"><em>vertex shader</em></span>. The vertex normals are used to perform this calculation. Then, using a <span>varying</span><a id="id325638074" class="indexterm"></a> variable, the final color for the vertex is passed to the fragment shader. Due to the automatic interpolation of varyings provided by the rendering pipeline, each fragment will have a color that is the result of interpolating the colors of the enclosing triangle for each fragment.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note36"></a>Note</h3><p><strong class="userinput"><code>Varying Interpolation</code></strong>
The interpolation of varyings is automatic in the rendering pipeline. No programming is required.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec13"></a>Phong Interpolation</h4></div></div></div><p>The <span class="strong"><strong>Phong</strong></span> method calculates <span>the</span><a id="id325643390" class="indexterm"></a> final color in the <span class="emphasis"><em>fragment shader</em></span>. To do so, each vertex normal is passed from the vertex shader to <span>the</span><a id="id325643402" class="indexterm"></a> fragment shader using a varying. Because of the interpolation mechanism of varyings included in the pipeline, each fragment will have its own normal. Fragment normals are then used to calculate the final color in the fragment shader.</p><p>The following diagram summarizes the two interpolation models:</p><div class="mediaobject"><img src="/graphics/9781788629690/graphics/db67eb36-7e28-4bae-a22a-41fcebe47d39.png" /></div><p>The shading method does not specify how the final color for each fragment is calculated. It only specifies <span class="emphasis"><em>where</em></span> (vertex or fragment shader) and the <span class="emphasis"><em>type of interpolation</em></span> (vertex colors or vertex normals) to be used.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec14"></a>Goraud Versus Phong Shading</h4></div></div></div><p>We now understand that Goraud shading performs <span>the</span><a id="id325662206" class="indexterm"></a> calculations inside <span>the</span><a id="id325662215" class="indexterm"></a> vertex shader and leverages the built-in rendering pipeline's interpolation. Phong shading, on the other hand, performs all of the calculations inside the fragment shader – that is, per fragment (or pixel). With these two details in mind, can you guess some of the advantages and disadvantages of these two shading techniques?</p><p>Goraud shading is considered to be faster since the performed calculations are computed per vertex, whereas Phong shading is calculated per fragment. The speed in performance does come at the cost of accurate or more realistic interpolation. This is most noticeable in cases where a light's intensity does not linearly degrade between two vertices. Later in this chapter, we will cover these two techniques in more detail.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec41"></a>Light-Reflection Models</h3></div></div></div><p>As we mentioned previously, the lighting model is independent from the shading/interpolation model. The shading model only determines where <span>the</span><a id="id325662232" class="indexterm"></a> final color is calculated. Now, it’s time to talk about how to perform such calculations.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec15"></a>The Lambertian Reflection Model</h4></div></div></div><p><span class="strong"><strong>Lambertian reflections</strong></span> are commonly used in computer graphics as a model for <span class="emphasis"><em>diffuse reflections</em></span>, which are the kinds of reflections where an <span>incident</span><a id="id325662254" class="indexterm"></a> light ray is <span>reflected</span><a id="id325662263" class="indexterm"></a> in many angles instead of just <span class="emphasis"><em>one</em></span> angle, as is the case for <span class="emphasis"><em>specular reflections:</em></span></p><div class="mediaobject"><img src="/graphics/9781788629690/graphics/a64a1837-8373-4c63-8e9c-990f793505b8.png" /></div><p>This lighting model is <span>based</span><a id="id325662288" class="indexterm"></a> on the <span class="strong"><strong>cosine emission law</strong></span>, or <span class="strong"><strong>Lambert's emission law</strong></span>. It is <span>named</span><a id="id325662302" class="indexterm"></a> after Johann Heinrich Lambert, from his <span class="emphasis"><em>Photometria</em></span>, published in 1760.</p><p>The Lambertian reflection is usually calculated as the dot product between the surface normal (vertex or fragment normal, depending on the interpolation method used) and the negative of the light-direction vector. Then, the number is multiplied by the material and light source colors.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note37"></a>Note</h3><p><strong class="userinput"><code>Light-Direction Vector</code></strong><span class="strong"><strong></strong></span> The light-direction vector is the vector that starts on the surface and ends on the light source position. It is essentially the vector that maps the light's position to the surface of the geometry.</p></div><div class="mediaobject"><img src="/graphics/9781788629690/graphics/f2603264-b592-483a-bf80-aa64d7f766fd.png" /></div><p>Where:</p><pre class="programlisting"><div class="mediaobject"><img src="/graphics/9781788629690/graphics/985e3255-907f-4aea-bfb5-b33a0141f71c.png" /></div></pre><p><code class="literal"><div class="mediaobject"><img src="/graphics/9781788629690/graphics/df3fb635-b3f4-4b18-a264-a233ba54d3c9.png" /></div></code> is the final diffuse color, <code class="literal"><div class="mediaobject"><img src="/graphics/9781788629690/graphics/16d99b16-1d89-4270-b26b-bc660703a56a.png" /></div></code> is the light diffuse color, and <code class="literal"><div class="mediaobject"><img src="/graphics/9781788629690/graphics/62c4365b-5109-4562-9e1f-77ddff5bd52f.png" /></div></code> is the material diffuse color.</p><p>That being said, we'd derive the final diffuse color with the following:</p><pre class="programlisting"><div class="mediaobject"><img src="/graphics/9781788629690/graphics/accf601e-077d-425a-9dd6-e521577afd5f.png" /></div></pre><p>If <code class="literal"><span class="emphasis"><em>L</em></span></code> and <code class="literal"><span class="emphasis"><em>N</em></span></code> are normalized, then:</p><pre class="programlisting"><div class="mediaobject"><img src="/graphics/9781788629690/graphics/38654e6d-2b7f-41be-9e9b-239e8d7403ce.png" /></div></pre><pre class="programlisting"><div class="mediaobject"><img src="/graphics/9781788629690/graphics/38654e6d-2b7f-41be-9e9b-239e8d7403ce.png" /></div>
<div class="mediaobject"><img src="/graphics/9781788629690/graphics/de342375-8679-4766-9946-0ba3701bde5a.png" /></div></pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec16"></a>Phong Reflection Model</h4></div></div></div><p>The Phong reflection model <span>describes</span><a id="id325359196" class="indexterm"></a> the way a surface reflects the light as the sum of three types of reflection: ambient, diffuse, and specular. It <span>was</span><a id="id325359206" class="indexterm"></a> developed by Bui Tuong Phong, who published it in his 1973 PhD dissertation:</p><div class="mediaobject"><img src="/graphics/9781788629690/graphics/08c45d04-f1b2-4323-b5e8-c65357f20668.png" /></div><p>Let's cover these concepts individually.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec42"></a>Ambient</h3></div></div></div><p>The <span class="strong"><strong>ambient</strong></span> term accounts for <span>the</span><a id="id325359236" class="indexterm"></a> scattered light present in the scene. This term is independent from any light source and is the same for all fragments.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec43"></a>Diffuse</h3></div></div></div><p>The <span class="strong"><strong>diffuse</strong></span> term corresponds to <span>diffuse</span><a id="id325359289" class="indexterm"></a> reflections. A Lambertian model is typically used for this component.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec44"></a>Specular</h3></div></div></div><p>The <span class="strong"><strong>specular</strong></span> term provides mirror-like reflections. Conceptually, the specular reflection reaches its maximum when we look at the <span>object</span><a id="id325359307" class="indexterm"></a> at an angle that is equal to the reflected light-direction vector.</p><p>The specular term is modeled by the dot product of two vectors, namely, the eye vector and the reflected light-direction vector. The eye vector originates in the fragment and terminates in the view position (camera). The reflected light-direction vector is obtained by reflecting the light-direction vector upon the surface normal vector. When this dot product equals <code class="literal">1</code> (by working with normalized vectors), our camera will capture the maximum specular reflection.</p><p>The dot product is then exponentiated by a number that represents the shininess of the surface. After that, the result is multiplied by the light and material specular components:</p><div class="mediaobject"><img src="/graphics/9781788629690/graphics/68471f2f-1ce0-4094-8e1d-fe406493b447.png" /></div><p>Where:</p><pre class="programlisting"><div class="mediaobject"><img src="/graphics/9781788629690/graphics/9baf666c-1a43-46ef-a6bb-0e21a3e5a0e0.png" /></div></pre><div class="mediaobject"><img src="/graphics/9781788629690/graphics/ad2e8ccb-0131-4927-803b-40d7efd8375e.png" /></div><p> is the final specular color, <code class="literal"><div class="mediaobject"><img src="/graphics/9781788629690/graphics/16d99b16-1d89-4270-b26b-bc660703a56a.png" /></div></code> is the light specular color, <code class="literal"><div class="mediaobject"><img src="/graphics/9781788629690/graphics/62c4365b-5109-4562-9e1f-77ddff5bd52f.png" /></div></code> is the material specular color, and <span class="emphasis"><em><code class="literal">n</code> </em></span>is the shininess factor.</p><p>That being said, we'd derive the final specular color with the following:</p><pre class="programlisting"><div class="mediaobject"><img src="/graphics/9781788629690/graphics/0954711c-1ee5-48e8-a6ec-a16d1f61f228.png" /></div></pre><p>If <code class="literal"><span class="emphasis"><em>R</em></span></code> and <code class="literal"><span class="emphasis"><em>E</em></span></code> are normalized, then:</p><pre class="programlisting"><div class="mediaobject"><img src="/graphics/9781788629690/graphics/4c95954c-cb65-40a1-95a5-80cc2f0a1ef4.png" /></div>
<div class="mediaobject"><img src="/graphics/9781788629690/graphics/a922b679-1a3b-48bd-8ea7-14f7eb5c5599.png" /></div></pre><p>It's important to note that the specular reflection reaches its maximum when <code class="literal"><span class="emphasis"><em>R</em></span></code> and <code class="literal"><span class="emphasis"><em>E</em></span></code> have the same direction.</p><p>Once we have the ambient, diffuse, and specular terms, we add them to find the final color of the fragment, which provides us with the Phong reflection model.</p><p>Now, it’s time to learn about the language that will allow us to implement the shading and lighting strategies inside the vertex and fragment shaders. This language is called ESSL.</p></div></div>