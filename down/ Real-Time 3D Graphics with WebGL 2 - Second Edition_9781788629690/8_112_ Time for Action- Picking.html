<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec116"></a>Time for Action: Picking</h2></div></div><hr /></div><p>Let's cover an <span>example</span><a id="id325357458" class="indexterm"></a> of this technique in action:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Open the <code class="literal">ch08_01_picking.html</code> file using your browser. You will see a screen similar to this:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788629690/graphics/e850f2b2-c979-45fd-939d-acb2c3e037ee.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Here, you have a set of objects, each one of which has a unique diffuse color property. As was the case in previous examples, you can move the camera around the scene. Also, note that the cube has a texture and that the flat disk is translucent. As you may expect, the code in the <code class="literal">draw</code> function handles textures, coordinates, and also transparencies, so it looks a bit more complex than before (you can check it out in the source code). This is a more realistic <code class="literal">draw</code> function. In a real application, you will have to handle these cases.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>Click on the sphere and drag it around the scene. Notice that the object becomes translucent. Also, note that the displacement occurs along the axis of the camera. To make this evident, please go to your web browser's <code class="literal">console</code> and type in the following:</li></ol></div><pre class="programlisting">camera.setElevation(0);</pre><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>Once you resume the clock by clicking inside of the scene, you will see that the camera updates its position to an elevation of zero degrees, as shown in the following screenshot:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788629690/graphics/50cc11b7-2831-4d1b-b330-13b04c4f4d84.png" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip76"></a>Note</h3><p><strong class="userinput"><code>JavaScript Console</code></strong>
Firefox: <strong class="userinput"><code>Tools</code></strong> | <strong class="userinput"><code>WebDeveloper</code></strong> | <strong class="userinput"><code>WebConsole</code></strong>
Safari: <strong class="userinput"><code>Develop</code></strong> | <strong class="userinput"><code>Show Web Inspector</code></strong>
Chrome: <strong class="userinput"><code>Tools</code></strong> | <strong class="userinput"><code>Javascript Console</code></strong></p></div><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>When you click and drag <span>objects</span><a id="id325647131" class="indexterm"></a> in the scene from this perspective, you will see that they change their position according to the camera's axis. In this case, the up axis of the camera is aligned with the scene's y-axis. If you move an object up and down, you will see that they change their position in the <code class="literal">y</code> coordinate. If you change the camera position (by clicking on the background and dragging the mouse around), and then move a different object, you will see that the object moves according to the camera’s new y-axis.</li><li>Try different camera angles and see what happens.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="7" type="1"><li>Let's see what the offscreen framebuffer looks like. Click on the <strong class="userinput"><code>Show Picking Image</code></strong><span class="strong"><strong> </strong></span>button. Here, we are instructing the fragment shader to use each of the object diffuse properties to color the fragments. You can also rotate the scene and pick objects in this mode. If you want to go back to the original shading method, click on <strong class="userinput"><code>Show Picking Image</code></strong> again to deactivate it.</li><li>To reset the scene, click on <span class="strong"><strong><strong class="userinput"><code>Reset Scene</code></strong></strong></span>.</li></ol></div><p><span class="emphasis"><em><span class="strong"><strong>What just happened?</strong></span></em></span></p><p>We have seen an example of picking in action. The source code uses the <code class="literal">Picker</code> class that we previously described in the <span class="emphasis"><em>Architectural Updates</em></span> section. Let's examine it a bit closer.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec136"></a>Picker Architecture</h3></div></div></div><p>As you may have noticed, every picker state has a callback function associated with it. The following process outlines what happens in the <code class="literal">Picker</code> class when the user clicks the <span>mouse</span><a id="id325647221" class="indexterm"></a> on the <code class="literal">canvas</code>, drags it, and releases it:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>State</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Callback</strong></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">Picker</code> searches for a hit</p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">hitPropertyCallback(object)</code>: This callback informs the picker about which object property to use to make the comparison with the retrieved color from the offscreen framebuffer.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>User drags mouse in picking mode</p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">moveCallback(dx, dy)</code>: When the picking mode is activated (by having picked at least one object), this callback allows us to move the objects in the picking list (hits). This list is maintained internally by the <code class="literal">Picker</code> class.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Remove hit from picking list</p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">addHitCallback(object)</code>: If we click on an object and this object is not in the picking list, the picker notifies the application by triggering this callback.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Add hit to picking list</p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">removeHitCallback(object)</code>: If we click on an object and this object is already in the picking list, the picker will remove it from the list and then it will inform the application by triggering this callback.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>End Picking Mode</p></td><td style=""><p><code class="literal">processHitsCallback(hits)</code>: If the user releases the mouse button while the <span class="emphasis"><em>Shift </em></span>key is not pressed, the picking mode finishes and the application is notified by triggering this callback. If the <span class="emphasis"><em>Shift</em></span> key is pressed, then the picking mode continues, and the picker waits for a new click to continue looking for hits.</p></td></tr></tbody></table></div></div></div>