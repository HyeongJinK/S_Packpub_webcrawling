<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch11lvl1sec139"></a>What's New in WebGL 2?</h2></div></div><hr /></div><p>As of January 27, 2016, WebGL 2 is available by default in Firefox and Chrome. This means that you will automatically have access to WebGL 2 without <span>any</span><a id="id325358845" class="indexterm"></a> additional dependencies, as long as you use one of the following browsers:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Firefox 51 or above</li><li style="list-style-type: disc">Google Chrome 56 or above</li><li style="list-style-type: disc">Chrome for Android 64 or above</li></ul></div><p></p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note96"></a>Note</h3><p><strong class="userinput"><code>WebGL 2 Support</code></strong>
For an updated list of the browsers that support WebGL 2, please visit the Khronos Group web page by following this link: <a class="ulink" href="http://www.khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" target="_blank">http://www.khronos.org/WebGL/wiki/Getting_a_WebGL_Implementation</a>. Or, you can visit the well-known <span class="strong"><strong>CanIUse.com</strong></span> resource at: <a class="ulink" href="https://caniuse.com/#search=webgl2" target="_blank">https://caniuse.com/#search=WebGL 2</a>.</p></div><p>As described in <a class="link" href="#" linkend="ch01">Chapter 1</a>, <span class="emphasis"><em>Getting Started</em></span>, WebGL 1 is based on OpenGL ES 2.0; therefore, it doesn’t expose features like query timers, compute shaders, uniform buffers, and so on. That being said, with WebGL 2 (based on OpenGL ES 3.0), we are getting access to more GPU features like instancing and multiple render targets. Since WebGL 2 is a considerable upgrade from WebGL 1, let’s highlight some of its important features.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec165"></a>Vertex Array Objects</h3></div></div></div><p>As described in <a class="link" href="#" linkend="ch02">Chapter 2</a>, <span class="emphasis"><em>Rendering</em></span>, we <span>can</span><a id="id325628691" class="indexterm"></a> implement <span class="strong"><strong>vertex array objects</strong></span> in WebGL 1 by using the <code class="literal">OES_vertex_array_object</code> extension. That <span>being</span><a id="id325628705" class="indexterm"></a> said, they are available by default in WebGL 2. This is an important feature that should always<span class="emphasis"><em> </em></span>be used, since it significantly reduces rendering times. When not using vertex array objects, all attributes data is in a global WebGL state, which means that calling functions such as <code class="literal">gl.vertexAttribPointer</code>, <code class="literal">gl.enableVertexAttribArray</code>, and <code class="literal">gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer)</code> manipulates the global state. This leads to performance loss, because before any draw call, we would need to set up all vertex attributes and set the <code class="literal">ELEMENT_ARRAY_BUFFER</code> where indexed data is being used. On the other hand, with vertex array objects, we would set up all attributes during our application's initialization and simply bind the data during rendering, yielding much better performance. </p><p>This is very similar to the <code class="literal">IDirect3DVertexDeclaration9</code>/<code class="literal">ID3D11InputLayout</code> interfaces in DirectX land.</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>WebGL 1 with Extension</p></th><th style="border-bottom: 0.5pt solid ; "><p>WebGL 2</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">createVertexArrayOES</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">createVertexArray</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">deleteVertexArrayOES</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">deleteVertexArray</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">isVertexArrayOES</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">isVertexArray</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">bindVertexArrayOES</code></p></td><td style=""><p><code class="literal">bindVertexArray</code></p></td></tr></tbody></table></div><p>An example of this is as follows:</p><pre class="programlisting"><span>// Create a VAO instance
var</span> vertexArray <span>=</span><span>gl</span>.<span>createVertexArray</span>();

// Bind the VAO
<span>gl</span>.<span>bindVertexArray</span>(vertexArray);

<span>// Set vertex array states</span>
<span>// Set with GLSL layout qualifier
</span>const vertexPositionLocation = 0;
// Enable the attribute
<span>gl</span>.<span>enableVertexAttribArray</span>(vertexPositionLocation);
// Bind Buffer 
<span>gl</span>.<span>bindBuffer</span>(<span>gl</span>.<span>ARRAY_BUFFER</span>, vertexPositionBuffer);
// ...
// Configure instructions for VAO
<span>gl</span>.<span>vertexAttribPointer</span>(vertexPositionLocation, <span>2</span>, <span>gl</span>.<span>FLOAT</span>, <span>false</span>, <span>0</span>, <span>0</span>);

// Clean
<span>gl</span>.<span>bindVertexArray</span>(<span>null</span>);
gl.bindBuffer(gl.ARRAY_BUFFER, null);

<span>// ...</span><span>// Render</span><span>gl</span>.<span>bindVertexArray</span>(vertexArray);
<span>gl</span>.<span>drawArrays</span>(<span>gl</span>.<span>TRIANGLES</span>, <span>0</span>, <span>6</span>);</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec166"></a>Wider Range of Texture Formats</h3></div></div></div><p>While WebGL 1 had a limited <span>set</span><a id="id325629003" class="indexterm"></a> of texture formats, WebGL 2 provides a much larger set, some of which are listed here: </p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">RGBA32I</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">RG8</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">RGB16UI</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">RGBA32UI</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">RG8I</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">RGB8_SNORM</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">RGBA16I</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">RG8UI</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">RGB8I</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">RGBA16UI</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">R32I</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">RGB8UI</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">RGBA8</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">R32UI</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">SRGB8</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">RGBA8I</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">R16I</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">R11F_G11F_B10F</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">RGBA8UI</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">R16UI</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">RGB9_E5</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">SRGB8_ALPHA8</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">R8</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">RG32F</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">RGB10_A2</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">R8I</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">RG16F</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">RGB10_A2UI</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">R8UI</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">RG8_SNORM</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">RGBA4</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">RGBA32F</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">R32F</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">RGB5_A1</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">RGBA16F</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">R16F</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">RGB8</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">RGBA8_SNORM</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">R8_SNORM</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">RGB565</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">RGB32F</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">DEPTH_COMPONENT32F</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">RG32I</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">RGB32I</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">DEPTH_COMPONENT24</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">RG32UI</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">RGB32UI</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">DEPTH_COMPONENT16</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">RG16I</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">RGB16F</code></p></td><td style="border-bottom: 0.5pt solid ; "><p></p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">RG16UI</code></p></td><td style="border-right: 0.5pt solid ; "><p><code class="literal">RGB16I</code></p></td><td style=""><p></p></td></tr></tbody></table></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec167"></a>3D Textures</h3></div></div></div><p>A <span class="strong"><strong>3D texture </strong></span>is a <span>texture</span><a id="id325359593" class="indexterm"></a> in which each mipmap level contains a single three-dimensional image. A 3D texture is essentially just a <span>stack</span><a id="id325359600" class="indexterm"></a> of 2D textures that can be sampled with <code class="literal">x</code>, <code class="literal">y</code>, and <code class="literal">z</code> coordinates in the shader. This functionality allows us to have multiple 2D textures in a single object so that shaders can seamlessly select which image to use for each object.</p><p> This is useful for visualizing volumetric data (like medical scans), 3D effects like smoke, storing lookup tables, and so on.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec168"></a>Texture Arrays</h3></div></div></div><p><span class="strong"><strong>Texture arrays</strong></span>, similar to 3D textures, are a <span>great</span><a id="id325359630" class="indexterm"></a> feature for reducing complexity, improving code maintainability, and increasing the number of <span>textures</span><a id="id325359639" class="indexterm"></a> that can be used. By ensuring that all texture slices in a texture array are the same size, shaders can have access to many textures with a smaller footprint.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec169"></a>Instanced Rendering</h3></div></div></div><p>In WebGL 2, <span class="strong"><strong>instancing</strong></span> or <span class="strong"><strong>instanced rendering</strong></span> is available by default<span class="emphasis"><em>. </em></span>Instance rendering is a <span>way</span><a id="id325359665" class="indexterm"></a> to execute the same <span>drawing</span><a id="id325359671" class="indexterm"></a> commands <span>many</span><a id="id325359677" class="indexterm"></a> times in a row, with each producing a slightly different result. This can be a very efficient method for rendering a large amount of geometry with very few API calls.</p><p>Instancing is a great performance booster for certain types of geometry, especially objects with many instances but without many vertices. Good examples are grass and fur. Instancing avoids the overhead of an individual API call per object, while minimizing memory costs by avoiding storing geometric data for each separate instance.</p><p>Here's a quick example:</p><pre class="programlisting"><span>gl</span>.<span>drawArraysInstanced</span>(<span>gl</span>.<span>TRIANGLES</span>, <span>0</span>, <span>3</span>, <span>2</span>);</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec170"></a>Non-Power of 2 Texture Support</h3></div></div></div><p>As we saw in <a class="link" href="#" linkend="ch07">Chapter 7</a>, <span class="emphasis"><em>Textures</em></span><span class="emphasis"><em>,</em></span><span class="strong"><strong><span class="emphasis"><em> </em></span></strong></span>mipmaps <span>are</span><a id="id325359739" class="indexterm"></a> a powerful feature in which pre-calculated, optimized sequences of images, each of which is a progressively lower-resolution representation of the same image, allow for more optimized rendering. While in WebGL 1 the height and width of each image, or level, in the mipmap is a power of two smaller than the previous level, in WebGL 2, that <span>limit</span><a id="id325359748" class="indexterm"></a> is removed. That is, <span class="strong"><strong>non-power of 2 textures</strong></span> work the same as power of 2 textures.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec171"></a>Fragment Depth</h3></div></div></div><p>In WebGL 2, we can manually <span>set</span><a id="id325359765" class="indexterm"></a> our own custom values to the depth buffer (z-buffer). This feature allows you to manipulate the depth of a fragment from the fragment shader. This can be expensive, because it forces the GPU to bypass a lot of it's normal fragment discard behavior, but can also allow for some interesting effects that would be difficult to accomplish without having incredibly high poly geometry.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec172"></a>Texture Size in Shaders</h3></div></div></div><p>In WebGL 2, you can <span>look</span><a id="id325359780" class="indexterm"></a> up the size of any texture within ESSL shaders using <code class="literal">textureSize</code>. With WebGL 1, you'd need to create a uniform and pass the data into the shader manually.</p><p>For example:</p><pre class="programlisting"><span>vec2 size </span><span>=</span><span> textureSize</span><span>(</span><span>sampler</span><span>,</span><span> lod</span><span>);</span></pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec173"></a>Sync Objects</h3></div></div></div><p>With WebGL 1, the path from Javascript to GPU to screen is fairly opaque to developers. That is, you dispatch draw commands and at some <span>undefined</span><a id="id325359821" class="indexterm"></a> point in the future, the <span>results</span><a id="id325359830" class="indexterm"></a> show up on the screen. In WebGL 2, <span class="strong"><strong>sync objects</strong></span> allow the developer to gain a little more insight into when the GPU has completed it's work. Using <code class="literal">gl.fenceSync</code>, you can place a marker at some point in the GPU command stream and then later call <code class="literal">gl.clientWaitSync</code> to pause Javascript execution until the GPU has completed all commands up to the fence. Obviously blocking execution isn't desirable for applications that want to render fast, but this can be very beneficial for getting accurate benchmarks. It may also possibly be used in the future for synchronizing between workers.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec174"></a>Direct Texel Lookup</h3></div></div></div><p>It's often convenient to <span>store</span><a id="id325359853" class="indexterm"></a> large arrays of data in a texture. This is possible in WebGL 1, but you can only address textures with texture <span>coordinates</span><a id="id325359896" class="indexterm"></a> inside a range spanning from <code class="literal">0.0</code> to <code class="literal">1.0</code>. In WebGL 2, accessing this sort of data is considerably easier, as you can easily look up values from a texture with pixel/texel coordinates.</p><p>For example:</p><pre class="programlisting"><span>vec4 values </span><span>=</span><span> texelFetch</span><span>(</span><span>sampler</span><span>,</span><span> ivec2Position</span><span>,</span><span> lod</span><span>);</span></pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec175"></a>Flexible Shader Loops</h3></div></div></div><p>In WebGL 1, loops in the <span>shader</span><a id="id325359944" class="indexterm"></a> had to use a constant integer expression. However, since WebGL 2 is based on OpenGL ES 3.0, this <span>limit</span><a id="id325359953" class="indexterm"></a> no longer exists.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec176"></a>Shader Matrix Functions</h3></div></div></div><p>Given that WebGL 2's shading <span>language</span><a id="id325359966" class="indexterm"></a> is much <span>more</span><a id="id325359975" class="indexterm"></a> feature-rich than WebGL 1's, we now have many more matrix math operations at our fingertips. For example, if an <code class="literal">inverse</code> or <code class="literal">transpose</code> of a matrix is needed, we would need to pass it in as a uniform. However, in WebGL 2, functions such as <code class="literal">inverse</code><span class="emphasis"><em> </em></span>and <code class="literal">transpose</code> are functions directly built into shaders.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec177"></a>Common Compressed Textures</h3></div></div></div><p>In WebGL 1, there are various <span>compressed</span><a id="id325360004" class="indexterm"></a> texture formats <span>that</span><a id="id325360012" class="indexterm"></a> are hardware-dependent. For example, formats such as <code class="literal">S3TC</code> and <code class="literal">PVTC</code> are desktop and iOS only, respectively. However, in WebGL 2, the following formats are much more flexible by being hardware independent:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">COMPRESSED_R11_EAC RED</code></li><li style="list-style-type: disc"><code class="literal">COMPRESSED_SIGNED_R11_EAC RED</code></li><li style="list-style-type: disc"><code class="literal">COMPRESSED_RG11_EAC RG</code></li><li style="list-style-type: disc"><code class="literal">COMPRESSED_SIGNED_RG11_EAC RG</code></li><li style="list-style-type: disc"><code class="literal">COMPRESSED_RGB8_ETC2 RGB</code></li><li style="list-style-type: disc"><code class="literal">COMPRESSED_SRGB8_ETC2 RGB</code></li><li style="list-style-type: disc"><code class="literal">COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 RGBA</code></li><li style="list-style-type: disc"><code class="literal">COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 RGBA</code></li><li style="list-style-type: disc"><code class="literal">COMPRESSED_RGBA8_ETC2_EAC RGBA</code></li><li style="list-style-type: disc"><code class="literal">COMPRESSED_SRGB8_ALPHA8_ETC2_EAC</code></li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec178"></a>Uniform Buffer Objects</h3></div></div></div><p>Setting shader program <span>uniforms</span><a id="id325360136" class="indexterm"></a> is a huge part of almost any WebGL/OpenGL draw loop. This can make your draw calls fairly chatty as they <span>make</span><a id="id325360145" class="indexterm"></a> hundreds or thousands of <code class="literal">gl.uniform</code> calls. </p><p>In WebGL 1, if we have <code class="literal">n</code> number of uniforms that need to be updated, then it would require <code class="literal">n</code> number of calls with the appropriate uniform method—this can be quite slow. However, with WebGL 2, we can use <span class="strong"><strong>uniform buffer objects</strong></span><span class="strong"><strong>, </strong></span>which allow us to specify a large number of uniforms from a single buffer. This is a major boost in performance, since we can manipulate uniforms in the buffer outside of WebGL by using JavaScript-typed arrays and updating a set of uniforms with a single call. Additionally, uniform buffers can be bound to multiple programs at the same time, so it's possible to update global data (like projection or view matrices) once and all programs that use them will automatically see the changed values.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note97"></a>Note</h3><p><span class="strong"><strong><strong class="userinput"><code>Heterogeneous Uniform Buffer Objects</code></strong></strong></span>It's important to note that, in a given application, you can leverage a diverse set of uniform buffer objects to fit your application's needs.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec179"></a>Integer Textures and Attributes</h3></div></div></div><p>While in WebGL 1 textures <span>and</span><a id="id325360188" class="indexterm"></a> attributes are <span>represented</span><a id="id325360197" class="indexterm"></a> as floating-point values, regardless of their original type, in WebGL 2, textures and <span>attributes</span><a id="id325360205" class="indexterm"></a> are provided <span>integer</span><a id="id325360214" class="indexterm"></a> representation.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec180"></a>Transform Feedback</h3></div></div></div><p>A powerful technique <span>offered</span><a id="id325360227" class="indexterm"></a> in WebGL 2 is that vertex shaders can write their results back into a buffer. This can be very useful in situations <span>where</span><a id="id325632963" class="indexterm"></a> we want to leverage the GPU's computational power to perform complex computations so that we are able to read them within our application.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec181"></a>Sampler Objects</h3></div></div></div><p>While in WebGL 1 all texture <span>parameters</span><a id="id325632976" class="indexterm"></a> are <span class="emphasis"><em>per texture</em></span>, in WebGL 2, we can optionally use <span class="strong"><strong>sampler objects</strong></span>. By using samplers, we can move all texture <span>parameters</span><a id="id325632992" class="indexterm"></a> to a sampler, allowing a single texture to be sampled in different ways.</p><p>In WebGL 1, texture image data and sampling information (which tells GPU how to read the image data) are both stored in texture objects. It can be painful when we want to read from the same texture twice but with a different method (say, linear filtering vs nearest filtering) because we need to have two texture objects. With sampler objects, we can separate these two concepts. We can have one texture object and two different sampler objects. This will result in a change in how our engine organize textures.</p><p>Here’s an example:</p><pre class="programlisting"><span>const</span> samplerA <span>=</span><span>gl</span>.<span>createSampler</span>();
<span>gl</span>.<span>samplerParameteri</span>(samplerA, <span>gl</span>.<span>TEXTURE_MIN_FILTER</span>, <span>gl</span>.<span>NEAREST_MIPMAP_NEAREST</span>);
<span>gl</span>.<span>samplerParameteri</span>(samplerA, <span>gl</span>.<span>TEXTURE_MAG_FILTER</span>, <span>gl</span>.<span>NEAREST</span>);
<span>gl</span>.<span>samplerParameteri</span>(samplerA, <span>gl</span>.<span>TEXTURE_WRAP_S</span>, <span>gl</span>.<span>CLAMP_TO_EDGE</span>);
<span>gl</span>.<span>samplerParameteri</span>(samplerA, <span>gl</span>.<span>TEXTURE_WRAP_T</span>, <span>gl</span>.<span>CLAMP_TO_EDGE</span>);

<span>const</span> samplerB <span>=</span><span>gl</span>.<span>createSampler</span>();
<span>gl</span>.<span>samplerParameteri</span>(samplerB, <span>gl</span>.<span>TEXTURE_MIN_FILTER</span>, <span>gl</span>.<span>LINEAR_MIPMAP_LINEAR</span>);
<span>gl</span>.<span>samplerParameteri</span>(samplerB, <span>gl</span>.<span>TEXTURE_MAG_FILTER</span>, <span>gl</span>.<span>LINEAR</span>);
<span>gl</span>.<span>samplerParameteri</span>(samplerB, <span>gl</span>.<span>TEXTURE_WRAP_S</span>, <span>gl</span>.<span>MIRRORED_REPEAT</span>);
<span>gl</span>.<span>samplerParameteri</span>(samplerB, <span>gl</span>.<span>TEXTURE_WRAP_T</span>, <span>gl</span>.<span>MIRRORED_REPEAT</span>);

<span>// ...</span><span>gl</span>.<span>activeTexture</span>(<span>gl</span>.<span>TEXTURE0</span>);
<span>gl</span>.<span>bindTexture</span>(<span>gl</span>.<span>TEXTURE_2D</span>, texture);
<span>gl</span>.<span>bindSampler</span>(<span>0</span>, samplerA);

<span>gl</span>.<span>activeTexture</span>(<span>gl</span>.<span>TEXTURE1</span>);
<span>gl</span>.<span>bindTexture</span>(<span>gl</span>.<span>TEXTURE_2D</span>, texture);
<span>gl</span>.<span>bindSampler</span>(<span>1</span>, samplerB);</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec182"></a>Depth Textures</h3></div></div></div><p>A <span>major</span><a id="id325633267" class="indexterm"></a> drawback to WebGL 1 is the <span>lack</span><a id="id325633275" class="indexterm"></a> of support for <span class="strong"><strong>depth textures</strong></span>. In WebGL 2, they are available by default.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec183"></a>Standard Derivatives</h3></div></div></div><p>While in WebGL 1 you'd <span>need</span><a id="id325633292" class="indexterm"></a> to compute normal and pass them to shaders, in WebGL 2, you can compute them within shaders by using a <span>larger</span><a id="id325633302" class="indexterm"></a> set of mathematical operations that are available by default.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec184"></a>UNSIGNED_INT Indices</h3></div></div></div><p>In WebGL 2, there isn't a <span>practical</span><a id="id325633315" class="indexterm"></a> size limit for <span>indexed</span><a id="id325633323" class="indexterm"></a> geometries since we can use 32-bit <code class="literal">int</code> for indices.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec185"></a>Blend Equation MIN / MAX</h3></div></div></div><p>In WebGL, you <span>can</span><a id="id325633339" class="indexterm"></a> easily take the <code class="literal">MIN</code> or <code class="literal">MAX</code> of two colors <span>when</span><a id="id325633354" class="indexterm"></a> blending using these added functions.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec186"></a>Multiple Render Targets (MRT)</h3></div></div></div><p>In WebGL 2, you can <span>draw</span><a id="id325633368" class="indexterm"></a> to multiple buffers at <span>once</span><a id="id325633377" class="indexterm"></a> from a shader. This can be quite powerful for various deferred rendering techniques. This is "the big one" for many developers, because it makes many of the modern deferred rendering techniques that have become such a core part of modern realtime 3D practical for WebGL. </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec187"></a>Texture Access in Vertex Shaders</h3></div></div></div><p>While accessing textures <span>within</span><a id="id325633389" class="indexterm"></a> vertex shaders is possible in WebGL 1, you would need to count how many textures you could access, and that could equal zero. In WebGL 2, texture access is much more streamlined, and the texture access count is required to be at least <code class="literal">16</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec188"></a>Multi-Sampled Renderbuffers</h3></div></div></div><p>While in WebGL 1 we <span>could</span><a id="id325633408" class="indexterm"></a> only use the GPU's built in multi-sample system to anti-alias our <code class="literal">canvas</code>, in WebGL 2, there is support to <span>perform</span><a id="id325633419" class="indexterm"></a> our own custom multi-sampling.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec189"></a>Query Objects</h3></div></div></div><p><span class="strong"><strong>Query objects</strong></span> give <span>developers</span><a id="id325633436" class="indexterm"></a> another, more <span>explicit</span><a id="id325633445" class="indexterm"></a> way to peek at the inner workings of the GPU. A query wraps a set of GL commands for the GPU to asynchronously report some sort of statistic about. For example, occlusion queries are done in the following way: performing a <code class="literal">gl.ANY_SAMPLES_PASSED</code> query around a set of draw calls will let you detect if any of the geometry passed the depth test. If not, you know that the object wasn't visible and may choose not to draw that geometry in future frames until something happens (object moved, camera moved, and so on) that indicates that the geometry might have become visible again.</p><p>It should be noted that these queries are asynchronous, which means that a queries' results may not be ready for many frames after the query was originally issued! This makes them tricky to use, but it can be worth it in the right circumstances.</p><p>Here's an example:</p><pre class="programlisting">gl.beginQuery(gl.ANY_SAMPLES_PASSED, query);
gl.drawArraysInstanced(gl.TRIANGLES, 0, 3, 2);
gl.endQuery(gl.ANY_SAMPLES_PASSED);

//...

(function tick() {
if (!gl.getQueryParameter(query, gl.QUERY_RESULT_AVAILABLE)) {
// A query's result is never available in the same frame
    // the query was issued.  Try in the next frame.
requestAnimationFrame(tick);
return;
}

var samplesPassed = gl.getQueryParameter(query, gl.QUERY_RESULT);
gl.deleteQuery(query);
})();</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec190"></a>Texture LOD</h3></div></div></div><p>The <span class="strong"><strong>texture LOD</strong></span> parameter is used to determine which <span>mipmap</span><a id="id325633476" class="indexterm"></a> to fetch from. This allows for mipmap streaming, that is, loading only the <span>mipmap</span><a id="id325633482" class="indexterm"></a> levels currently needed. This is very useful for a WebGL environment, where textures are downloaded via a network.</p><pre class="programlisting"><span>gl</span>.<span>texParameterf</span>(<span>gl</span>.<span>TEXTURE_2D</span>, <span>gl</span>.<span>TEXTURE_MIN_LOD</span>, <span>0.0</span>);
<span>gl</span>.<span>texParameterf</span>(<span>gl</span>.<span>TEXTURE_2D</span>, <span>gl</span>.<span>TEXTURE_MAX_LOD</span>, <span>10.0</span>);</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec191"></a>Shader Texture LOD</h3></div></div></div><p>The <span class="strong"><strong>Shader Texture LOD</strong></span> bias control makes <span>mipmap</span><a id="id325633587" class="indexterm"></a> level control simpler for glossy environment effects in physically-based rendering. Now as <span>part</span><a id="id325633595" class="indexterm"></a> of the WebGL 2 core, the <code class="literal">lodBias</code> can be passed as an optional parameter to texture.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec192"></a>Floating Point Textures Always Available</h3></div></div></div><p>While in WebGL 1, floating <span>point</span><a id="id325633612" class="indexterm"></a> textures <span>are</span><a id="id325633621" class="indexterm"></a> optional<span class="emphasis"><em>,</em></span> but in WebGL 2, they are available by default.</p></div></div>