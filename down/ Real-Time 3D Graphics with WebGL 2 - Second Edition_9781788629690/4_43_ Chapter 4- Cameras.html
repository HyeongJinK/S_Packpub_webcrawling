<div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="ch04"></a>Chapter 4. Cameras</h2></div></div></div><p>In the previous chapter, we covered the vertex shader, fragment shader, and ESSL to a define a lighting model in our 3D scene. In this chapter, we will leverage these concepts to learn more about the matrices that we have seen in the source code. These matrices represent transformations that, when applied to our scene, allow us to display and move things around. In one case, we've already used them to set the camera to a distance to see all the objects in our scene, and in another case, we've used them to spin our 3D car model.</p><p>Even though we have a camera within our 3D application, there is no camera object in the WebGL API—only matrices. That is because having matrices instead of a camera object gives WebGL the flexibility to represent complex projections and animations. In this chapter, we will learn what these matrix transformations mean and how we can use them to define and operate a virtual camera.</p><p>In this chapter, we will look at the following topics:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Understanding the transformations that the scene undergoes from a 3D world to a 2D screen.</li><li style="list-style-type: disc">Learning about affine transformations.</li><li style="list-style-type: disc">Mapping matrices to ESSL uniforms.</li><li style="list-style-type: disc">Working with the Model-View and Projection matrix.</li><li style="list-style-type: disc">Appreciating the value of the Normal matrix.</li><li style="list-style-type: disc">Creating a camera and using it to move around a 3D scene.</li></ul></div></div>