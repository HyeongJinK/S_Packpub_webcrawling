<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec35"></a>Communication between services</h2></div></div><hr /></div><p>You currently know how to work with SF using Reliable services and Reliable actors. The next important topic refers to communication between each instance of a service. As we discussed at the beginning of this chapter, the best option when building your microservices is to create a platform that will be agnostic when it comes to choosing what is the best way to communicate and accept incoming requests. In SF, you do not have a single way to exchange messages—instead you are provided with a complete framework to do it your way. In this section, we will focus on building a simple communication channel for your services.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec34"></a>Creating a communication channel</h3></div></div></div><p>To create a channel, you will need to implement the <span>following</span><a id="id325310043" class="indexterm"></a> interface:</p><pre class="programlisting">public interface ICommunicationListener
{
    Task&lt;string&gt; OpenAsync(CancellationToken cancellationToken);
    Task CloseAsync(CancellationToken cancellationToken);
    void Abort();
}</pre><p>As you can see, there is no information regarding technology or the framework used—it is up to you. We will try to open the HTTP protocol in our service. Since we cannot cover all types of service in this book, we will focus on the stateless service. If you open the project from the section about it, in the main file of your service, you can find the following method:</p><pre class="programlisting">protected override IEnumerable&lt;ServiceInstanceListener&gt; CreateServiceInstanceListeners()
{
  return new ServiceInstanceListener[0];
}</pre><p>Currently, it returns an empty array—we would have to provide a custom implementation of <code class="literal">ServiceInstanceListener</code><span class="strong"><strong> </strong></span>and add it here. While it is, of course, possible to do so, it would take too much time to describe it in detail; instead, we use a NuGet package, which has the correct implementation of such a listener and is built using ASP.NET Core.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note64"></a>Note</h3><p>Currently, it is possible to use Http Sys or Kestrel to resolve communication. Feel free to experiment as those technologies differ a little and are always a substitute for each other (for example, Http Sys is currently not designed for stateful services).</p></div><p>For this exercise, please install the following package: <code class="literal">Microsoft.ServiceFabric.AspNetCore. HttpSys</code>. Once you have it, you can modify the <code class="literal">CreateServiceInstanceListeners()</code><span class="strong"><strong> </strong></span>method as follows:</p><pre class="programlisting">protected override IEnumerable&lt;ServiceInstanceListener&gt; CreateServiceInstanceListeners()
{
  return new[]
  {
    new ServiceInstanceListener(serviceContext =&gt;
      new HttpSysCommunicationListener(serviceContext, "ServiceEndpoint", (url, listener) =&gt;
        new WebHostBuilder()
          .UseHttpSys()
          .ConfigureServices(
            services =&gt; services
              .AddSingleton&lt;StatelessServiceContext&gt;(serviceContext))
          .UseContentRoot(Directory.GetCurrentDirectory())
          .UseServiceFabricIntegration(listener, ServiceFabricIntegrationOptions.None)
          .UseStartup&lt;Startup&gt;()
          .UseUrls(url)
          .Build()))
  };
}</pre><p>As you can see, it provided the full implementation of a listener and a pipeline for handling a request. You will also need to implement the <code class="literal">Startup</code> class, which will handle communication:</p><pre class="programlisting">public class Startup
{
  public Startup(IHostingEnvironment env)
  {
  }

  public Startup(IApplicationBuilder appenv, IHostingEnvironment env, ILoggerFactory loggerFactory)
  {
  }

  public void ConfigureServices(IServiceCollection services)
  {
  }

  public void Configure(IApplicationBuilder app)
  {
    app.Run(context =&gt; {
      return context.Response.WriteAsync("Hello From Service Fabric!");
    });
  }
}</pre><p>This may look familiar to you as this is a simple ASP.NET Core stack, which you would implement in the same manner, creating a web application not hosted in SF. Only one thing remains for now—we have to modify <code class="literal">ServiceManifest.xml</code> and specify that our endpoint is exposed by a service:</p><pre class="programlisting">&lt;Resources&gt;
  &lt;Endpoints&gt;
    &lt;Endpoint Name="ServiceEndpoint" Protocol="http" Port="80" /&gt;
  &lt;/Endpoints&gt;
&lt;/Resources&gt;</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note65"></a>Note</h3><p>Remember that the endpoint name must match the one you defined in your code.</p></div><p>Now, when you run your application, you should be able to call it by using the exposed endpoint, which can be found in <strong class="userinput"><code>Service Fabric Explorer</code></strong>:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/b4ccdc2a-99e5-4b01-b7d5-b8eefd3e8ef6.png" /></div><p>The following is the result of calling my service from the <span>Postman</span><a id="id325905353" class="indexterm"></a> application:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/188bbce4-3143-435e-b0fe-71a886392e1c.png" /></div><p>Now the question is: What you can do with such a feature? In fact, there are many possibilities—you can exchange messages between services, you can query a service for the status of a task currently performed, or you can change a state so a different path will be chosen when running a workload. This is a very powerful functionality and, in addition to all of the advantages that SF brings to distributed systems, you can be sure that your communication is reliable and fully under your control.</p></div></div>