<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch13lvl1sec113"></a>Azure Stream Analytics query language</h2></div></div><hr /></div><p>The strength of Azure Stream Analytics, besides the <span>rich</span><a id="id325128337" class="indexterm"></a> selection of Azure services that seamlessly integrate with it, lies in its query language, which allows you to analyze an input stream easily and output it to a required service. As it is an SQL-like language, it should be intuitive and easy to learn for most developers using this service. Even if you are not familiar with SQL, the many examples available and its simple syntax should make it easy for you.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl2sec134"></a>Writing a query</h3></div></div></div><p>In the Azure portal, the query window for <span>Azure</span><a id="id325128297" class="indexterm"></a> Stream Analytics can be found either in the <strong class="userinput"><code>Overview </code></strong>or <strong class="userinput"><code>Query </code></strong>blade:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/6f107657-c87b-49c9-ba89-4e19cd5ab35a.png" /></div><p>In the preceding example, you can see a simple SQL-like query, which performs the following three things:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Selects data from the input using the given alias</li><li style="list-style-type: disc">Chooses the particular columns</li><li style="list-style-type: disc">Pushes them into a specific output</li></ul></div><p>You can also click on the <strong class="userinput"><code>Edit query</code></strong><span class="strong"><strong> </strong></span>link, so you will be routed to the <strong class="userinput"><code>Query </code></strong>screen:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/94ac1af8-c1d2-4170-86fe-2f8422b725a3.png" /></div><p>As you can see, to be able to actually work with a query, you will need both an input and an output, as without them you will not be able to save it. In general, a query consists of three elements:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">SELECT</code>: Where you are selecting columns from the input you are interested in</li><li style="list-style-type: disc"><code class="literal">INTO</code>: Where you are telling the engine which output you are interested in</li><li style="list-style-type: disc"><code class="literal">FROM</code>: Where you are selecting an input from which data should be fetched</li></ul></div><p>Of course, the preceding statements are not the only ones, which are available—you can use plenty of different options, such as <strong class="userinput"><code>GROUP BY</code></strong>, <strong class="userinput"><code>LIKE</code></strong>, or <strong class="userinput"><code>HAVING</code></strong>. It all depends on the input stream and the schema of incoming data. For some jobs, you may only need to perform a quick transformation and extract the necessary columns; for others, you might require more sophisticated syntax for getting exactly what you want. You will find common query patterns in the link in the <span class="emphasis"><em>Further reading</em></span><span class="strong"><strong> </strong></span>section. In the preceding example, in the <code class="literal">SELECT</code> part of the query, I have selected three columns, which are available when analyzing <span>Azure</span><a id="id325117145" class="indexterm"></a> Event Hub events. What is more, I used the <code class="literal">AS </code> construct to tell the engine to actually rename fields to match those defined in the <strong class="userinput"><code>Outputs </code></strong>section. When I run my job, I can see that it actually passes events to my table:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/ad5a4907-d368-4b28-b879-b3d5a0482530.png" /></div><p>However, there are some problems with the current setup:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">We rely on the Event Hub fields, which might change in the future.</li><li style="list-style-type: disc">We are missing the actual data of an event.</li><li style="list-style-type: disc">There are duplicated columns.</li></ul></div><p>Let's assume each event has the following structure:</p><pre class="programlisting"> {"Id":"165e0206-8198-4f21-8a6d-ad2041031603","Date":"2018-09-02T12:17:48.3817632+02:00"}</pre><p>Of course, particular data changes over time. We can quickly change the query:</p><pre class="programlisting">SELECT
    PartitionId,
    Id,
    Date
INTO
    [handsonazure-tablestorage]
FROM
    [handsonazure-alias]</pre><p>And adapt the configuration to change the output a little bit:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/7c63a178-d8c3-44bc-9111-31cdbabd5fe9.png" /></div><p>However, the basic constructs are only a few percent of the overall capability of the service. There are also inbuilt functions, which can be easily used in each query to enhance it, as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Mathematical functions:</li></ol></div><pre class="programlisting"><span>SELECT</span><span>FLOOR</span>(<span>input</span>.x) <span>AS</span><span>"The FLOOR of the variable x"</span><span>FROM</span><span>input
SELECTSQUARE(input.x) AS<span>"The SQUARE of the variable x"</span>FROMinput
</span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Aggregate functions:</li></ol></div><pre class="programlisting"><span>SELECT</span><span>COUNT</span>(*) <span>FROM</span><span>Input
SELECTSUM (Income) FROMInput
SELECTAVG (Income) FROMInput
</span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>Analytic functions:</li></ol></div><pre class="programlisting"><span>SELECT</span> ISFIRST(mi, <span>10</span>) <span>as</span><span>first</span><span>FROM</span><span>Input</span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>Geospatial functions:</li></ol></div><pre class="programlisting"><span>SELECT</span> ST_DISTANCE(<span>input</span>.pos1, <span>input</span>.pos2) <span>FROM</span><span>input</span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>String functions:</li></ol></div><pre class="programlisting"><span>SELECT</span><span>SUBSTRING</span> (SerialNumber ,<span>1</span>,<span>3</span> ), <span>FROM</span><span>Input</span></pre><p>In addition to these, there are some more such as <span>record</span><a id="id325981084" class="indexterm"></a> functions, date/time functions, conversion, or array functions. The preceding examples are of course not all the available functions. You can find them all in the <span class="emphasis"><em>Further reading</em></span><span class="strong"><strong> </strong></span>section. The important thing here is that some functions are deterministic (this means that they always return the same result if the same input values are used), and some are not—this is especially important when handling high loads and trying to avoid possible anomalies.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip162"></a>Note</h3><p>Remember, you can merge different streams of data and push them to a single output (or vice versa—have a single input and distribute it to multiple outputs). This is a very powerful feature of this service, which makes ingesting and processing data much easier.</p></div></div></div>