<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch18lvl1sec152"></a>Autoscaling, scaling up, scaling out</h2></div></div><hr /></div><p>The cloud is all about scaling—it is one of the <span>most</span><a id="id326375021" class="indexterm"></a> important advantages of such a <span>setup</span><a id="id325120005" class="indexterm"></a> over an on-premises setup. The ability to rapidly adapt to new demands when it comes to incoming traffic, and the flexibility a cloud offers, enables you to create more stable services, which are less prone to unexpected load spikes and insufficient hardware performance. In this chapter, we will focus a little bit on diving deeper into the scaling topic, in order to build a deep understanding of how different services behave in Azure, and how you can ensure that the scaling feature is automated and requires as little attention as possible.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch18lvl2sec184"></a>Autoscaling</h3></div></div></div><p>You can define the autoscaling <span>feature</span><a id="id325120018" class="indexterm"></a> of many services as follows:</p><p>Autoscaling is a feature that allows a service, a machine, or an application to automatically scale up or out based on predefined parameters, like CPU utilization, memory used, or artificial factors, like throughput units, or worker utilization.</p><p>In general, you can describe autoscaling as follows:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/46d20333-10c9-41d2-ab7f-7435a38b386c.png" /></div><p>The preceding diagram can be described as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">A resource accepts incoming requests as normal</li><li style="list-style-type: disc">Simultaneously there is an entity that monitors a resource—it checks it against the scaling rules and decides whether a scaling operation is required</li><li style="list-style-type: disc">An entity takes a decision regarding scaling—it can scale a resource up/down or out, depending on the settings</li></ul></div><p>Of course, besides pros, scaling has its downsides:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">It may render your application unresponsive.</li><li style="list-style-type: disc">It requires additional resources for load balancing (if scaling out).
</li><li style="list-style-type: disc">It takes time, depending on the scaling characteristics. It is, therefore, crucial to plan such action at the design stage.</li><li style="list-style-type: disc">In many cases, it causes your solution to be many times more expensive.</li></ul></div><p>How a service scales depends solely on the service itself. Let us look at some examples:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Azure Event Hub can be scaled manually/automatically (using the auto-inflate feature). You can assign more <span class="strong"><strong>Throughput Units</strong></span> (<span class="strong"><strong>TUs</strong></span>) to an instance to enable it to accept more messages. Automatic scaling down is not implemented.</li><li style="list-style-type: disc">Azure App Services can be scaled both manually and automatically (it depends on the tier you have chosen). You have multiple different parameters available, and scaling down is also performed automatically.</li><li style="list-style-type: disc">Azure Cosmos DB relies on the <span class="strong"><strong>Request Unit</strong></span> (<span class="strong"><strong>RU</strong></span>) units assigned to an instance.</li><li style="list-style-type: disc">Azure SQL has different models for scaling—you can either use <span class="strong"><strong>Database Transaction Units</strong></span> (<span class="strong"><strong>DTUs</strong></span>) or vCores.</li><li style="list-style-type: disc">Azure Functions scale automatically using an internal mechanism of workers and the scale controller.</li><li style="list-style-type: disc">Azure Storage does not support scaling.</li></ul></div><p>As you can see, there is no single solution for scaling your services in Azure—you have to implement the working solution for each component individually. The rule of thumb is, that the less control over a resource you have, the more automated the scaling will be. While for IaaS scenarios, you have to operate the number of VMs, in <span class="strong"><strong>PaaS</strong></span>, you will end up with virtual cores or other units. Here you can find different cloud models ordered from the left to right in terms of the scaling complexity (where <span class="strong"><strong>IaaS </strong></span>has the most complex model):</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/b2a1a04f-2774-4fea-900b-09a3d00f697b.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch18lvl2sec185"></a>Scaling up and scaling out</h3></div></div></div><p>There are two different types of scaling (at least when it comes to Azure):</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Scaling up</strong></span>: Which <span>upgrades</span><a id="id325128339" class="indexterm"></a> hardware/a tier</li><li style="list-style-type: disc"><span class="strong"><strong>Scaling out</strong></span>: Which adds <span>instances</span><a id="id325128350" class="indexterm"></a> of a service
</li></ul></div><p>Scaling up can be presented as follows:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/aa1265ff-6c3f-4c72-9135-48842d0defca.png" /></div><p>While for comparison, scaling out is described as follows:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/0e10d23d-725f-424c-9f84-3e7ab02d3251.png" /></div><p>So, in the first scenario (scaling up), you will get a better performance from a single instance, while scaling out will allow you to parallelize your work. The use cases are different in both options and are basically dependent on the workload you are planning to run. These are some examples:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">If your code is sequential and there is no option to multiply it, use scaling up</li><li style="list-style-type: disc">If your code requires much compute power in a unit of time rather than dividing it into multiple machines, use scaling up</li><li style="list-style-type: disc">If you have a way to load balance your load, use scaling out</li><li style="list-style-type: disc">If you are able to perform the same work on multiple machines without a risk of collision, use scaling out</li></ul></div><p>Using scaling out can be compared to multithreading—but of course on a much bigger scale. In fact, the problems are quite the same. If your machine has multiple cores, and they are able to execute your code at the same time, you have to introduce very similar constraints. </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip209"></a>Note</h3><p>The common problems of scaling out are often caused by the access to the state—whether it is shared via any kind of storage, or distributed amongst many machines. Make sure you are aware of these before using this feature.</p></div><p>In Azure, multiple services scale out/up differently. We will focus on three of them to get a better understanding of the topic.</p></div></div>