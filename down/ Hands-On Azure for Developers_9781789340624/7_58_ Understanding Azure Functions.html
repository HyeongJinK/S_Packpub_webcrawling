<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec60"></a>Understanding Azure Functions</h2></div></div><hr /></div><p>Azure Functions are a part of so-called serverless components that are available in the <span>Azure</span><a id="id326269143" class="indexterm"></a> cloud. Before you start learning about this particular service, you will have to understand what serverless really means. While, initially, you may think that this concept implies no servers at all, you will quickly re-evaluate your way of thinking (as, we are still quite far away from not using any kind of machine for our applications and workloads).</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec53"></a>Being "serverless"</h3></div></div></div><p>You can easily find many different articles <span>describing</span><a id="id325326272" class="indexterm"></a> the term serverless—to be honest, I would like to avoid promoting a one and only correct definition, as this topic is currently so fuzzy, it is hard to find the best description. My goal, however, is to give you some hints and best practices, which will let you understand it in a way that makes the most sense to you.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl3sec43"></a>Responsibilities of cloud vendors</h4></div></div></div><p>We will start <span>with</span><a id="id325326297" class="indexterm"></a> the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/6bb1577f-2e5c-4d65-a206-b5ed8731b7c0.png" /></div><p> </p><p> </p><p>In the preceding screenshot, you can see the comparison of two of the most popular cloud models with serverless architecture regarding vendor responsibility. I compared them using five different fields:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Data center</strong></span>: DC infrastructure, security, maintenance, and staff</li><li style="list-style-type: disc"><span class="strong"><strong>Network security</strong></span>: Implementing correct and <span>secure</span><a id="id325466355" class="indexterm"></a> solutions regarding the network (firewalls, pen-tests, and anti-DDoS solutions)</li><li style="list-style-type: disc"><span class="strong"><strong>Operating systems</strong></span>: Updates, maintenance, and configuration</li><li style="list-style-type: disc"><span class="strong"><strong>Dev tools</strong></span>: Developing and delivering multiple features for programmers and administrators (such as extensions to IDE, management portal, and appropriate tools for managing services) </li><li style="list-style-type: disc"><span class="strong"><strong>Application host</strong></span>: The specific runtime that hosts and runs our application (such as App Service Plan)</li></ul></div><p>As you can see, the only difference (at least when using the described characteristics) is the application host. When it comes to serverless components, the only thing that you deliver to your <span>solution</span><a id="id325466391" class="indexterm"></a> is your code (or some kind of configuration, which is needed to set up a service)—the rest is delivered and handled by your cloud vendor. Of course, this is not the only way to define this idea.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl3sec44"></a>Pricing model</h4></div></div></div><p>One of the most popular features of serverless <span>services</span><a id="id325466405" class="indexterm"></a> and architectures is the possibility to pay for the number of executions and used computing power. This pricing model is the exact opposite of the most common prepaid model, where you pay a fixed price depending on a set of configured fields such as the number of used VMs or the size of a cluster. Here, you can find a table describing pricing for Azure Functions:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /><col /></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Meter</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Price</p></th><th style="border-bottom: 0.5pt solid ; "><p>Free grant (per month)</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Execution time</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span>€0.000014</span>/GB/s</p></td><td style="border-bottom: 0.5pt solid ; "><p>400.000 GB/s</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Total executions</p></td><td style="border-right: 0.5pt solid ; "><p><span>€0.169</span> per million executions</p></td><td style=""><p>1 million executions</p></td></tr></tbody></table></div><p>Now, you may wonder how can you understand this so that you can calculate the estimated cost of your solution. There are two things you have to understand to make your calculation correct:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Execution</strong></span>: This is a single function execution, which lasts <span class="emphasis"><em>N</em></span> seconds</li><li style="list-style-type: disc"><span class="strong"><strong>Consumption</strong></span>: This defines how many resources (CPU and memory) your function consumes within a fixed time</li></ul></div><p>Now, if you compare the preceding terms with the table, you will see that they differ slightly. This is because Azure Functions, pricing does not directly define the price for consumption but, rather, uses execution time. </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note89"></a>Note</h3><p>You have probably noticed the free grant<span class="strong"><strong> </strong></span>column in the pricing table. Remember that it applies only to the consumption model—it will not work for the prepaid one. </p></div><p>Now, let's assume that you have estimated the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">You will need 10 million executions of your function per month</li><li style="list-style-type: disc">Each execution lasts ~80 ms</li><li style="list-style-type: disc">You are using 145 MB of memory per execution</li></ul></div><p>To calculate the whole price for using Azure Functions, you can use the following formula:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/edf3841f-26f9-4ff5-a2a1-37328f2004dc.png" /></div><p>In the previous formula, the following is applicable:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Rc</strong></span>: Resource consumption defined as a product of memory consumed and execution time (in GB/s)</li><li style="list-style-type: disc"><span class="strong"><strong>Te:</strong></span> Total executions number (in millions)</li></ul></div><p>Now, if you enter the correct values and calculate the formula, you will get the following result:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/383af2c9-da5e-4eca-9463-727f0430ca55.png" /></div><p> </p><p>This will give you the following cost: 5.19 EUR. However, you may find the previous formula a bit confusing—why did I use <span class="emphasis"><em>256 </em></span>(instead of 128)<span class="strong"><strong> </strong></span>as the amount of memory consumed and<span class="emphasis"><em> 1 Ms</em></span><span class="strong"><strong> </strong></span>(instead of 800 Ks)<span class="strong"><strong> </strong></span>as the execution time? Well, there is one important thing to remember when using the consumption plan: the minimum execution time is 100 ms and when it comes to resources consumption, it is always <span class="strong"><strong>rounded up </strong></span>to the nearest 128 MBs.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip90"></a>Note</h3><p>In fact, when it comes to function execution, you cannot go under 100 ms and 128 MBs of used memory. This is very important when calculating possible cost optimization as, often, you should not aim at optimizing functions and rather focus on overall algorithm changes (such as batching or better serialization methods). </p></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec54"></a>Azure Functions concepts</h3></div></div></div><p>Now that you are a bit familiar with what serverless architecture is, we can start <span>learning</span><a id="id325773360" class="indexterm"></a> something else about Azure Functions. To proceed, you will need to understand the difference between the following topics:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Function apps</li><li style="list-style-type: disc">Functions</li><li style="list-style-type: disc">Triggers and bindings</li></ul></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl3sec45"></a>Function app</h4></div></div></div><p>The logical container for multiple <span>functions</span><a id="id326268285" class="indexterm"></a> is called a function app. A function app can host one or more functions, which will share configuration, settings, and runtime version. It is possible to run functions using multiple languages using the same function app.</p><p> </p><p> </p><p>Here, you can see what a single function app looks like, with several individual functions hosted within it:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/0dcf2ea5-2a59-429a-a92a-a29807ef6ac3.png" /></div><p>If you have the requirement to use both pricing plans (consumption and App Service), you will have to have two different functions apps, as a single one does not support such a scenario.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl3sec46"></a>Functions</h4></div></div></div><p>A single executable part of Azure <span>Functions</span><a id="id326268331" class="indexterm"></a> that hosts your code is called a <span class="strong"><strong>function</strong></span>. Each function can execute code written in different supported languages (one can use C#, while another can leverage Python features). The currently supported languages are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">C#</li><li style="list-style-type: disc">JavaScript</li><li style="list-style-type: disc">F#</li></ul></div><p>In the second version of runtime (v2), Java should also be available to use.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note91"></a>Note</h3><p>Please note that, at the time of writing this book, the v1 version is the only one that supports production workloads.</p></div><p>There is also the possibility of using a set of other languages (such as Powershell, PHP, or Batch), but they are in experimental mode and are not to be used in production. Here, you can find an example function with some boilerplate code:</p><pre class="programlisting">[FunctionName("QueueTrigger")]
public static void Run(
  [QueueTrigger("myqueue-items")] string myQueueItem, 
  TraceWriter log)
{
  log.Info($"C# function processed: {myQueueItem}");
}</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note92"></a>Note</h3><p>Note that the previous code was generated using Visual Studio—the boilerplate generated in Azure Portal looks a little bit different.</p></div><p> </p><p> </p><p>As you can see, a function consists of the following components:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Function decorator</strong></span>:<code class="literal"> [FunctionName]</code>, which allows the <span>runtime</span><a id="id326269185" class="indexterm"></a> to find a function, and delivers the required metadata</li><li style="list-style-type: disc"><span class="strong"><strong>Trigger</strong></span>: <code class="literal">[QueueTrigger]</code>—each function requires a trigger to be <span>configured</span><a id="id325175093" class="indexterm"></a> correctly</li><li style="list-style-type: disc"><span class="strong"><strong>Additional bindings</strong></span>: <code class="literal">TraceWriter</code>, which will be injected <span>during</span><a id="id325175110" class="indexterm"></a> runtime</li><li style="list-style-type: disc"><span class="strong"><strong>Function code: </strong></span>The actual logic that will be executed each time the function is called</li></ul></div><p>Of course, some parts of a function will differ depending on the features you use—in the previous example, we used a trigger for Azure Storage Queue, but there are also other possibilities (such as HTTP request, Azure Service Bus, or Azure CosmosDB); additionally, you can use other bindings and provide custom code each time. We will cover all of these topics in the following sections of this chapter.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl3sec47"></a>Triggers and bindings</h4></div></div></div><p>The power of Azure <span>Functions</span><a id="id325175132" class="indexterm"></a> comes when you consider all possible integrations, which can be used seamlessly and without much additional effort. In fact, the list of available triggers and bindings are quite impressive:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Azure Storage</li><li style="list-style-type: disc">Azure CosmosDB</li><li style="list-style-type: disc">Azure Event Grid</li><li style="list-style-type: disc">Azure Event Hub</li><li style="list-style-type: disc">HTTP</li><li style="list-style-type: disc">Microsoft Graph</li><li style="list-style-type: disc">Azure Mobile Apps</li><li style="list-style-type: disc">Azure Notification Hub</li><li style="list-style-type: disc">Azure Service Bus</li><li style="list-style-type: disc">Timer</li><li style="list-style-type: disc">Twilio</li><li style="list-style-type: disc">SendGrid</li></ul></div><p>Additionally, you have access to some experimental triggers and bindings, which may not be officially supported, but can be used in your application if you decide to do so (such as external files and external tables).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note93"></a>Note</h3><p>Remember that some experimental triggers and bindings will never reach GA status as there are specific recommendations (such as using Azure Logic Apps), which should be followed in most cases.</p></div><p>Of course, it is possible to introduce custom triggers and bindings since Azure <span>Functions</span><a id="id325175419" class="indexterm"></a> provides a full SDK, which can be used to extend runtime. However, this is an advanced topic that will be not covered in this book—you will find a reference to the appropriate tutorials in the <span class="emphasis"><em>Further reading</em></span><span class="strong"><strong> </strong></span>section. Here, you can find an example of a custom binding, which I used for authorizing a user:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/ce5fbcc9-231f-4ce5-8353-d8103d04b14d.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl3sec48"></a>Pricing models</h4></div></div></div><p>In Azure Functions, there are two pricing <span>models</span><a id="id325175450" class="indexterm"></a> available:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Consumption model</strong></span>: This was<span class="strong"><strong> </strong></span>described in the previous sections, where you pay for the number of executions of your functions and the computing power used</li><li style="list-style-type: disc"><span class="strong"><strong>App Service Plan </strong></span><span class="strong"><strong>model</strong></span>: This is where you select an App <span>Service</span><a id="id325220504" class="indexterm"></a> Plan version, which has a fixed price, no matter how many times you execute your functions</li></ul></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec55"></a>Scaling</h3></div></div></div><p>One of the most important features of serverless <span>components</span><a id="id325220519" class="indexterm"></a> and architectures is their ability to scale out as they are loaded more and more. While in traditional PaaS services, you often have to worry about available instances or scaling configuration. Serverless allows for the seamless handling of incoming requests, even if a service is hit by an unexpectedly high traffic. In this section, we will talk about the scaling capabilities of Azure Functions, with a focus on differences between consumption and App Service models.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl3sec49"></a>Scaling in the consumption model</h4></div></div></div><p>When you use the consumption model in Azure Functions, you are not defining any available instances for your <span>service</span><a id="id325220534" class="indexterm"></a> and are unable to configure auto-scaling settings. In fact, in this model, you are completely unaware of the number of machines running your workloads (however, if you integrate your functions with Azure Application Insights, you will be able to see how many instances have been created by taking a <span>look</span><a id="id325220542" class="indexterm"></a> at the <span class="strong"><strong>Live Stream</strong></span> blade).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note94"></a>Note</h3><p>In the consumption model, you have a fixed limit when it comes to the memory available for each execution of your function—this is 1.536 MBs. Whether your functions will scale or not depends on the current utilization of both memory and CPU.</p></div><p>The advantage of this plan is the ability to easily scale to hundreds of functions while running the same code concurrently. Of course, it all depends on the actual trigger used in a function—while, with the HTTP trigger, you have to scale out to be able to handle multiple requests at once, using the event hub trigger, for instance, will automatically increase the number of working instances for each partition used. On the other hand, you cannot always rely on the consumption plan to be sure that you will not expect delays in responses or temporary unavailability—immediate scaling out is not guaranteed by any means, so this particular pricing plan is not always the best solution when your application has to face quick peaks of traffic.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note95"></a>Note</h3><p>Remember that the current maximum for scaling a function app is limited to 200. Also worth noting is the fact that the runtime will allocate new instances no often than every 10 seconds.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl3sec50"></a>Scaling in the App Service model</h4></div></div></div><p>Using the App <span>Service</span><a id="id325220846" class="indexterm"></a> model has its benefits, especially when it comes to covering some cases of scaling that are not covered in the consumption plan. As mentioned in the previous section, if you have to be sure that you are able to handle the incoming load, it is often a better idea to use this particular model, as it ensures that some fixed resources will be available for your function app. Additionally, you are 100% sure that the provided hardware is provisioned for your application—this is not always the case in the consumption model since you have no guarantees when it comes to delivered machines and their characteristics. What's more, you are sure that your runtime is always running—since, in the consumption model, when a function is not used, its resources will be de-allocated, you can face quite common issues such as cold starts.</p></div></div></div>