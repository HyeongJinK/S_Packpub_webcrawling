<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch11lvl1sec95"></a>Storing data with Azure Storage Tables</h2></div></div><hr /></div><p>We will start our journey with Azure <span>Storage</span><a id="id325128270" class="indexterm"></a> capabilities by learning something about Table Storage. If you want to store unstructured data with almost limitless capacity and with high demands regarding availability and durability, this service is for you. In this section, you will learn how to start developing applications using Table Storage and the best practices for storing data and achieving the best performance for both writing and reading it. You will also see how to efficiently query it, and what is important when designing services using this Azure Storage capability.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec108"></a>Creating an Azure Storage service</h3></div></div></div><p>To get started, we have to actually create an <span>instance o</span><a id="id325125010" class="indexterm"></a>f Azure Storage. To do so, please following these steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Go to Azure Portal and click on <strong class="userinput"><code>+ Create a resource</code></strong>.<span class="strong"><strong> </strong></span>Search for <code class="literal">storage account</code><span class="strong"><strong> </strong></span>and click on the <strong class="userinput"><code>Create </code></strong>button.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>You will see a typical form, where you have to configure a new instance of a service. The following is an example of what I chose:</li></ol></div><div class="mediaobject"><img src="/graphics/9781789340624/graphics/0fe044dc-3ae2-494f-b3c9-72c1f6cfc6ef.png" /></div><p>Now I would like to describe some more mystique options available here:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><strong class="userinput"><code>Deployment model</code></strong>: You can select a different deployment model depending on your current requirements. In general, for almost every new storage account, you will select <strong class="userinput"><code>Resource manager</code></strong><span class="strong"><strong> </strong></span>as the default option. <strong class="userinput"><code>Classic </code></strong>mode is designed for legacy deployments, which use classic virtual networks. This choice also limits available options when it comes to selecting <strong class="userinput"><code>Account kind</code></strong><span class="strong"><strong> </strong></span>and some additional features such as <strong class="userinput"><code>Performance </code></strong>tier.</li><li style="list-style-type: disc"><strong class="userinput"><code>Account kind</code></strong>: You have three options available here (general purpose, V1/V2, and blob). If you would like to use your storage account with multiple capabilities (tables, queues, blobs), select storage. Selecting V2 gives you the possibility to define an access tier (cool or hot), which is directly connected to the frequency of accessing data stored within an account.</li><li style="list-style-type: disc"><strong class="userinput"><code>Secure transfer required</code></strong>: With Azure Storage it is possible to require a secure connection if this option is enabled. Turn it on for your production workloads, so no-one will be able to access data stored within an account using, for example, HTTP instead of HTTPS.</li><li style="list-style-type: disc"><strong class="userinput"><code>Performance</code></strong>: It is possible to select either the <strong class="userinput"><code>Standard </code></strong>or <strong class="userinput"><code>Premium </code></strong>performance tier. As mentioned previously, this impacts hardware used to provision your service with common magnetic disks for the <strong class="userinput"><code>Standard </code></strong>tier and SSDs for <strong class="userinput"><code>Premium</code></strong>.</li><li style="list-style-type: disc"><strong class="userinput"><code>Virtual networks</code></strong>: As in many other services, Azure Storage can be provisioned within a virtual network, limiting access to it even more.</li></ul></div><p>When everything is set and ready, you can click on the <strong class="userinput"><code>Create </code></strong>button and wait a moment—your account will be created and soon you will be able to start working with it.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec109"></a>Managing Table Storage</h3></div></div></div><p>When you go to the <strong class="userinput"><code>Overview </code></strong>blade, you will see a dashboard with basic information <span>available</span><a id="id325115429" class="indexterm"></a> regarding your account:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/2de66b43-6ced-46ef-b71e-4a6c8cd175d7.png" /></div><p>As you can see, it displays the information you defined while creating it, such as location, performance tier, or replication type. Additionally, when you scroll down, you will see the <strong class="userinput"><code>Monitoring </code></strong>section, where you can see how the whole service works:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/246d60e7-683d-4208-acbc-cfe0e65a7976.png" /></div><p>In this section, we are covering Table Storage, so find the <strong class="userinput"><code>Tables </code></strong>blade on the left and click on it. Initially, you should see no tables at all—of course, this is something we expected as this instance of a service has been just provisioned. Nonetheless, this is one of the methods to check what is actually stored within an account:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/64faa472-8f79-4ee1-b70c-7ac9bf322d86.png" /></div><p>To create a new table, simply click on the <strong class="userinput"><code>+ Table</code></strong><span class="strong"><strong> </strong></span>button—you will be asked to provide a table name, which is all that is needed to get started. As you probably remember, I described Table Storage as the capability for storing unstructured data. This is the reason why there are no other options for starting with a table—you simply rely on the internal specification of how this service works. The following shows what it looks like when a new container is created:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/bff7574c-05a3-4fed-b569-add886c4c274.png" /></div><p>The preceding screenshot shows an <code class="literal">orders</code> table and its URL—you <span>may</span><a id="id325117195" class="indexterm"></a> wonder what this URL is all about. As there are multiple ways to manage and use Azure services, Azure Storage allows you to use its capabilities using different methods, such as REST, Powershell, Azure CLI, or Azure Portal. When using SDKs and reading their source code, you could find that they are just wrappers around simple a REST API. This makes this particular service superbly easy to get started and work with on a daily basis. We have talked a little bit about Tables basics—now it is time to describe their schema.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec110"></a>Storing data in Table Storage</h3></div></div></div><p>Each record in Table Storage has a row structure with multiple columns. Each <span>row</span><a id="id325120010" class="indexterm"></a> has the following base columns:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">PartitionKey</code>: Identifier of a partition of a row</li><li style="list-style-type: disc"><code class="literal">RowKey</code>: The row's identifier</li><li style="list-style-type: disc"><code class="literal">Timestamp</code>: This column tells you when a row was recently modified</li><li style="list-style-type: disc"><code class="literal">ETag</code>: Table Storage implements the optimistic concurrency model and uses ETags to control whether an entity should be modified or not</li></ul></div><p>Of course, you are not limited to the columns listed above—you can create any additional columns you want and give each a specified type. However, before we go any further, you have to fully understand the implications of such a design. Here you can find an example of entities stored within a single table:</p><p><span>2018-07-13T11:56:11.108Z</span></p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /><col /><col /><col /><col /><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">PartitionKey</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">RowKey</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">Timestamp</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">Name</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">Price</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">Created</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">CustomerId</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Quantity</strong></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Order</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>16Hbs6gs8s</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2018-07-13T11:56:11.108Z</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2018-07-13T11:36:11.108Z</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>customer-001</p></td><td style="border-bottom: 0.5pt solid ; "><p></p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>16Hbs6gs8s</p></td><td style="border-right: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; "><p>2018-07-13T11:57:17.108Z</p></td><td style="border-right: 0.5pt solid ; "><p>Sponge</p></td><td style="border-right: 0.5pt solid ; "><p>3.00</p></td><td style="border-right: 0.5pt solid ; "><p>2018-07-13T11:36:11.108Z</p></td><td style="border-right: 0.5pt solid ; "><p></p></td><td style=""><p>3</p></td></tr></tbody></table></div><p> </p><p>In the preceding example, you data is stored within multiple partitions and though a single table is used, multiple schemas still can work, so there is no need to use additional containers. Additionally, I used a simple pattern, which allows you to introduce 1:n relationship—each order has a unique <code class="literal">RowKey</code>, which can be used as a partition key for entities related to it (allowing for really easy querying of data).</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch11lvl3sec58"></a>PartitionKey</h4></div></div></div><p>Table Storage uses partitions to distribute, load, and handle requests. The number of <span>partition</span><a id="id326395552" class="indexterm"></a> keys within a table impacts the ability to balance them. It is possible to use a single partition per table, but in most cases, this is an invalid approach, which will lower the performance of your storage account. Partition keys are limited to 1 KB in size and have to be unique within a table (so once an entity is assigned a partition key, all others that use the same value will be stored in the same storage). They also have to be strings.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch11lvl3sec59"></a>RowKey</h4></div></div></div><p>Each row key is a unique identifier of a row within a partition (so you can have rows using the same <code class="literal">RowKey</code> column value as long they have a different <code class="literal">PartitionKey</code>). More importantly, each table is sorted in ascending using values of row keys. This requires a smart design when you need, for example, to read only a selection of the top rows and do not want to provide their row keys (we will cover that later in this chapter). Like <code class="literal">PartitionKey</code>, <code class="literal">RowKey</code> is also limited to 1 KB and has to be a string.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch11lvl3sec60"></a>Timestamp</h4></div></div></div><p>This column is maintained server-side and is a <code class="literal">DateTime</code> value that is changed each time an entity is modified. It is also internally used to <span>provide</span><a id="id326395882" class="indexterm"></a> optimistic concurrency, and cannot be modified. Even if you set it, the value will be ignored.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch11lvl3sec61"></a>General rules for entities</h4></div></div></div><p>Table Storage has some hard limitations when it comes to storing data:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">The maximum number of columns is 255</li><li style="list-style-type: disc">The maximum size of an entity is 1 MB</li><li style="list-style-type: disc">By default, each entity column is created as a type string—this can be overridden when it is created</li><li style="list-style-type: disc">It is not possible to store null as a value—if you do not <span>provide</span><a id="id326396050" class="indexterm"></a> a column value, an entity will be considered as if it does not have it at all</li></ul></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec111"></a>Querying data in Table Storage</h3></div></div></div><p>To query data in Table Storage, you will <span>need</span><a id="id326396065" class="indexterm"></a> a simple application (it can be a console application) and an SDK for this service. You will also need an instance of Azure Storage—it can be either the one provisioned in Azure, or a local one, if you installed Storage Emulator.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note140"></a>Note</h3><p>To get started with Storage Emulator, simply search for an executable (for example, <strong class="userinput"><code>Start |</code></strong> type <code class="literal">Storage Emulator</code>) and run it. It will initially create a database for storing data and run in the background, so you will not have to worry about accidentally closing it.</p></div><p>To get started, we have to install the <code class="literal">WindowsAzure.Storage</code> package using NuGet Package Manager. It has everything that is needed to start working with Azure Storage in .NET. Here you can find an example of code for creating a table:</p><pre class="programlisting">using Microsoft.WindowsAzure.Storage;

namespace TableStorage
{
    internal class Program
    {
        private static void Main()
        {
            var storageAccount = CloudStorageAccount.Parse("&lt;connection-string&gt;");
            var tableClient = storageAccount.CreateCloudTableClient();
            var table = tableClient.GetTableReference("orders");

            table.CreateIfNotExists();
        }
    }
}</pre><p>We can briefly describe what this code does:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>It parses a connection string so it can be used in the following methods</li><li>It creates an instance of <code class="literal">CloudTableClient</code>class, which is the main class for working with Table Storage</li><li>It gets a reference to a table <code class="literal">order</code>, whether it exists or not</li><li>Finally, it creates an <code class="literal">orders</code> table, if does not exist already</li></ol></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip141"></a>Note</h3><p>You could also use the <code class="literal">Create()</code><span class="strong"><strong> </strong></span>method instead of <code class="literal">CreateIfNotExists()</code>, although, it could break if a table has been already created.</p></div><p>Now we need to get a connection string, so depending on the storage account you would like to use you either:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Have to go to Azure Portal, find your storage account, and copy a connection string from <strong class="userinput"><code>Access keys</code></strong><span class="strong"><strong> </strong></span>blade</li><li style="list-style-type: disc">Use the <code class="literal">UseDevelopmentStorage=true</code><span class="strong"><strong> </strong></span>value for connecting with Storage Emulator</li></ul></div><p>When you execute an application, a table should be created without a problem. Now, when we have a table, we would like to actually insert something in it. To do so, you will need the following code:</p><pre class="programlisting">var op = TableOperation.Insert(new DynamicTableEntity("orders", Guid.NewGuid().ToString(), "*",
  new Dictionary&lt;string, EntityProperty&gt;
  {
    {"Created", EntityProperty.GeneratePropertyForDateTimeOffset(DateTimeOffset.Now)},
    {"CustomerId", EntityProperty.GeneratePropertyForString("Customer-001")}
  }));

table.Execute(op);</pre><p>Here we are creating a new <code class="literal">TableOperation</code>, which accepts one argument that is an instance of <code class="literal">TableEntity</code>. <code class="literal">TableEntity</code> is a base class that contains all row properties, and has to be passed to a table (like <code class="literal">PartitionKey</code> or <code class="literal">RowKey</code>). Of course, instead of using <code class="literal">DynamicTableEntity</code>, you can derive from <code class="literal">TableEntity</code>and introduce a custom entity class. </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip142"></a>Note</h3><p>In the preceding example, we used the <code class="literal">Insert()</code><span class="strong"><strong> </strong></span>operation, which may not be the best choice for concurrent requests. In such a scenario, it is sometimes better to use <code class="literal">InsertOrReplace()</code><span class="strong"><strong> </strong></span>or <code class="literal">InsertOrMerge()</code>.</p></div><p>The last thing to do is to query a table. To do so in .NET, you will need something like this:</p><pre class="programlisting">var query = new TableQuery();
var result = table.ExecuteQuery(query);

foreach (var entity in result)
{
  Console.WriteLine($"{entity.PartitionKey}|{entity.RowKey}|{entity.Timestamp}|{entity["Created"].DateTimeOffsetValue}|{entity["CustomerId"].StringValue}");
}</pre><p>We just executed a basic query, which will return all rows from a table. While it works now, it is not the best idea to query all data within a table using such a query—in most cases, you will use something like the following:</p><pre class="programlisting">var query =
  new TableQuery().Where(
    TableQuery.GenerateFilterCondition("PartitionKey", QueryComparisons.Equal, "orders"));</pre><p>The preceding query will return all rows in a table that have an <code class="literal">orders</code> partition key. Such queries can be extended as you wish by generating further filter conditions.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip143"></a>Note</h3><p>Remember that to achieve the best performance, your queries should include both <code class="literal">PartitionKey</code> and <code class="literal">RowKey</code>. Using <code class="literal">PartitionKey</code> only leads to worse results, but is still acceptable. Using only<code class="literal">RowKey</code>will result in reading the whole partition anyway. Not using those columns will result in reading the whole table.</p></div><p>You can also check what is stored in a table using Azure <span>Storage</span><a id="id325200171" class="indexterm"></a> Explorer:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/d6e0d185-9de9-47b2-8139-a1f42a55ae18.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec112"></a>Table API in Azure Cosmos DB</h3></div></div></div><p>It is possible to leverage the premium offering for Table <span>Storage</span><a id="id325200194" class="indexterm"></a> using Azure Cosmos DB. Using that option has the following advantages:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Automatic and manual failovers.</li><li style="list-style-type: disc">Secondary indexes (the ability to index against all properties inside a row).</li><li style="list-style-type: disc">Independent scaling across multiple regions.</li><li style="list-style-type: disc">Different consistency levels.</li><li style="list-style-type: disc">Dedicated throughput per table.</li></ul></div><p>While failover can be achieved using Table Storage only, the rest of the presented features are available only for Azure Cosmos DB, and can be a great solution when you like the simplicity of this service and still want to challenge it against more complicated scenarios.</p></div></div>