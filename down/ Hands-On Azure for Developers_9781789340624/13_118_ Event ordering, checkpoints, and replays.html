<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch13lvl1sec114"></a>Event ordering, checkpoints, and replays</h2></div></div><hr /></div><p>In the previous sections, we covered <span>some</span><a id="id325310692" class="indexterm"></a> basic topics of Azure Stream Analytics: how to <span>configure</span><a id="id325310676" class="indexterm"></a> inputs and outputs, querying data, and using the service. In the last part of this chapter, I will show you its more advanced features such as event ordering, checkpoints, and replays, which ensure that events are processed exactly in a way you would expect. These topics are in fact common subjects in many different messaging solutions, so you will be able to use knowledge from this chapter in your other projects.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl2sec135"></a>Event ordering</h3></div></div></div><p>There are two <span>concepts</span><a id="id325143141" class="indexterm"></a> of events when it comes to their ordering:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Application (or event) time</li><li style="list-style-type: disc">Arrival time</li></ul></div><p>There is a clear distinction between them:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Application time</strong></span>: This is a timestamp when an event was generated on the client (or application) side. It tells you exactly when it occurred.</li><li style="list-style-type: disc"><span class="strong"><strong>Arrival time</strong></span>: This is a system timestamp, which is <span>not</span><a id="id325143126" class="indexterm"></a> present in the original payload. It tells you when an event was received by a service and picked up for processing.</li></ul></div><p>Depending on the input type, arrival time and application time will be different properties (<code class="literal">EventEnqueuedUtcTime </code>or <code class="literal">EnqueuedTime </code>for arrival time, whereas application time, in general, will be a generic property). What you have to remember is, depending on the selected scenario, you can process events as they come but out of order, or in order but delayed. This can be easily described using the following event sequence:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><span class="strong"><strong>Arrival</strong></span>: <code class="literal">2018-09-02T12:17:49</code> <span class="strong"><strong>Application</strong></span>: <code class="literal">2018-09-02T12:17:48</code></li><li><span class="strong"><strong>Arrival</strong></span>: <code class="literal">2018-09-02T12:17:50</code> <span class="strong"><strong>Application</strong></span>:<code class="literal"> 2018-09-02T12:17:44</code></li><li><span class="strong"><strong>Arrival</strong></span>: <code class="literal">2018-09-02T12:17:51</code> <span class="strong"><strong>Application</strong></span>:<span class="strong"><strong> </strong></span><code class="literal">2018-09-02T12:17:46</code></li></ol></div><p>If you process events as they come into the stream, they will be processed <span class="strong"><strong>out of order</strong></span>—in fact, they occurred in a different order, so there is a possibility that some data will be outdated. The other option is to sort events by application time; in such a scenario, the process will be delayed, but the order will be preserved.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip163"></a>Note</h3><p>Whether you need to or not, processing events in order depends on the data schema and characteristics of the processed events. Processing them in order is more time-consuming, but sometimes you just cannot do it the other way.</p></div><p>Azure Stream Analytics has a feature named <strong class="userinput"><code>Event ordering</code></strong>, which allows you to make a decision about what to do with events, which are either out of order or outdated:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/03367121-93b3-40ce-99d9-6eb45f337750.png" /></div><p>There are two options available:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><strong class="userinput"><code>Events that arrive late</code></strong>: This one allows you to process outdated events (for which the application time does not match the one processed as the last one) within a defined time window.</li><li style="list-style-type: disc"><strong class="userinput"><code>Out of order events</code></strong>: It is possible that Azure Stream Analytics consider some of your events to be  out of order (this situation could happen, for instance, if your senders' clocks are skewed). Here you can set a time window, during which this situation is acceptable).</li></ul></div><p>Additionally, you can define an action, which will be performed if an event either arrived late or was out of order—for <strong class="userinput"><code>Drop</code></strong>, it will simply be removed, and if you select <strong class="userinput"><code>Adjust</code></strong>, processing will be suspended for some time when such situations occur.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl2sec136"></a>Checkpoints and replays</h3></div></div></div><p>In fact, Azure Stream Analytics is a stateful service, which is able to <span>track</span><a id="id325115417" class="indexterm"></a> the event-processing progress. This <span>makes</span><a id="id325115424" class="indexterm"></a> it suitable for the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Job recovery</li><li style="list-style-type: disc">Stateful query logic</li><li style="list-style-type: disc">Different job start modes (now, custom, and when last stopped)</li></ul></div><p>Of course, there is a difference between what is possible after the checkpoint and when a replay is necessary. There are situations when the data stored within a checkpoint is not enough, and the whole replay is required; however, this may differ depending on your query. In fact, it depends on the query parallelization factor and can be described using the following formula:</p><p><span class="emphasis"><em>[The input event rate] x [The gap length] / [Number of processing partitions]</em></span></p><p>The more processors you have, the faster you can recover when something goes wrong. A good rule of thumb is to introduce more SUs in case your job fails and you have to close the gap quickly.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip164"></a>Note</h3><p>The important thing to consider when replaying data is the use of window functions in your queries (tumbling, hopping, sliding, or session)—they allow you to process data in different kinds of windows, but complicate the replay mechanism.</p></div></div></div>