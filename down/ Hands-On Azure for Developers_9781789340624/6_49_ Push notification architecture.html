<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec52"></a>Push notification architecture</h2></div></div><hr /></div><p>Creating a whole system <span>that</span><a id="id325115403" class="indexterm"></a> relies on push notification is not a trivial task. Besides ensuring that you are not focusing on handling each PNS logic individually and providing reliable device registration and routing systems, you have to introduce a pipeline for passing messages from one part of your system to the end device. In this section, we will focus on incorporating Notification Hub into a few reference architectures, which will help you understand its role and the connections between different cloud services.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec46"></a>Direct connection</h3></div></div></div><p>The simplest architecture we <span>could</span><a id="id325115397" class="indexterm"></a> think of would be a direct connection between a <span>backend</span><a id="id324830082" class="indexterm"></a> and notification service:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/3df41ceb-4e39-418a-9653-feb3c5bd8a66.png" /></div><p>In such a scenario, each send notification request is handled by <strong class="userinput"><code>Notification Service</code></strong>, which communicate with different <strong class="userinput"><code>PNSes</code></strong>. Each PNS individually handles a request and sends a notification to a registered device. Device registration is handled by <strong class="userinput"><code>Notification Service</code></strong>—each device has to register in it to be able to receive a notification. Note that, even in that simple scenario, <strong class="userinput"><code>Notification Service</code></strong> (in our case—Notification Hub) takes responsibility for two important things:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Providing a common interface for different PNSes</li><li style="list-style-type: disc">Handling device registration and routing</li></ul></div><p>Devices never communicate directly with the PNS itself—they only receive push notifications as a result of sending a request to <strong class="userinput"><code>Notification Service</code></strong>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec47"></a>Queued communication</h3></div></div></div><p>Sometimes exposing <strong class="userinput"><code>Notification Service </code></strong>to the <span>backend</span><a id="id325321106" class="indexterm"></a> is not the way to go—it could become unresponsive, have some performance issues, or just be overloaded. In such a situation, it is <span>always</span><a id="id325321081" class="indexterm"></a> good to have something that can cache messages and store them until all issues are resolved. Let's modify the previous architecture with one more service:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/a75fe239-df5f-43b3-bcfe-e0389b08657d.png" /></div><p>By introducing a <strong class="userinput"><code>Queue</code></strong> with readers, you can absolve the backend from handling communication with <strong class="userinput"><code>Notification Service </code></strong>and move the responsibility for delivering a message to them. Now <strong class="userinput"><code>Backend</code></strong> does not have to know how to handle undelivered messages and will not be aware of a storage for storing them. This solution can be also scaled much more easily than the previous one, as you do not have to worry about losing a message—a queue should be able to cache them as long as needed.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip82"></a>Note</h3><p>Make sure that your caching mechanism makes sense in the business domain you are working with. Caching a notification request for a day, for example, and sending a notification after that time may not make any sense in scenarios such as geolocalization, a specific time, or a short-lived discount.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec48"></a>Triggered communication</h3></div></div></div><p>Sometimes, you might like to <span>send</span><a id="id325120036" class="indexterm"></a> a notification <span>based</span><a id="id325120044" class="indexterm"></a> on some specific set of parameters or raising an event. Let's assume you would like to send it whenever a photo is uploaded to storage:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/cd6dcbfb-cfe5-4099-a589-c4069e136dc4.png" /></div><p>In this asynchronous scenario, you have an <strong class="userinput"><code>Event Listener</code></strong>, which listens to an event publication and performs an action based on the passed metadata. It sends a request to a <strong class="userinput"><code>Notification Service</code></strong>, which communicates with <strong class="userinput"><code>PNS</code></strong> to send a notification with the appropriate content (probable information regarding an upload status). Once more, we see the advantages of having a service acting as a proxy to PNSes—the whole communication can be made asynchronous and each component has its own responsibility.</p></div></div>