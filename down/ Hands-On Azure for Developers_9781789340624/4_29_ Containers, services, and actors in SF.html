<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec34"></a>Containers, services, and actors in SF</h2></div></div><hr /></div><p>To start with SF, we will cover three main topics, which allow you to divide an application <span>logically</span><a id="id325117152" class="indexterm"></a> and physically:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Containers</strong></span>: Small, deployable components that are isolated <span>from</span><a id="id325120006" class="indexterm"></a> each other and enable you to virtualize the underlying operating system</li><li style="list-style-type: disc"><span class="strong"><strong>Reliable services</strong></span>: One of the <span>programming</span><a id="id325117192" class="indexterm"></a> models available in <span>SD</span><a id="id325117165" class="indexterm"></a> for writing and managing stateful and stateless services</li><li style="list-style-type: disc"><span class="strong"><strong>Reliable a</strong></span><span class="strong"><strong>ctors</strong></span>: Another <span>programming</span><a id="id325117146" class="indexterm"></a> model on top of Reliable services</li></ul></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec31"></a>Containers</h3></div></div></div><p>For now, SF supports two <span>types</span><a id="id324830066" class="indexterm"></a> of container:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Docker </strong></span>on Linux</li><li style="list-style-type: disc"><span class="strong"><strong>Windows Server </strong></span>containers on Windows Server 2016</li></ul></div><p>When working with containers in SF, you can use any programming <span>language</span><a id="id324830090" class="indexterm"></a> or framework (as you probably expected), but the most important thing related to such a model is the fact that you do not have to stick to built-in programming models (Reliable actors and Reliable services). What is more, this <span>approach</span><a id="id325115404" class="indexterm"></a> is very similar to running so-called <span class="strong"><strong>guest executables</strong></span>, where you deploy an existing executable to SF.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec24"></a>Creating a cluster</h4></div></div></div><p>Before we start with containers, we will need to create an SF cluster. To do so, go to <span>Azure</span><a id="id325115421" class="indexterm"></a> Portal and click <strong class="userinput"><code>+ Create a resource</code></strong>. Search for <code class="literal">Service Fabric Cluster</code> and click <strong class="userinput"><code>Create</code></strong>. You will see a familiar screen, where you have to fill multiple fields with your cluster configuration. In SF, the process of creation is divided into four different steps, which we will cover one by one.</p><p>On the very first screen, you will have to enter basic information regarding the cluster:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/67cf2f00-8c8b-4b06-af5f-69bcc86c07fb.png" /></div><p>There is one field that probably requires a little bit of clarification, namely, <strong class="userinput"><code>Operating system</code></strong>. As mentioned in the beginning of this chapter, SF supports both Windows and Linux containers, which you can select here. The choice affects both the pricing and available features, so you have to be sure which OS you're using.</p><p>Once you are satisfied with the setup, you can proceed to the next screen:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/c4c365f7-84e1-4c8f-8617-ffa5a7c5a21d.png" /></div><p>Now we begin with the actual cluster configuration. The first thing you have to do is select <strong class="userinput"><code>Node type count</code></strong>. To select the correct version, you have to understand what this actually means. This property defines the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Virtual machine (VM) sizes</li><li style="list-style-type: disc">The number of VMs</li><li style="list-style-type: disc">Properties of VMs</li></ul></div><p>So, to cut a long story short—if you need two different <span>types</span><a id="id325633914" class="indexterm"></a> of machine (because, for instance, you have a lightweight frontend and heavy backend), you will choose two different node types. </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip54"></a>Note</h3><p>Remember that you can always add or remove a node after cluster creation, but you will always need to have at least one.</p></div><p>On the <strong class="userinput"><code>Node type configuration</code></strong><span class="strong"><strong> </strong></span>blade, you will have to choose the size of virtual machines and their capacity and select a name for the node. You can also configure advanced options but, as we are just starting with SF, I would not recommend changing anything there.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note55"></a>Note</h3><p>Using fewer than five virtual machines initially designates a cluster as a test cluster. The reason why SF requires you to run five or more VMs is to make sure that your solution is more resilient to simultaneous failures. You still can use a test cluster to run production workloads, but it is not recommended.</p></div><p>Now click <strong class="userinput"><code>OK </code></strong>to proceed. The last but one screen allows you to configure the security features of your cluster:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/74ed98d5-d85b-46e5-a7e5-f978b94e0b08.png" /></div><p>You can choose either the <strong class="userinput"><code>Basic </code></strong>or <strong class="userinput"><code>Custom </code></strong>configuration type—the difference between them is that, when using <strong class="userinput"><code>Basic</code></strong>,<strong class="userinput"><code> </code></strong>a certificate will be created for you and, when choosing <strong class="userinput"><code>Custom</code></strong>,<strong class="userinput"><code> </code></strong>you can enter certificate information on your own. Additionally, SF will require you to select a key vault (or create a new one) to store a certificate. </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note56"></a>Note</h3><p>We will not cover Azure key vaults in this book. If you would like to know more about this service, please take a look at the documentation—<a class="ulink" href="https://docs.microsoft.com/en-us/azure/key-vault/" target="_blank">https://docs.microsoft.com/en-us/azure/key-vault/</a></p></div><p>When everything is set and ready, you can click <strong class="userinput"><code>OK, </code></strong>and you will see the final <span>screen</span><a id="id326429301" class="indexterm"></a> with a summary of the configuration of your cluster. Validate all of the information displayed there and, if you are ready to create the cluster, click on <strong class="userinput"><code>Create</code></strong>. When you go to the resource group you selected while creating the cluster, you should see a similar setup to mine:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/18683a96-677a-4819-805a-f35c1f5c8f5f.png" /></div><p>As you can see, it contains many different services already:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Virtual machine scale set</strong></span>: To make sure you can easily scale out, SF uses the VMs scale set to automate the whole process</li><li style="list-style-type: disc"><span class="strong"><strong>Service Fabric </strong></span><span class="strong"><strong>cluster</strong></span>: The actual SF service</li><li style="list-style-type: disc"><span class="strong"><strong>Load balancer</strong></span>: To distribute the load between your machines</li><li style="list-style-type: disc"><span class="strong"><strong>Public IP address</strong></span>: So your application is available publicly</li><li style="list-style-type: disc"><span class="strong"><strong>Storage account</strong></span>: For storing data</li><li style="list-style-type: disc"><span class="strong"><strong>Virtual network</strong></span>: To secure and ease communication between machines, SF utilizes Azure Virtual Network to couple machines in the VMs scale set</li></ul></div><p>Now that we have a cluster configured and running, we can proceed to deploy the Docker container.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec25"></a>Deploying a container</h4></div></div></div><p>To use Docker images in SF, we will need a registry in <span>Azure</span><a id="id325321623" class="indexterm"></a> Container Registry. You can go back to <a class="link" href="#" linkend="ch03">Chapter 3</a>, <span class="emphasis"><em>Deploying Web Applications as Containers</em></span>, where I described in detail how to work with ACR and Docker.</p><p>Now we will try to deploy a simple Python application—to start, we will need Dockerfile, of course:</p><pre class="programlisting">FROM python:2.7-slim
WORKDIR /app
ADD . /app
RUN pip install -r requirements.txt
EXPOSE 80
ENV NAME World
CMD ["python", "app.py"]</pre><p>Additionally, let's create a Python application, which will display simple text:</p><pre class="programlisting">from flask import Flask

app = Flask(__name__)

@app.route("/")
def hello():

    return 'This is my first Service Fabric app!'

if __name__ == "__main__":
    app.run(host='0.0.0.0', port=80)</pre><p>Now, run the <code class="literal">docker build</code> command:</p><pre class="programlisting">docker build -t handsonservicefabricapp .</pre><p>We will be able to test and run it locally by typing the following:</p><pre class="programlisting">docker run -d -p 4000:80 --name handsonsf handsonservicefabricapp</pre><p>As you can see, all is working correctly—we can proceed by pushing an image and deploying it:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/9c28798d-1892-4777-a929-765c8afa29c7.png" /></div><p>To push a container image, you will need of course a registry for it. If you want to use Azure Container Registry, please refer to the previous chapter for detailed instructions.</p><p>For now, you will need three Docker<span class="strong"><strong> </strong></span>commands:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">docker login</code>: To authenticate in ACR</li><li style="list-style-type: disc"><code class="literal">docker tag</code><span class="strong"><strong>:</strong></span> To create an alias of an image and put it in the correct namespace</li><li style="list-style-type: disc"><code class="literal">docker push</code>: To deploy an image to the registry</li></ul></div><p>The following is the full syntax:</p><pre class="programlisting">docker login handsonazureregistry.azurecr.io -u {USERNAME} -p {PASSWORD}
docker tag handsonservicefabricapp handsonazureregistry.azurecr.io/sf/handsonservicefabricapp
docker push handsonazureregistry.azurecr.io/sf/handsonservicefabricapp</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec26"></a>Packaging a service</h4></div></div></div><p>To package our service, we will use <span>Yeoman</span><a id="id325328890" class="indexterm"></a> with the SF Yeoman container generator. To do so, you have to install them—in your command line, execute the following two commands:</p><pre class="programlisting"><span class="strong"><strong>npm install -g yo</strong></span>
<span class="strong"><strong>npm install -g generator-azuresfcontainer</strong></span></pre><p>We will need one more thing—because the container image will be fetched from ACR, we have to configure its credentials in <code class="literal">ApplicationManifest.xml</code>.<span class="strong"><strong> </strong></span>While the username can be traditionally found on the <strong class="userinput"><code>Overview </code></strong>blade of Container Registry, to find a password you have to run these two commands:</p><pre class="programlisting"><span class="strong"><strong>az acr login --name {REGISTRY_NAME}</strong></span>
<span class="strong"><strong>az acr credential show -n {REGISTRY_NAME} --query passwords[0].value</strong></span></pre><p>Now, we will need to update the manifest generated by Yeoman so it uses our credentials:</p><pre class="programlisting">&lt;ServiceManifestImport&gt;
  &lt;ServiceManifestRef ServiceManifestName="HandsOnServicePkg" ServiceManifestVersion="1.0.0" /&gt;
  &lt;Policies&gt;
    &lt;ContainerHostPolicies CodePackageRef="Code"&gt;
      &lt;PortBinding ContainerPort="80" EndpointRef="HandsOnServiceEndpoint"/&gt;
      &lt;RepositoryCredentials AccountName="{LOGIN}" Password="{PASSWORD}" PasswordEncrypted="false"/&gt;
    &lt;/ContainerHostPolicies&gt;
  &lt;/Policies&gt;
&lt;/ServiceManifestImport&gt;</pre><p>Now, log in to your cluster using the following command:</p><pre class="programlisting"><span class="strong"><strong>sfctl cluster select --endpoint https://{ENDPOINT}:19000 --pem {CERTIFICATE}.pem --no-verify</strong></span></pre><p>Finally, just run the <code class="literal">install.ps1</code><span class="strong"><strong> </strong></span>file Yeoman generated and wait a moment—your application image should be deployed to the SF cluster in the cloud and fully working.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip57"></a>Note</h3><p>To get a certificate, you can download it from the <strong class="userinput"><code>Certificates </code></strong>blade in key vault.</p></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec32"></a>Reliable services</h3></div></div></div><p>In this section, we will try to create both stateless and <span>stateful</span><a id="id325350716" class="indexterm"></a> services using SF. This time, we will use Visual Studio to create a C# application and deploy it to our cluster. You can also start with Reliable services<span class="strong"><strong> </strong></span>on Linux, but this will not be covered in this book. Refer to the <span class="emphasis"><em>Further reading</em></span><span class="strong"><strong> </strong></span>section for links to the appropriate documentation. </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec27"></a>Creating a SF application</h4></div></div></div><p>When you open a Visual Studio instance, go to <strong class="userinput"><code>File</code></strong> | <strong class="userinput"><code>New Project</code></strong>. In the new <span>window</span><a id="id325351159" class="indexterm"></a> search for <strong class="userinput"><code>Visual C#</code></strong> | <strong class="userinput"><code>Cloud </code></strong>templates; you should be able to find the <strong class="userinput"><code>Service Fabric Application </code></strong>option:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/9e806694-80fe-4f98-9a05-291ca313d971.png" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note58"></a>Note</h3><p>If you cannot find this option, make sure you have installed the SF SDK.</p></div><p>On the next screen, you will see many different options, most of which we will discuss later. For now, select <strong class="userinput"><code>Stateless Service</code></strong><span class="strong"><strong> </strong></span>and click <strong class="userinput"><code>OK</code></strong>:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/2c566569-9b35-409f-afde-6131e82cefa2.png" /></div><p>After a moment you should be able to see that a stateless service template has been built with SF. You can now press <span class="emphasis"><em>F5</em></span><span class="strong"><strong> </strong></span>to see how it works with all the default values:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/823cd48d-a61d-4a63-94b5-a1f845b00df4.png" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip59"></a>Note</h3><p>If you have trouble starting your local SF instance, make sure you have started Visual Studio as an administrator.</p></div><p>As you can see, each second a message—<code class="literal">Working-{N}</code>—is published. Take a look at the <code class="literal">RunAsync()</code><span class="strong"><strong> </strong></span>method:</p><pre class="programlisting">protected override async Task RunAsync(CancellationToken cancellationToken)
{
  long iterations = 0;

  while (true)
  {
    cancellationToken.ThrowIfCancellationRequested();

    ServiceEventSource.Current.ServiceMessage(this.Context, "Working-{0}", ++iterations);

    await Task.Delay(TimeSpan.FromSeconds(1), cancellationToken);
  }
}</pre><p>You will see that it is the source of those messages. In fact, it is the starting point of your service, which is called when it starts. It also accepts one parameter, <code class="literal">cancellationToken</code>, which is here to inform you about any of the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">There was a fatal error in your code and the service is currently in the invalid state</li><li style="list-style-type: disc">There was a hardware outage in a cluster</li><li style="list-style-type: disc">There is an ongoing upgrade</li><li style="list-style-type: disc">The current instance of service is no longer required</li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip60"></a>Note</h3><p><span>Remember to honor that</span> <code class="literal">RunAsync()</code><span class="strong"><strong> </strong></span>should return a task. The system will wait until the service finishes executing, so always try to do it as quickly as possible if you discover that cancellation was requested.</p></div><p>Let's now try to add also a stateful service—to do so, add a new <strong class="userinput"><code>Service Fabric <span>Application</span><a id="id325351493" class="indexterm"></a></code></strong><span class="strong"><strong> </strong></span>project to the solution, but this time select <strong class="userinput"><code>Stateful Service</code></strong>:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/bafb61d5-0796-44fa-9f72-f703791c7aaa.png" /></div><p>If you compare the stateless <code class="literal">RunAsync()</code><span class="strong"><strong> </strong></span>with the stateful one, you will see many differences:</p><pre class="programlisting">protected override async Task RunAsync(CancellationToken cancellationToken)
{
  var myDictionary = await this.StateManager.GetOrAddAsync&lt;IReliableDictionary&lt;string, long&gt;&gt;("myDictionary");

  while (true)
  {
    cancellationToken.ThrowIfCancellationRequested();

    using (var tx = this.StateManager.CreateTransaction())
    {
      var result = await myDictionary.TryGetValueAsync(tx, "Counter");

      ServiceEventSource.Current.ServiceMessage(this.Context, "Current Counter Value: {0}",
        result.HasValue ? result.Value.ToString() : "Value does not exist.");

      await myDictionary.AddOrUpdateAsync(tx, "Counter", 0, (key, value) =&gt; ++value);

      // If an exception is thrown before calling CommitAsync, the transaction aborts, all changes are</pre><pre class="programlisting">      // discarded, and nothing is saved to the secondary replicas.
      await tx.CommitAsync();
    }

    await Task.Delay(TimeSpan.FromSeconds(1), cancellationToken);
  }
}</pre><p>The most important one is a direct reference to state—in a stateful service, we have the state manager, which enables you to query state and execute actions within transactions. Here, in the previous example, we fetch a dictionary of the <code class="literal">IReliableDictionary&lt;&gt;</code> type from it—it is a reliable collection that stores data and replicates it to other machines. In fact, it is the same dictionary as, for example, <code class="literal">IDictionary&lt;&gt;</code>, but this time operations on a collection are asynchronous because data has to be persisted on disk.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip61"></a>Note</h3><p>Remember that everything you store in the state manager has to be serializable. </p></div><p>When you start your application, you will see that both services are running at the same time:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/8f033530-e818-4989-96d8-6aaf6f249210.png" /></div><p>Now we would like to publish our simple application to Azure to see whether it really works.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec28"></a>Deploying an application to the cloud</h4></div></div></div><p>If you take a look, you will see that our <span>solution</span><a id="id325352013" class="indexterm"></a> contains now three projects:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Stateless service</li><li style="list-style-type: disc">Stateful service</li><li style="list-style-type: disc">SF project</li></ul></div><p>Now right-click on the SF project and click the <strong class="userinput"><code>Publish...</code></strong><span class="strong"><strong> </strong></span>option:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/7d45e090-7253-45e1-ac77-e775097455a0.png" /></div><p>On the new screen, you can configure things such as <strong class="userinput"><code>Target profile</code></strong><span class="strong"><strong> </strong></span>or <strong class="userinput"><code>Application Parameters File</code></strong>, but the most interesting one is <strong class="userinput"><code>Connection Endpoint</code></strong>, which is empty now. In fact, you cannot proceed without selecting one option, so let's open the drop-down menu and see our options. Among the available options, you will have the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><strong class="userinput"><code>Local cluster</code></strong></li><li style="list-style-type: disc"><strong class="userinput"><code>Create New Cluster</code></strong></li><li style="list-style-type: disc"><strong class="userinput"><code>Use Trial Cluster</code></strong></li><li style="list-style-type: disc"><strong class="userinput"><code>Refresh</code></strong></li></ul></div><p>While the local/new cluster option is self-explanatory, you might wonder what the <strong class="userinput"><code>Trial</code></strong> option is. When you select it, you will be given an option to sign-in to so-called <span class="strong"><strong>party clusters</strong></span>. These are <span>free-</span><a id="id325370214" class="indexterm"></a>of-charge SF clusters, which you can use to play with this service a little bit and learn how it works. You do not need a subscription, but after an hour the cluster will be taken down. Because we are learning about services in Azure in this book, I will not use that option, but feel free to utilize it later if you decide you want to know much more about SF than this short chapter was able to provide.</p><p>When you select the <strong class="userinput"><code>Create New Cluster</code></strong><span class="strong"><strong> </strong></span>option, a new screen will appear with the whole SF cluster configuration. It is very similar to the one you can see in the portal—it has the same sections, such as <strong class="userinput"><code>Cluster</code></strong>, <strong class="userinput"><code>Certificate</code></strong>, and <strong class="userinput"><code>VM Detail</code></strong>. </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note62"></a>Note</h3><p>Creating an SF cluster from Visual Studio has one downside—you do not know what the recommended values are and have no direct reference to the documentation. </p></div><p>The following shows my configuration from the first tab:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/a5868aba-4d35-4e3c-a218-b601fb11c25c.png" /></div><p>As you can see, I set the <strong class="userinput"><code>Number of nodes</code></strong> to <code class="literal">1</code>—this is because I am not planning to deploy a production workload and do not need two different characteristics of virtual machines as both my services are more or less the same. When you click <strong class="userinput"><code>Next</code></strong>, you will see the second tab, where you will specify a certificate password. A certificate will be automatically created and imported if you leave the <strong class="userinput"><code>Import certificate</code></strong><span class="strong"><strong> </strong></span>option checked:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/556b4346-5697-4820-bb4e-d2af36718f6d.png" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note63"></a>Note</h3><p>Certificates in SF are a way to secure both node-to-node and client-to-node communication. These are X.509 certificates and, what is more, it is important to keep at least one valid—failing to do so can even make the cluster stop functioning.</p></div><p>The next tab is <strong class="userinput"><code>VM Detail</code></strong>, where you can specify details of machines <span>running</span><a id="id325370534" class="indexterm"></a> your cluster. After providing a <strong class="userinput"><code>User name</code></strong> and <strong class="userinput"><code>Password</code></strong>, you have to choose which operating system will be used to run SF and the size of each VM. After entering all the required information, you can click on <strong class="userinput"><code>Create</code></strong>:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/03be80d0-5223-4f14-9918-9bc3ddf03e33.png" /></div><p>Deploying an SF cluster can take a while so be patient. Once it is finished, you can take a look at it in Azure Portal to see that all parts of the whole ecosystem are deployed. However, when you enter the SF cluster in Azure, you will see that it has both <code class="literal">0</code> applications and <code class="literal">0</code> nodes attached. This is because we just created it without deploying anything. This is why we have to go back to Visual Studio and click <strong class="userinput"><code>Publish </code></strong>once more, this time selecting a cluster we just created:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/475b2277-869e-4212-b63d-105d0c842d20.png" /></div><p> </p><p>Now, let's go to Azure and explore our application. On the <strong class="userinput"><code>Overview </code></strong>blade of our SF instance, there is the <strong class="userinput"><code>Explorer </code></strong>button:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/74e19ceb-3cd7-419e-87f7-e88a954de2dd.png" /></div><p>When you click on it, new windows will open in your browser and you will be asked to select a certificate, which will be used to secure a connection. Remember to select the one you created and <span>exported</span><a id="id325390164" class="indexterm"></a> during SF cluster creation. After accepting it, you should be able to see <strong class="userinput"><code>Service Fabric Explorer</code></strong>:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/ce4f7b77-2bbb-4f51-9f59-96bf2374f803.png" /></div><p>Congratulations—you have just created your very first microservice architecture using SF!</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec33"></a>Reliable actors</h3></div></div></div><p>In the previous section, we created an application that is <span>made</span><a id="id325390192" class="indexterm"></a> up of two services—a stateful and stateless one. In SF, there are many different frameworks to build your system—another one is Reliable actors. It is designed for creating a platform of distributed services that can work concurrently and independently—because each actor is isolated, an issue with one instance does not affect others working at the same moment. You may wonder when to choose <strong class="userinput"><code>Reliable services</code></strong> and when the best option is <strong class="userinput"><code>Reliable Actors</code></strong>? The rule of thumb <span>could</span><a id="id325391709" class="indexterm"></a> be defined as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">If you require to divide your work among multiple workers (such as hundreds or thousands), choose <strong class="userinput"><code>Reliable Actors</code></strong></li><li style="list-style-type: disc">If you want to isolate your work and expect a single-threaded environment for simplicity, choose <strong class="userinput"><code><strong class="userinput"><code>Reliable Actors</code></strong></code></strong></li><li style="list-style-type: disc">If your business domain expects work to be performed in the transaction, choose <strong class="userinput"><code>Reliable Services</code></strong></li><li style="list-style-type: disc">If your service has to be reliable and highly available, choose <strong class="userinput"><code>Reliable Services</code></strong></li></ul></div><p>Of course, the aforementioned reasons do not cover all possible scenarios, but you should be able to understand the difference by now. In general, you cannot expect that actors will be very durable as the idea is to spawn new ones and forward the workload to them instead of ensuring that they can work indefinitely.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec29"></a>Creating a project with actors</h4></div></div></div><p>We will start our journey with Reliable actors by creating a <span>brand</span><a id="id325391748" class="indexterm"></a> new project in Visual Studio—for this, click on <strong class="userinput"><code>File</code></strong> | <strong class="userinput"><code>New project</code></strong><span class="strong"><strong> </strong></span>and once more select an SF template. On the <strong class="userinput"><code>New Service Fabric Service</code></strong><span class="strong"><strong> </strong></span>screen, select the <strong class="userinput"><code>Actor Service</code></strong><span class="strong"><strong> </strong></span>template and click <strong class="userinput"><code>OK</code></strong>:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/85714776-a7c0-4517-9da4-20a27f6c4165.png" /></div><p> </p><p>After your project is initialized, you will see that it is a bit different from the one for Reliable services—what is most important is that it now contains the <code class="literal">.Interfaces</code><span class="strong"><strong> </strong></span>project, which for now contains only one file with the following content:</p><pre class="programlisting">[assembly: FabricTransportActorRemotingProvider(RemotingListener = RemotingListener.V2Listener, RemotingClient = RemotingClient.V2Client)]
namespace ReliableActor.Interfaces
{
    /// &lt;summary&gt;
    /// This interface defines the methods exposed by an actor.
    /// Clients use this interface to interact with the actor that implements it.
    /// &lt;/summary&gt;
    public interface IReliableActor : IActor
    {
        /// &lt;summary&gt;
        /// TODO: Replace with your own actor method.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        Task&lt;int&gt; GetCountAsync(CancellationToken cancellationToken);

        /// &lt;summary&gt;
        /// TODO: Replace with your own actor method.
        /// &lt;/summary&gt;
        /// &lt;param name="count"&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        Task SetCountAsync(int count, CancellationToken cancellationToken);
    }
}</pre><p>It will act as our communication point between the actor and its clients. You may think of it as a contracts aggregator. Now, check the main actor project (in my case it is <code class="literal">ReliableActor</code>)—you will find there the current implementation of the previous interface. The following is the current code:</p><pre class="programlisting">namespace ReliableActor
{
    [StatePersistence(StatePersistence.Persisted)]
    internal class ReliableActor : Actor, IReliableActor
    {
        public ReliableActor(ActorService actorService, ActorId actorId) 
            : base(actorService, actorId)
        {
        }

        protected override Task OnActivateAsync()
        {
            ActorEventSource.Current.ActorMessage(this, "Actor activated.");
            return this.StateManager.TryAddStateAsync("count", 0);
        }

        Task&lt;int&gt; IReliableActor.GetCountAsync(CancellationToken cancellationToken)
        {
            return this.StateManager.GetStateAsync&lt;int&gt;("count", cancellationToken);
        }

        Task IReliableActor.SetCountAsync(int count, CancellationToken cancellationToken)
        {
            return this.StateManager.AddOrUpdateStateAsync("count", count, (key, value) =&gt; count &gt; value ? count : value, cancellationToken);
        }
    }
}</pre><p>Each actor implementation is decorated with the <code class="literal">[StatePersistence]</code><span class="strong"><strong> </strong></span>attribute. It has three different options:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><strong class="userinput"><code>Persisted</code></strong>: Here the state is persisted to disk and replicated to replicas (three or more). It is the most durable option and prevents you from losing it even during a complete cluster failure.</li><li style="list-style-type: disc"><strong class="userinput"><code>Volatile</code></strong>: Instead of persisting a state to disk, it is only replicated and held in memory on three or more replicas. This is the less durable option, similar to holding your data only in RAM memory, which will be lost once power is lost.</li><li style="list-style-type: disc"><strong class="userinput"><code>None</code></strong>: If you do not need to persist in your state, you <span>can</span><a id="id325395907" class="indexterm"></a> use this option.</li></ul></div><p>There is no best option here—it all depends on the requirements of your actors. Please note one more thing—an actor itself is not limited to some kind of "hard" contract; you define the code all by yourself and SF will do its best to replicate it, persist state (if needed), and scale out to meet your demands. Currently, we have only a worker—we also need a client to test our service.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec30"></a>Creating an actor's client</h4></div></div></div><p>To create a client, we will use the most traditional <strong class="userinput"><code>Console Application</code></strong>.<span class="strong"><strong> </strong></span>Once more, click on <strong class="userinput"><code>File</code></strong> | <strong class="userinput"><code>New project </code></strong>and search for it or just right-click on the solution and click on <strong class="userinput"><code>Add</code></strong> | <strong class="userinput"><code>New project</code></strong>. You will have to add two more things before we write some code:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Add a reference to our <code class="literal">.Interfaces</code><span class="strong"><strong> </strong></span>project as we have to know which methods we would like to call</li><li style="list-style-type: disc">Install the <code class="literal">Microsoft.ServiceFabric.Actors</code> package</li></ul></div><p>We will write a simple application that calls our actor, fetches the current count value, and updates it. The following shows my example code:</p><pre class="programlisting">using System;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.ServiceFabric.Actors;
using Microsoft.ServiceFabric.Actors.Client;
using ReliableActor.Interfaces;

namespace ReliableActor.Client
{
    class Program
    {
        static void Main()
        {
            MainAsync().GetAwaiter().GetResult();
        }

        static async Task MainAsync()
        {
            IReliableActor actor = ActorProxy.Create&lt;IReliableActor&gt;(ActorId.CreateRandom(), new Uri("fabric:/ReliableActors/ReliableActorService"));
            while (true)
            {
                var count = await actor.GetCountAsync(CancellationToken.None);
                Console.Write($"Current count is: {count}\r\n");
                await actor.SetCountAsync(++count, CancellationToken.None);

                Thread.Sleep(1000);
            }
        }
    }
}</pre><p>As you can see, I am doing three things:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">I am getting a reference to my actor service by using the <code class="literal">fabric</code> protocol and a specific interface I created</li><li style="list-style-type: disc">To obtain the count value, I am calling the <code class="literal">GetCountAsync()</code><span class="strong"><strong> </strong></span>method on my reference</li><li style="list-style-type: disc">I am updating state by calling <code class="literal">SetCountAsync()</code></li></ul></div><p>The following shows the result of running both actor and client:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/b9306571-1778-40fc-973e-33ec178219d9.png" /></div><p>Great—all works as expected. You may wonder how actor instances are distributed in the SF cluster and how we achieve the distribution of hundreds of instances of them. Well, it is all handled by SF runtime by partitioning instances and attaching them to different nodes on a cluster. Thanks to that, you <span>can</span><a id="id325404403" class="indexterm"></a> expect that the workload will be balanced—what is more, you can reference an actor by its ID (as opposed to the presented method, <code class="literal">ActorId.CreateRandom()</code>), but it is not always recommended as you have to ensure you are not overloading one actor.</p></div></div></div>