<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec79"></a>Partitioning, throughput, and consistency</h2></div></div><hr /></div><p>Now we have learned <span>something</span><a id="id325128376" class="indexterm"></a> about Azure <span>Cosmos</span><a id="id325128365" class="indexterm"></a> DB—how it works and its most common features—we can focus a little bit on three really important topics in this service; partitioning, throughput, and consistency. Those factors are crucial when selecting a database engine to power your application. They directly tell you how it will be performing, how many requests it will be able to handle, and what guarantees apply when it comes to your data integrity. </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec81"></a>Partitions in Azure Cosmos DB</h3></div></div></div><p>Partitioning is directly connected with scaling in <span>Azure</span><a id="id325128353" class="indexterm"></a> Cosmos DB as it allows for load-balancing incoming requests. In fact, there are two different types of partition in <span>this</span><a id="id325128342" class="indexterm"></a> service:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Physical</strong></span>: These are a combination of fixed storage and a variable amount of computing resources. This type of partition is fully managed by Cosmos DB—you cannot directly affect how your data is physically partitioned and how a service handles those partitions. In fact, you are also unaware of how many of those partitions are currently in use. Therefore, you should not design your containers against that specific concept.
</li><li style="list-style-type: disc"><span class="strong"><strong>Logical</strong></span>: This kind of <span>partition</span><a id="id325128284" class="indexterm"></a> holds data that has the same partition key. Because you are able to define that key (by specifying it in each entity), you are able to control how your data is partitioned. </li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note121"></a>Note</h3><p>Remember that a logical partition has a limit of 10 GB. Additionally, all data for a logical partition has to be stored within one physical partition.</p></div><p>Now you may wonder how partitioning works in Azure Cosmos DB. This can be described in a few steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Each time a new container is provisioned (and you are providing a number of RUs), Cosmos DB has to provision physical partitions, which will be able to serve the number of requests specified in the number of RUs. </li><li>It may turn out that the specified amount of RUs exceeds the maximum number of requests per second served by a partition. In that case, Cosmos DB will provision the number of partitions it needs to satisfy your requirements.</li><li>The next thing to do is to allocate space for partition key hashes. All provisioned partitions have to have the same space allocated (so it is distributed evenly). </li><li>Now, if after some time any partition reaches its storage limit, it is split into two new partitions, and data is distributed evenly between them.</li></ol></div><p>Of course, the partition key used for partitioning differs for each database model—for a table it is partition key, for SQL it will be a custom path. In general, this operation is slightly different depending on the database type, yet the overall concept remains the same. </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note122"></a>Note</h3><p>Remember that if your container has only one partition key for all the entities in it, then Cosmos DB will not be able to split a partition. That means that you could hit the maximum of 10 GB per partition and not be able to add any more data.</p></div><p>The best value for the partition key depends solely on your application data specification. In general, you have to choose a value that is quite differential (so partitioning can actually happen). On the other hand, you should not create a unique partition key for each record (while it is possible, it will be quite expensive). There is no one solution to that problem—you always have to analyze each scenario and select what suits you the most. </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip123"></a>Note</h3><p>In most cases, it is worth including a partition key while filtering data, as it allows for high concurrency.</p></div><p> </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec82"></a>Throughput in Azure Cosmos DB</h3></div></div></div><p>In the <span class="emphasis"><em>Further reading</em></span><span class="strong"><strong> </strong></span>section, you will find a capacity calculator—a tool that enables you to plan your Cosmos DB instance and estimate the required RUs. As mentoned previously, in this particular service you are not defining the number of instances or clusters. Instead, while creating a container, you have to state your expected throughput for that specific collection (or a set of collections). Thanks to an <span class="strong"><strong>Service Level Agreement</strong></span> (<span class="strong"><strong>SLA</strong></span>) for <span>Azure</span><a id="id325115399" class="indexterm"></a> Cosmos DB, that value will be guaranteed for you. Additionally, even if you replicate a database to another region, you can expect that problems in one region will not affect others. </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip124"></a>Note</h3><p>There is one important definition of 1 request unit—it is the processing capacity, that enables you to read a 1 KB entity using, for example, a simple GET request. The same is not true for operations such as inserting or deleting, as those require more computing power to be performed.</p></div><p>If you would like to know exactly how many RUs a specific operation consumes, you have to consult the <code class="literal">x-ms-request-charge</code> header in a response from a Cosmos DB instance. This will tell you the cost of this operation—of course, you have to remember that it may differ depending on the number of records returned. In the documentation you can find the following table:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Operation</p></th><th style="border-bottom: 0.5pt solid ; "><p>Request unit charge</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Create item</p></td><td style="border-bottom: 0.5pt solid ; "><p>~15 RU</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Read item</p></td><td style="border-bottom: 0.5pt solid ; "><p>~1 RU</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Query item by ID</p></td><td style=""><p>~2.5 RU</p></td></tr></tbody></table></div><p> </p><p>Those are values for executing an operation against an entity 1 KB in size. As you can see, the values are completely different depending on the operation type. You also can see, that it is crucial to carefully check all operations requirements—if you fail to do so, you may face an HTTP 429 response, which tells you that you have exceeded the reserved throughput limits. In such a scenario, you should honor the <code class="literal">x-ms-retry-after-ms</code> header response, which allows for an easy retry policy.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec83"></a>Consistency in Azure Cosmos DB</h3></div></div></div><p>Besides different models of a database, Azure Cosmos DB offers <span>also</span><a id="id325117148" class="indexterm"></a> a different level of consistency. You may wonder what consistency is and how it affects your data.</p><p> </p><p> </p><p>We can define it as follows:</p><p>Consistency is a parameter of a database system, which reflects the way a transaction affects data. It defines the rules that are applied when different constraints or/and triggers affect data written to a database. </p><p>So basically it tells you what are the guarantees that, if your data becomes affected by a set of operations, it will not be malformed and you will be able to rely on it. The following are the available consistency models in Cosmos DB:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><strong class="userinput"><code>STRONG</code></strong></li><li style="list-style-type: disc"><strong class="userinput"><code>BOUNDED STATELESS</code></strong></li><li style="list-style-type: disc"><strong class="userinput"><code>SESSION</code></strong></li><li style="list-style-type: disc"><strong class="userinput"><code>CONSISTENT PREFIX</code></strong></li><li style="list-style-type: disc"><strong class="userinput"><code>EVENTUAL</code></strong></li></ul></div><p>In the above list, each level below <strong class="userinput"><code>STRONG<span class="strong"><strong> </strong></span></code></strong>gives you less consistency. This is especially true for <strong class="userinput"><code>EVENTUAL</code></strong>, which could be familiar to you thanks to a topic known as eventual consistency. In general, you are setting the default consistency level for your account—then it is possible to override it per each request (of course, if you want to). If you want to know how exactly each consistency level works, please refer to the <span class="emphasis"><em>Further reading</em></span><span class="strong"><strong> </strong></span>section. To set a particular level in your Cosmos DB instance, click on the <strong class="userinput"><code>Default consistency</code></strong><span class="strong"><strong> </strong></span>blade:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/1b291ac2-bcc5-4eb7-af2c-433d6ce55fa5.png" /></div><p> </p><p>As you can see, it allows you to easily switch to another consistency level depending on your needs. What is more, it displays a nice animation, which describes how reads/writes in multiple regions will work for this particular level. The following screenshot shows the animation for eventual consistency:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/aea59e0e-437f-43d8-8b67-b9171ced133f.png" /></div><p>In this screenshot, each individual note represents an individual read or write in a particular region. Additionally, on this screen, you are able to set <strong class="userinput"><code>Maximum Lag (Time)</code></strong><span class="strong"><strong> </strong></span>when the <strong class="userinput"><code>BOUNDED STALENESS</code></strong><span class="strong"><strong> </strong></span>level is selected.</p></div></div>