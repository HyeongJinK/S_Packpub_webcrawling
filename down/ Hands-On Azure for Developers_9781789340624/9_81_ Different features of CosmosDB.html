<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec81"></a>Different features of CosmosDB</h2></div></div><hr /></div><p>Azure <span>Cosmos</span><a id="id325115447" class="indexterm"></a> DB has multiple different features that can be used to lower your bills, secure an instance, or integrate with other services. In this section, we will quickly take a look at most of them, so you will fully understand the basics of this service and will be able to progress on your own. </p><p> </p><p> </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec89"></a>Account level throughput</h3></div></div></div><p>Instead of defining throughput per each collection, sometimes you would like to set a fixed <span>value</span><a id="id325115413" class="indexterm"></a> for the whole account. This is a great addition if you have many different containers and instead of paying for each individually (as you remember—it was over $20 per month), you can go to <strong class="userinput"><code>Account level throughput</code></strong><span class="strong"><strong> </strong></span>and set a throughput for the whole account:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/64d29ac0-65e4-4375-bb2e-c0eb0ed90776.png" /></div><p>The only limitation of this feature is you can no tables currently in the account. If you enable it, all your requests to all tables will share the same amount of throughput (so you can pay less, but in the case of "greedy" collections you can run out of RUs). The downside of that functionality is that you will pay for the provisioned throughput, whether you have created collections or not.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note126"></a>Note</h3><p>Note that the aforementioned feature is available only for the Table API.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec90"></a>Database level throughput</h3></div></div></div><p>In Azure Cosmos DB it is also possible to <span>provision</span><a id="id324830059" class="indexterm"></a> throughput directly on the database. To do so, you need to select the <strong class="userinput"><code>Provision throughput</code></strong> checkbox during database creation:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/b3f377f3-7e95-4e8e-97cb-1543123d7e49.png" /></div><p>With that feature on, all provisioned RUs will be shared across all collection available for a database.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec91"></a>Firewall and virtual networks</h3></div></div></div><p>If you configured the virtual <span>network</span><a id="id325128295" class="indexterm"></a> feature during <span>Cosmos</span><a id="id325128337" class="indexterm"></a> DB creation, in this blade you will be able to configure it further. What is more, it is also possible to configure a firewall—so you can restrict access to a specific range of IPs or disallow connections from other Azure data centers. In general, you do not want to have a database that can be accessed by everyone, so if this feature is available, I strongly recommend you use it.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note127"></a>Note</h3><p>Note that currently firewalls and VNets are available only for the SQL API and Mongo API. Support for other APIs should be available soon.</p></div><p> </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec92"></a>Azure Functions</h3></div></div></div><p>You can easily integrate Azure Cosmos DB with <span>Azure</span><a id="id325128360" class="indexterm"></a> Functions by using the <strong class="userinput"><code>Add Azure Function</code></strong><span class="strong"><strong> </strong></span>blade:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/5a0e7ef0-e473-466e-ab65-52652ef31ce0.png" /></div><p>Creating a function from Cosmos DB will add the following code to your Function App:</p><pre class="programlisting">#r "Microsoft.Azure.Documents.Client"

using Microsoft.Azure.Documents;
using System.Collections.Generic;
using System;

public static async Task Run(IReadOnlyList&lt;Document&gt; input, TraceWriter log)
{
    log.Verbose("Document count " + input.Count);
    log.Verbose("First document Id " + input[0].Id);
}</pre><p>This is CSX code, which we did not cover—however, besides slight changes in syntax, it is pure C#. This function will listen to changes to a collection you selected during creation—it is up to you what it will do next. In general, it is a quick and easy way to integrate these two services. What is more, you can have more than just one Azure Function generated for your collection or table. Now if I add a document, I can see it triggers a function:</p><pre class="programlisting"><span>Pause</span><span>Clear</span><span><span><span>Copy logs</span></span></span><span>Expand
</span>2018-08-07T06:01:28  Welcome, you are now connected to log-streaming service.
2018-08-07T06:01:34.556 [Info] Function started (Id=5fb63ab3-e128-45ad-b7a8-4ccfdad38c82)
2018-08-07T06:01:34.573 [Verbose] Document count 1
2018-08-07T06:01:34.573 [Verbose] First document Id test_document
2018-08-07T06:01:34.591 [Info] Function completed (Success, Id=5fb63ab3-e128-45ad-b7a8-4ccfdad38c82, Duration=21ms)</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec93"></a>Stored procedures</h3></div></div></div><p><span>Azure</span><a id="id325143099" class="indexterm"></a> Cosmos DB allows for creating stored procedures that can be executed individually and can hold extra logic, which you do not want to share.</p><p>If you go to your collection in <strong class="userinput"><code>Data Explorer</code></strong>,<span class="strong"><strong> </strong></span>you will see the <strong class="userinput"><code>New Stored Procedure</code></strong><span class="strong"><strong> </strong></span>tab and the ability to create one:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/60772959-983d-4ef7-9b34-e655b0b4e2d4.png" /></div><p>Stored procedures are written in JavaScript—this allows you to easily access the document's schema (as they are all JSON). What is more, they are registered per collection. Here you can find an example of the easiest stored procedure:</p><pre class="programlisting">function sample(prefix) {
    var context = getContext();
    var response = context.getResponse();

    response.setBody("Hello, World");
}</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec94"></a>User-defined functions and triggers</h3></div></div></div><p>To extend the query language, you can write your own <span class="strong"><strong>user-defined function</strong></span> (<span class="strong"><strong>UDF</strong></span>) and in your queries. Note that you cannot use these in Stored Procedures. UDFs are <span>used</span><a id="id325214393" class="indexterm"></a> to extend the SQL query language in <span>Azure</span><a id="id325214400" class="indexterm"></a> Cosmos DB and can be only called from inside queries. Triggers, however, are divided into two categories:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Pre-triggers</li><li style="list-style-type: disc">Post-triggers</li></ul></div><p>Additionally, you can select an operation that this trigger refers to:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><strong class="userinput"><code>All</code></strong></li><li style="list-style-type: disc"><strong class="userinput"><code>Create</code></strong></li><li style="list-style-type: disc"><strong class="userinput"><code>Delete</code></strong></li><li style="list-style-type: disc"><strong class="userinput"><code>Replace</code></strong></li></ul></div><p> </p><p>Here you can find an example of a trigger that updates a timestamp in a document before it is created:</p><pre class="programlisting">var context = getContext();
var request = context.getRequest();
var documentToCreate = request.getBody();

if (!("timestamp" in documentToCreate)) {
  var ts = new Date();
  documentToCreate["my timestamp"] = ts.getTime();
}

request.setBody(documentToCreate);</pre><p>Triggers, of course, are also available from <strong class="userinput"><code>Data Explorer</code></strong>:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/5cd784b8-3104-4533-b065-6b48a91c35f8.png" /></div></div></div>