<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec20"></a>Creating WebJobs</h2></div></div><hr /></div><p>Working with WebJobs is much <span>simpler</span><a id="id325467664" class="indexterm"></a> than working with App Services, as this is a much easier service to configure and use. In fact, there are two ways of working with them:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Using Azure Portal and deploying a job manually</li><li style="list-style-type: disc">Using Visual Studio to develop and deploy it manually</li></ul></div><p>What is more, you can leverage the WebJobs SDK to prepare an application triggered by an external service. This will be covered at the end of this chapter, and will be an excellent introduction to Azure Functions, described later in this book.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec17"></a>Creating and deploying WebJobs in Azure Portal</h3></div></div></div><p>The easiest and quickest way to start working with <span>WebJobs</span><a id="id325535476" class="indexterm"></a> is to create a custom console application, perform an action, and then deploy it using Azure Portal. Thanks to this exercise, you will understand the <span>main</span><a id="id325535484" class="indexterm"></a> concepts of jobs hosted within App Services. </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec7"></a>Creating an application in Visual Studio</h4></div></div></div><p>When you open Visual Studio, go to <strong class="userinput"><code>File</code></strong> | <strong class="userinput"><code>New Project</code></strong>. In the <strong class="userinput"><code><span>New</span><a id="id325535517" class="indexterm"></a> Project</code></strong><span class="strong"><strong> </strong></span>window, select <strong class="userinput"><code>Windows Classic Desktop</code></strong><span class="strong"><strong> </strong></span>and then <strong class="userinput"><code>Console App (.NET Framework)</code></strong>. Give your application a name and click on <strong class="userinput"><code>OK</code></strong>:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/863b1f17-960e-40fa-96ab-9f1f8da19e44.png" /></div><p>After a moment, you will see an empty project, which we can modify. We will try to trigger our job in intervals (let's say one minute), so we need to add code, which will finish within the given time.</p><p> </p><p> </p><p>For the very beginning, let's just display the current date. In the <code class="literal">Main()</code><span class="strong"><strong> </strong></span>method of your application, add the following code:</p><pre class="programlisting">using System;

namespace MyFirstWebJob
{
    class Program
    {
        static void Main()
        {
            Console.WriteLine($"Current date and time is: {DateTime.Now:yyyy-MM-d dddd HH:mm:ss}");
        }
    }
}</pre><p>Now save and build your project—we will need the compiled version soon.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec8"></a>Deploying a WebJob in the Azure Portal</h4></div></div></div><p>Now, when we have a code of our WebJob, we can try to put in the cloud. To do so we need App Service, which will host our code and execute it. You can either use one of your current Web Apps or create a <span>new</span><a id="id325643036" class="indexterm"></a> one:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Go to your App Service and find the <strong class="userinput"><code>WebJobs </code></strong>blade. (If you do not see it, scroll down a little bit—it can be found on the left in the <strong class="userinput"><code>Settings </code></strong>section.):</li></ol></div><div class="mediaobject"><img src="/graphics/9781789340624/graphics/f9f5476d-a269-4f50-8fa5-19ce8b3f2441.png" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note31"></a>Note</h3><p>If you do not know how to create App Service or configure it, please take a look at <a class="link" href="#" linkend="ch01">Chapter 1</a>, <span class="emphasis"><em>Azure App Service</em></span>, where I describe the process of working with this Azure service in detail.</p></div><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Since you currently do not have any jobs, click on the <strong class="userinput"><code>+ Add</code></strong><span class="strong"><strong> </strong></span>button. You will see a new screen, which allows you to configure a new WebJob:</li></ol></div><div class="mediaobject"><img src="/graphics/9781789340624/graphics/9dfac3f8-e88c-45af-a2a4-cc59ac7293b0.png" /></div><p>Available fields differ a bit depending on the selected <strong class="userinput"><code>Type </code></strong>field value. If you have selected <strong class="userinput"><code>Triggered </code></strong>job, you will see the following fields:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><strong class="userinput"><code>Triggers</code></strong><span class="strong"><strong>:</strong></span> If you select <strong class="userinput"><code>Scheduled</code></strong>, one additional field (<strong class="userinput"><code>CRON Expression</code></strong>) will appear. The other option is <strong class="userinput"><code>Manual</code></strong>, which ensures that a WebJob can be triggered only manually.
</li><li style="list-style-type: disc"><strong class="userinput"><code>CRON Expression</code></strong>: A CRON valid expression, which <span>defines</span><a id="id326352854" class="indexterm"></a> an interval at which a job runs. </li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip32"></a>Note</h3><p>CRON expressions are a quite complicated topic themselves, and we will not focus on them in this book. If you have not heard about them yet, those two links should be useful for you to get started: <a class="ulink" href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-timer" target="_blank">https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-timer</a>.</p></div><p>Another option is to set the <strong class="userinput"><code>Triggered </code></strong>field to <strong class="userinput"><code>Continuous</code></strong>. In that scenario, only one extra field is displayed: <strong class="userinput"><code>Scale.</code></strong> Decide whether you want to always have a <strong class="userinput"><code>Single Instance</code></strong><span class="strong"><strong> </strong></span>of job or scale it across all instances of your App Service. This is helpful if you want, for instance, to implement a singleton pattern and never scale out a job. Note that you cannot change this option if you are using the <strong class="userinput"><code>Free </code></strong>or <strong class="userinput"><code>Shared </code></strong>tier as they do not support scaling.</p><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>For now, we will create a <strong class="userinput"><code>Triggered </code></strong>job to see how App Service executes it. Give it a name and attach an executable file of the console application you created in the previous section. Here, you can find my configuration:</li></ol></div><div class="mediaobject"><img src="/graphics/9781789340624/graphics/864561b1-c9fd-4dd6-85a7-746eed33c13f.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>I have decided to use the <code class="literal">0 */1 * * * *</code><span class="strong"><strong> </strong></span><strong class="userinput"><code>CRON Expression</code></strong> to run my job each minute. Once you are satisfied with your configuration, click <strong class="userinput"><code>OK</code></strong>. After a moment, you should see a new WebJob added to App Service and deployed:</li></ol></div><div class="mediaobject"><img src="/graphics/9781789340624/graphics/b5e733b7-e251-4f2e-b1b8-e5f66026a244.png" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip33"></a>Note</h3><p>You do not have to deploy a single file as your WebJob. If your application has more files (such as additional dependencies or static files), you can archive them in a ZIP package and publish. After deployment, they will be unzipped and fully functional.</p></div><p>Now when you click on a job, new options will be available in the menu above. We would like to see the output—for that, please click on <strong class="userinput"><code>Logs</code></strong>. On the <span>new</span><a id="id325210823" class="indexterm"></a> screen, you will see the list of jobs available in this particular App Service. Click on the one you have just added—a list of recent runs should be displayed, which you can analyze. You can click on any of the positions available—you will be able to see a full log of the running job:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/e977ea69-6e66-469c-af56-bfc97250318f.png" /></div><p>As you can see, a job was run and it displayed exactly what we have been expecting—the current date and time. Congratulations—you have just created and deployed your first WebJob!</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note34"></a>Note</h3><p>Remember that running continuous or triggered jobs require at least the <strong class="userinput"><code>Basic </code></strong>App Service Plan. If you use the <strong class="userinput"><code>Free </code></strong>or <strong class="userinput"><code>Shared </code></strong>tier, after some time, a WebJob will be cancelled and you will need to start it manually.</p></div><p>In the next section, you will learn how to deploy a WebJob directly from Visual Studio.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec18"></a>Deploying WebJobs from Visual Studio</h3></div></div></div><p>In the previous part of this chapter, you saw how to create a simple WebJob and publish it from Azure Portal. Sometimes you would prefer not to leave your IDE and use it for deployments too. Fortunately, Visual Studio is integrated with Azure and makes such actions a piece of cake. Before, we started to create a brand <span>new</span><a id="id325210936" class="indexterm"></a> <strong class="userinput"><code>Console Application</code></strong><span class="strong"><strong> </strong></span>as we did in the beginning—this will be our starting point. You can add any code you would like to—I will use the one from the previous exercises, which will display the current date and time. Once you are satisfied with the provided functionality, right-click on your project icon.</p><p>From the context menu, click on <strong class="userinput"><code>Publish as Azure WebJob...</code></strong>:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/797233fe-4cd4-4964-8df8-8917d8836f18.png" /></div><p>You will see a new screen, where you can select a name for a new WebJob and its <strong class="userinput"><code>Run mode</code></strong>. This time, I also decided on a continuous job, so I selected <strong class="userinput"><code>Run continuously</code></strong>. When you click <strong class="userinput"><code>OK</code></strong>, this wizard will install missing packages for your project and display the <strong class="userinput"><code>Publish </code></strong>screen:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/907dc5c9-cfbe-4c09-9dbc-f05e6c5ae04d.png" /></div><p>Here, you can create or import <strong class="userinput"><code>Publish profile</code></strong>, which is needed to deploy WebJob. We would like to publish our job to a specific location, and that is why we select <strong class="userinput"><code>Microsoft Azure App Service</code></strong>. On the next screen, you can select the appropriate App Service by filtering it using subscription and resource group fields. Select the one you are interested in and then click <strong class="userinput"><code>OK</code></strong>. Now you will be able to change different properties if you want and deploy configuration. I recommend leaving the default values for now and clicking on <strong class="userinput"><code>Publish</code></strong>. After several seconds, you should see a success message in the output window:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/dd6706f4-24f8-4839-b6a5-4d66a5db2f88.png" /></div><p>
 </p><p>We can now check whether our job is available in Azure. Go to the <strong class="userinput"><code>WebJobs </code></strong>blade in your App Service. You should be able to see your job among others (I used the same Web App as in the previous section, that is <span>why</span><a id="id325211465" class="indexterm"></a> I have two WebJobs available):</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/7331d969-aa48-4411-8ccb-c712c931e6f3.png" /></div><p>It seems that everything is all right. I am sure you see one flaw of such an approach—we can define the <strong class="userinput"><code>Run mode</code></strong><span class="strong"><strong> </strong></span>of our job only as <strong class="userinput"><code>Run on demand</code></strong><span class="strong"><strong> </strong></span>or <strong class="userinput"><code>Run continuously</code></strong>. What we are missing here is running it on a schedule. In the next section, I will address this issue as we will start using the WebJobs SDK to have better control over our application.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip35"></a>Note</h3><p>In fact, it is possible to modify a continuous job to work in intervals. If you take a look at your project, you will see that now it contains a file called <code class="literal">webjob-publish-settings.json</code>. Its schema and description can be found here—<a class="ulink" href="http://schemastore.org/schemas/json/webjob-publish-settings.json" target="_blank">http://schemastore.org/schemas/json/webjob-publish-settings.json</a>.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec19"></a>Working with the WebJobs SDK</h3></div></div></div><p>To simplify working with WebJobs in Azure and easily <span>access</span><a id="id325213294" class="indexterm"></a> their advanced features, you can use a framework called the WebJobs SDK. It is available out of the box in Visual Studio when an Azure workload is installed. To start, you can create a clean console application, or use the one used for the previous exercises—at this moment, it is up to you. You will need one more thing—the <code class="literal">Microsoft.Azure.WebJobs</code> package, which can be installed either using the command line or the NuGet package manager:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/6769834c-7b22-4195-a0ce-16a200fb7582.png" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note36"></a>Note</h3><p>Please note that it is possible to develop .NET Core WebJob using the packages version 3.X. However, since they are still in the beta state, I will not cover them in this book.</p></div><p>When everything is set and ready, we can proceed and try to actually create a new application. Writing jobs using the WebJobs SDK is a bit different than creating them like we did in the previous exercises, but it gives you some interesting benefits:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">You have an available set of triggers integrated with other Azure services such as queues</li><li style="list-style-type: disc">You have an integrated logging framework, which eases the process of monitoring a job</li><li style="list-style-type: disc">It is a great start to developing Azure Functions, which will be covered later in this book</li></ul></div><p>To get started you have to start a <code class="literal">JobHost</code> instance. It is a container for all of the jobs you will run within your application. (We can also call them <code class="literal">functions</code>, as described in the documentation.) The boilerplate code looks like this:</p><pre class="programlisting">using Microsoft.Azure.WebJobs;

namespace MyFirstWebJobWebJobsSDK
{
    class Program
    {
        static void Main()
        {
            var config = new JobHostConfiguration();
            var host = new JobHost(config);
            host.RunAndBlock();
        }
    }
}</pre><p>Those three lines are the actual host of your job application, which will handle its functionalities.</p><p> </p><p> </p><p>Try to compile and run—unfortunately, there is something missing, as you will see an exception thrown as follows:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/33ef81ac-5b0a-4e9c-8323-93984488658f.png" /></div><p>It tells us that we have a missing Azure Storage account connection string. Because we have not covered this topic yet, you will have to perform one more exercise before continuing. Go to <a class="link" href="#" linkend="ch11">Chapter 11</a>, <span class="emphasis"><em>Using Azure Storage - Tables, Queues, Files, and Blobs</em></span>,<span class="strong"><strong> </strong></span>and go through the very first section. It will guide you through the process of creating an Azure Storage account and tell where you can find the connection string to it. Once you have, we can proceed—add it to <code class="literal">App.config</code> as follows:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;configuration&gt;
    &lt;startup&gt; 
        &lt;supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.7" /&gt;
    &lt;/startup&gt;
  &lt;connectionStrings&gt;
    &lt;add name="AzureWebJobsDashboard" connectionString="DefaultEndpointsProtocol=https;AccountName={NAME};AccountKey={KEY}" /&gt;
    &lt;add name="AzureWebJobsStorage" connectionString="DefaultEndpointsProtocol=https;AccountName={NAME};AccountKey={KEY}" /&gt;
  &lt;/connectionStrings&gt;
&lt;/configuration&gt;</pre><p>As you can see, I already added two required connection strings—<code class="literal">AzureWebJobsDashboard </code>and <code class="literal">AzureWebJobsStorage</code>. Now, when <span>you</span><a id="id325381605" class="indexterm"></a> start the host, you should be able to see something similar to the following:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/015f0e72-688b-4b76-a7c3-47e87f486d32.png" /></div><p>Since we have no jobs added yet, none is found and enabled. Let's try to add one and see how it works. </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip37"></a>Note</h3><p>If you want, you can configure connection strings directly in your code by setting the <code class="literal">StorageConnectionString </code>and<span class="strong"><strong> </strong></span><code class="literal">DashboardConnectionString</code> properties of the <code class="literal">JobHostConfiguration </code>object manually.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec9"></a>Calling a job manually</h4></div></div></div><p>If <span>you</span><a id="id325381648" class="indexterm"></a> would like to trigger a job manually, you can use the <code class="literal">[NoAutomaticTrigger]</code> attribute to tell a host that this particular function is not triggered automatically. Here, you have an example of the one I created and named <code class="literal">Manual.cs</code>:</p><pre class="programlisting">using System.IO;
using Microsoft.Azure.WebJobs;

namespace MyFirstWebJobWebJobsSDK
{
    public class Manual
    {
        [NoAutomaticTrigger]
        public static void ManualFunction(
            TextWriter logger,
            string value)
        {
            logger.WriteLine($"Received message: {value}");
        }
    }
}</pre><p>Now let's see what happens if you call it from the main point of your program:</p><pre class="programlisting">using Microsoft.Azure.WebJobs;

namespace MyFirstWebJobWebJobsSDK
{
    class Program
    {
        static void Main()
        {
            var config = new JobHostConfiguration();
            var host = new JobHost(config);

            host.Call(typeof(Manual).GetMethod("ManualFunction"), new { value = "Hello world!" });

            host.RunAndBlock();
        }
    }
}</pre><p>You should be able to see the following result:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/fa88b714-63ab-4a99-aceb-0162d532c142.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec10"></a>Automatic triggers in WebJobs</h4></div></div></div><p>By default, the WebJobs SDK provides a limited set of triggers. Currently, it supports only the <span>following</span><a id="id325381827" class="indexterm"></a> ones:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Blob storage</li><li style="list-style-type: disc">Queue storage</li><li style="list-style-type: disc">Table storage</li></ul></div><p> </p><p>All of these are connected to Azure Storage and will be covered in the chapter describing Azure Functions. Fortunately, we can install additional NuGet packages to extend the functionality of our host. For now, add the <code class="literal">Microsoft.Azure.WebJobs.Extensions</code> package so that we will be able to use <code class="literal">TimerTrigger</code>. When you have it, call the <code class="literal">UseTimers()</code><span class="strong"><strong> </strong></span>method on the <code class="literal">JobHostConfiguration </code>object:</p><pre class="programlisting">using Microsoft.Azure.WebJobs;

namespace MyFirstWebJobWebJobsSDK
{
    class Program
    {
        static void Main()
        {
            var config = new JobHostConfiguration();
<span class="strong"><strong>config.UseTimers();</strong></span>

            var host = new JobHost(config);

            host.Call(typeof(Manual).GetMethod("ManualFunction"), new { value = "Hello world!" });

            host.RunAndBlock();
        }
    }
}</pre><p>Now we can create a new <code class="literal">Timer.cs</code><span class="strong"><strong> </strong></span>function, which will be triggered on schedule:</p><pre class="programlisting">using System;
using System.IO;
using Microsoft.Azure.WebJobs;

namespace MyFirstWebJobWebJobsSDK
{
    public class Timer
    {
        public static void TimerFunction(
            [TimerTrigger("* */1 * * * *")] TimerInfo timer,
            TextWriter logger)
        {
            logger.WriteLine($"Message triggered at {DateTime.Now:yyyy-MM-dd HH:mm:ss}");
        }
    }
}</pre><p>When you start your project, <code class="literal">TimerFunction</code> should be discovered and called:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/9990c137-77d1-4179-a605-92f87e30584d.png" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip38"></a>Note</h3><p>You can install additional packages to leverage other bindings, such as <code class="literal">Http</code>, <code class="literal">Notification Hub</code>, or <code class="literal">SendGrid</code>. Search for packages with the <code class="literal">Microsoft.Azure.WebJobs.Extensions</code><span class="strong"><strong> </strong></span>prefix. </p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec11"></a>Publish a job </h4></div></div></div><p>Publishing a job, which is written using the WebJobs SDK, is the <span>same</span><a id="id325382134" class="indexterm"></a> as in the previous exercises. Right-click on your project and click on <strong class="userinput"><code>Publish as Azure WebJob</code></strong>. You will be once more guided through the process of publishing a job package. At the end of it, you should be able to see a job available in your App Service:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/33e89f7d-57cc-4e0d-a308-491e2b6f9ea1.png" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip39"></a>Note</h3><p>If you find that your job has problems running, make sure the required connection strings are available in App Service. To do so, go to the <strong class="userinput"><code>Application settings</code></strong><span class="strong"><strong> </strong></span>blade and verify the contents of the <strong class="userinput"><code>Connection strings</code></strong><span class="strong"><strong> </strong></span>section. If something is missing, add it manually by adding a name and its value and set its type as <strong class="userinput"><code>Custom</code></strong>.</p></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec20"></a>Azure WebJobs limitations</h3></div></div></div><p>As Azure WebJobs are based on Azure App <span>Services</span><a id="id325382318" class="indexterm"></a> and, what is more, there is no way to host them individually (you can use an extra App Service Plan to power them, but this often means that you pay the double price for your service), you may find some of their limitations quite serious in your projects. When using this particular service, remember the following things:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">When co-hosting Web App and WebJobs, one may interfere with the performance of other. In other words, if your WebJob starts to utilize too much CPU/memory, it may affect your web application powered by the same App Service Plan.</li><li style="list-style-type: disc">Azure WebJobs have a limited catalog of bindings that are offered—they are currently less popular than Azure Functions and are not so dynamically developed.</li><li style="list-style-type: disc">There is no way to utilize the consumption model with Azure WebJobs; hence, you have to pay the full price, even if they do nothing 90% of the time.</li></ul></div></div></div>