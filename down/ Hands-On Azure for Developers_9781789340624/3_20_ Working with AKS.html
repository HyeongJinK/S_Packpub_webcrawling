<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec26"></a>Working with AKS</h2></div></div><hr /></div><p>AKS eases the <span>process</span><a id="id325674010" class="indexterm"></a> of deploying and managing containerized applications by eliminating the need to maintain or upgrade your resources on your own. It is a managed Kubernetes service hosted in Azure with many helpful features such as integrated logging and monitoring, identity and security management, and virtual network integration. In this section, we will create a simple application hosted in an AKS cluster, which we will scale and update.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec23"></a>Preparing an application</h3></div></div></div><p>Let's start with a <span>tutorial</span><a id="id325469624" class="indexterm"></a> application proposed by the Docker documentation:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>To begin, we need <code class="literal">Dockerfile</code>, which is a definition of how our container environment should look. It contains keywords such as <code class="literal">FROM</code> (defines an image that will be used for the container), <code class="literal">WORKDIR</code> (the working directory of the application), <code class="literal">ADD</code> (adds a directory to a container), <code class="literal">RUN</code> (runs a command), <code class="literal">EXPOSE</code> (exposes a given port in the container), <code class="literal">ENV</code> (adds an environment variable), and <code class="literal">CMD</code> (declares an entry point):</li></ol></div><pre class="programlisting">FROM python:2.7-slim
WORKDIR /app
ADD . /app
RUN pip install --trusted-host pypi.python.org -r requirements.txt
EXPOSE 80
ENV NAME HandsOnAzure
CMD ["python", "app.py"]</pre><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>We will need two more files:
<div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">requirements.txt</code>: This one defines the external dependencies our application has to download</li><li style="list-style-type: disc"><code class="literal">app.py</code>: The main file of an application
</li></ul></div></li></ol></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note42"></a>Note</h3><p>If you are familiar with Docker, you can prepare your very own <code class="literal">Dockerfile</code> and application; there is no need to follow everything in this section as we are covering very basic topics.</p></div><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>Here, you can find the contents of <code class="literal">requirements.txt</code>:</li></ol></div><pre class="programlisting">Flask
Redis</pre><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>And of course, <code class="literal">app.py</code>, which is the script we want to run. It is a simple Python application that uses Flask to host a web app and defines the default route that exposes an HTML web page. Note that it accesses the <code class="literal">HandsOnAzure</code> environment variable defined in the Dockerfile: </li></ol></div><pre class="programlisting">from flask import Flask
from redis import Redis, RedisError
import os
import socket

# Connect to Redis
redis = Redis(host="redis", db=0, socket_connect_timeout=2, socket_timeout=2)

app = Flask(__name__)

@app.route("/")
def hello():
    try:
        visits = redis.incr("counter")
    except RedisError:
        visits = "&lt;i&gt;cannot connect to Redis, counter disabled&lt;/i&gt;"

    html = "&lt;h3&gt;Hello {name}!&lt;/h3&gt;" \
           "&lt;b&gt;Hostname:&lt;/b&gt; {hostname}&lt;br/&gt;" \
           "&lt;b&gt;Visits:&lt;/b&gt; {visits}"
    return html.format(name=os.getenv("NAME", "HandsOnAzure"), hostname=socket.gethostname(), visits=visits)

if __name__ == "__main__":
    app.run(host='0.0.0.0', port=80)</pre><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>Now, you need two more things—to build an image and check whether it works. To build an image, you will need the following command:</li></ol></div><pre class="programlisting">docker build -t {IMAGE_NAME} .</pre><p> </p><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>After Docker fetches all of <span>the</span><a id="id325710297" class="indexterm"></a> packages and builds an image, you can run it. I used the <code class="literal">4000</code><span class="strong"><strong> </strong></span>port but you can choose whichever works for you:</li></ol></div><pre class="programlisting">docker run -p 4000:80 {IMAGE_NAME}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="7" type="1"><li>If everything is correct, you should be able to see a running application:</li></ol></div><div class="mediaobject"><img src="/graphics/9781789340624/graphics/c6495cc0-483a-4ea3-a753-dc5224c8075b.png" /></div><p>In the next section, we will create a container registry and Kubernetes cluster to host an application.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec24"></a>Container Registry and Kubernetes clusters</h3></div></div></div><p>To use a Docker image in Azure, we have to <span>put</span><a id="id325710414" class="indexterm"></a> it in a container registry. To do so, we can use <span class="strong"><strong>Azure Container Registry</strong></span> (<span class="strong"><strong>ACR</strong></span>), which is a private registry for <span>hosting</span><a id="id325710432" class="indexterm"></a> container images. To get started, go to Azure Portal, click on <strong class="userinput"><code>+ Create a resource</code></strong>, and search for <code class="literal">Container Registry</code>. When you click <strong class="userinput"><code>Create</code></strong>,<strong class="userinput"><code> </code></strong>you <span>will</span><a id="id326263858" class="indexterm"></a> see a familiar <span>screen</span><a id="id326263866" class="indexterm"></a> containing multiple <span>fields</span><a id="id326263873" class="indexterm"></a> needed for service configuration. The following need clarification for now:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><strong class="userinput"><code>Admin user</code></strong>: If you want to log in to your registry using the registry name and admin access key, you can turn on this feature. By default it is disabled.</li><li style="list-style-type: disc"><strong class="userinput"><code>SKU</code></strong>: This defines the overall performance of the registry and available features. To start with, the <strong class="userinput"><code>Basic </code></strong>tier should be more than enough.</li></ul></div><p> </p><p> </p><p>The following screenshot shows my current configuration:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/a167f90a-c69e-4f28-96e0-1e0dd04106fe.png" /></div><p>If you are satisfied with the configuration, you can click <strong class="userinput"><code>OK</code></strong>. Now we will push an image with an application to the registry to use it in Azure.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec12"></a>Pushing a Docker image to Azure Container Registry</h4></div></div></div><p>To push an image to Azure <span>Container</span><a id="id325221142" class="indexterm"></a> Registry, we have to know the exact name of the image:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>To list available images, use the following command:</li></ol></div><pre class="programlisting"><span class="strong"><strong>docker images</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>The result of running the command is a list of all repositories available for Docker:</li></ol></div><div class="mediaobject"><img src="/graphics/9781789340624/graphics/6054fc24-b7b6-4614-a4ba-0afd35721c53.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>I want to push <code class="literal">handsonazurehello</code>, which I created previously, to Azure. To do so, I will need firstly to tag an image using the following command:</li></ol></div><pre class="programlisting"><span class="strong"><strong>docker tag handsonazurehello {ACR_LOGIN_SERVER}/handsonazurehello:v1</strong></span></pre><p>The reason for tagging is to both set a version for my container and give it the appropriate name that is required to push it to a private registry.</p><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>You can find <strong class="userinput"><code>Login server</code></strong><span class="strong"><strong> </strong></span>on the <strong class="userinput"><code>Overview </code></strong>blade:</li></ol></div><div class="mediaobject"><img src="/graphics/9781789340624/graphics/3b29b22e-dae2-4f75-b691-5885faa23e3d.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>Now you can try to push an image with the following command:</li></ol></div><pre class="programlisting"><span class="strong"><strong>docker push handsonazureregistry.azurecr.io/handsonazurehello:v1</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>Of course, you have to push your image name and registry server login. When you execute the preceding command, you will see the following result:</li></ol></div><pre class="programlisting"><span class="strong"><strong>$ docker push handsonazureregistry.azurecr.io/handsonazurehello:v1</strong></span>
<span class="strong"><strong>The push refers to repository [handsonazureregistry.azurecr.io/handsonazurehello]</strong></span>
<span class="strong"><strong>bbdbf9d56e79: Preparing</strong></span>
<span class="strong"><strong>128193523190: Preparing</strong></span>
<span class="strong"><strong>f78e6f8eec4b: Preparing</strong></span>
<span class="strong"><strong>20f93bdcee9c: Preparing</strong></span>
<span class="strong"><strong>21b24882d499: Preparing</strong></span>
<span class="strong"><strong>db9dabc5cfee: Waiting</strong></span>
<span class="strong"><strong>d626a8ad97a1: Waiting</strong></span>
<span class="strong"><strong>unauthorized: authentication required</strong></span></pre><p> </p><p> </p><div class="orderedlist"><ol class="orderedlist arabic" start="7" type="1"><li>Still there is something wrong—we are pushing a container to the correct registry, but we have not authenticated yet. To have access to Azure Container Registry, we have to use Azure CLI. Use two commands:</li></ol></div><pre class="programlisting"><span class="strong"><strong>az login</strong></span>
<span class="strong"><strong>az acr login --name {REGISTRY_NAME}</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="8" type="1"><li>The first one is used to authenticate in Azure, the second one will let you work with your instance of Container Registry. After successfully authenticating, you can retry pushing an image—this time everything should work smoothly:</li></ol></div><pre class="programlisting"><span class="strong"><strong>$ docker push handsonazureregistry.azurecr.io/handsonazurehello:v1</strong></span>
<span class="strong"><strong>The push refers to repository [handsonazureregistry.azurecr.io/handsonazurehello]</strong></span>
<span class="strong"><strong>bbdbf9d56e79: Pushed</strong></span>
<span class="strong"><strong>128193523190: Pushed</strong></span>
<span class="strong"><strong>f78e6f8eec4b: Pushed</strong></span>
<span class="strong"><strong>20f93bdcee9c: Pushed</strong></span>
<span class="strong"><strong>21b24882d499: Pushed</strong></span>
<span class="strong"><strong>db9dabc5cfee: Pushed</strong></span>
<span class="strong"><strong>d626a8ad97a1: Pushed</strong></span>
<span class="strong"><strong>v1: digest: sha256:2e689f437e1b31086b5d4493c8b4ef93c92640ad576f045062c81048d8988aa6 size: 1787</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="9" type="1"><li>You can verify it is available in the portal:</li></ol></div><div class="mediaobject"><img src="/graphics/9781789340624/graphics/37b97966-b78b-4d43-bdd7-878a03ebe229.png" /></div><p>The next thing we need is a Kubernetes cluster—this is why we use AKS to provision a managed Kubernetes service.</p><p> </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec13"></a>Creating a Kubernetes cluster using AKS</h4></div></div></div><p>To create a Kubernetes service, perform <span>the</span><a id="id325331351" class="indexterm"></a> following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><span class="emphasis"><em>G</em></span>o to the portal.</li><li>Click on the <strong class="userinput"><code>+ Create a resource </code></strong>button and search for <code class="literal">AKS</code>.</li><li>When you click <strong class="userinput"><code>Create</code></strong>, you should see the following screen:</li></ol></div><div class="mediaobject"><img src="/graphics/9781789340624/graphics/ac7a2186-bde0-4abe-bcd6-8a6b7d7a88ca.png" /></div><p> </p><p>As you can see, we have plenty of different options and fields here. Some of them should be self-explanatory. Initially, I recommend using default values for most fields, such as <strong class="userinput"><code>Kubernetes version</code></strong><span class="strong"><strong> </strong></span>or <strong class="userinput"><code>Service principal,</code></strong><span class="strong"><strong> </strong></span>as they matter only if you have existing requirements regarding your application.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip43"></a>Note</h3><p>To learn more about applications and service principal objects in Azure AD, you can read this short article from the documentation: <a class="ulink" href="https://docs.microsoft.com/en-us/azure/active-directory/develop/active-directory-application-objects" target="_blank">https://docs.microsoft.com/en-us/azure/active-directory/develop/active-directory-application-objects</a>.</p></div><p>You can go to different tabs such as <strong class="userinput"><code>Networking </code></strong>or <strong class="userinput"><code>Monitoring </code></strong>to see whether you want to change something—however, the current settings should be correct for the very first AKS cluster.</p><p>Once you have reviewed all fields, click on the <strong class="userinput"><code>Review + create </code></strong>button. The following screenshot shows my configuration:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/71b871e6-4981-4f94-a866-d6123344eca8.png" /></div><p>When you click on <strong class="userinput"><code>Create</code></strong>, you will have to wait a moment until deployment is finished. </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note44"></a>Note</h3><p>Creating a cluster can take a while, especially when you select several machines to be deployed at once. Be patient!</p></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec25"></a>Running, scaling, and updating an application in AKS</h3></div></div></div><p>To run and deploy an application in AKS in Azure, we <span>will</span><a id="id325342759" class="indexterm"></a> need the Kubernetes manifest file, which <span>will</span><a id="id325342768" class="indexterm"></a> define how an image should be deployed. However, before we perform that part of the exercise, we have to configure Kubernetes locally, so it can <span>connect</span><a id="id325342776" class="indexterm"></a> with our cluster. To do so, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Run the following command:</li></ol></div><pre class="programlisting"><span class="strong"><strong>kubectl get nodes</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Initially, it will return the following result:</li></ol></div><pre class="programlisting"><span class="strong"><strong>Unable to connect to the server: dial tcp [::1]:8080: connectex: No connection could be made because the target machine actively refused it.</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>That means that we have not configured <code class="literal">kubectl </code>with the AKS cluster we just created. To do so, use the following Azure CLI command:</li></ol></div><pre class="programlisting"><span class="strong"><strong>az aks get-credentials --resource-group {RESSOURCE_GROUP} --name {AKS_CLUSTER_NAME}</strong></span></pre><p>Running it should merge your cluster as a current context in your local configuration. Now, when you verify your connection, everything should be set and ready. We can go back to our manifest file—the initial version can be found in the <span class="emphasis"><em>Chapter03</em></span> in the repository. In general, it is a simple YML file that defines and configures services and deployment.</p><p> </p><p> </p><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>Put the file in the directory for your application and use the following command to deploy it:</li></ol></div><pre class="programlisting"><span class="strong"><strong>kubectl apply -f handsonazure.yml</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>After a moment, you should see the status of the process:</li></ol></div><pre class="programlisting"><span class="strong"><strong>$ kubectl apply -f handsonazure.yml</strong></span>
<span class="strong"><strong>deployment "handsonazurehello-back" created</strong></span>
<span class="strong"><strong>service "handsonazurehello-back" created</strong></span>
<span class="strong"><strong>deployment "handsonazurehello" configured</strong></span>
<span class="strong"><strong>service "handsonazurehello" unchanged</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>Now, we need one more command to get the external IP of our service:</li></ol></div><pre class="programlisting"><span class="strong"><strong>$ kubectl get service handsonazurehello --watch</strong></span>
<span class="strong"><strong>NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE</strong></span>
<span class="strong"><strong>handsonazurehello LoadBalancer 10.0.223.94 40.118.7.118 80:30910/TCP 4m</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="7" type="1"><li>Initially, you could see the <code class="literal">EXTERNAL-IP</code> field as pending—it should change in a second. Now you can verify the installation of an application:</li></ol></div><div class="mediaobject"><img src="/graphics/9781789340624/graphics/2e391323-eb7f-4a04-bda3-04f2a086efab.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="8" type="1"><li>There is also one more method to get the status of the whole cluster. Try to run the following command:</li></ol></div><pre class="programlisting"><span class="strong"><strong>az aks browse --resource-group {RESOURCE_GROUP} --name {AKS_CLUSTER_NAME}</strong></span></pre><p> </p><p> </p><div class="orderedlist"><ol class="orderedlist arabic" start="9" type="1"><li>After a moment, you should see the whole Kubernetes dashboard available locally. Read all of the information carefully as it is really helpful when diagnosing possible issues with AKS:</li></ol></div><div class="mediaobject"><img src="/graphics/9781789340624/graphics/95328b8f-8ec0-40a6-b57c-8cc2bea6d383.png" /></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec14"></a>Solving problems with authentication</h4></div></div></div><p>Sometimes AKS cannot <span>access</span><a id="id325382302" class="indexterm"></a> Azure Container Registry and needs the creation of a service principal, which can be used in pod deployment. To create it, you will need to perform the following script:</p><pre class="programlisting"><span class="strong"><strong>$ az acr show --name {REGISTRY_NAME} --query loginServer --output tsv</strong></span>
<span class="strong"><strong>{YOUR_REGISTRY_NAME}</strong></span>

<span class="strong"><strong>$ az acr show --name handsonazureregistry --query id --output tsv</strong></span>
<span class="strong"><strong>/subscriptions/94f33c43-60b5-4042-ae74-51777f69f99a/resourceGroups/handsonazure-rg/providers/Microsoft.ContainerRegistry/registries/handsonazureregistry</strong></span>
<span class="strong"><strong>{REGISTRY_ID}</strong></span>

<span class="strong"><strong>$ az ad sp create-for-rbac --name acr-service-principal --role Reader --scopes {REGISTRY_ID} --query password --output tsv</strong></span>
<span class="strong"><strong>{PASSWORD}</strong></span>

<span class="strong"><strong>$ az ad sp show --id http://acr-service-principal --query appId --output tsv</strong></span>
<span class="strong"><strong>{CLIENT_ID}</strong></span>

<span class="strong"><strong>$ kubectl create secret docker-registry acr-auth --docker-server {YOUR_REGISTRY_NAME} --docker-username {CLIENT_ID} --docker-password {PASSWORD} --docker-email {DOCKER_ACCOUNT_EMAIL}</strong></span></pre><p>The full script can be also found in the source code for this chapter. Once the secret is created, you can modify the manifest file and add the <code class="literal">imagePullSecrets</code> line to it:</p><pre class="programlisting"><span class="strong"><strong>containers:</strong></span>
<span class="strong"><strong>      - name: handsonazurehello</strong></span>
<span class="strong"><strong>       image: handsonazureregistry.azurecr.io/handsonazurehello:v1</strong></span>
<span class="strong"><strong>        ports:</strong></span>
<span class="strong"><strong>        - containerPort: 80</strong></span>
<span class="strong"><strong>        resources:</strong></span>
<span class="strong"><strong>          requests:</strong></span>
<span class="strong"><strong>            cpu: 250m</strong></span>
<span class="strong"><strong>          limits:</strong></span>
<span class="strong"><strong>            cpu: 500m</strong></span>
<span class="strong"><strong>        env:</strong></span>
<span class="strong"><strong>        - name: REDIS</strong></span>
<span class="strong"><strong>          value: "handsonazurehello-back"</strong></span>
<span class="strong"><strong>      imagePullSecrets:</strong></span>
<span class="strong"><strong>      - name: acr-auth</strong></span></pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec15"></a>Scaling a cluster</h4></div></div></div><p>Scaling in AKS is one of the <span>easiest</span><a id="id325469511" class="indexterm"></a> things to do. All you need to do is go to Azure Portal, find your AKS instance, and click on the <strong class="userinput"><code>Scale</code></strong><span class="strong"><strong> </strong></span>blade:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/f3abfa9f-b9a1-40a9-835a-981e8a0321c0.png" /></div><p>Once there, you can change the cluster capacity depending on your needs.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip45"></a>Note</h3><p>Make sure you have the required number of nodes available for your application—such information can be found in the Kubernetes dashboard. If you don't have enough machines, some of your images might not be deployed.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec16"></a>Updating an application</h4></div></div></div><p>Updating an <span>application</span><a id="id325469549" class="indexterm"></a> in AKS requires two things:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Publishing a new image to Azure Container Registry</li><li style="list-style-type: disc">Setting a new image as the actual one in AKS</li></ul></div><p>When you make changes in your application, you need two commands to update it in a registry. First, change its version to a new one:</p><pre class="programlisting"><span class="strong"><strong>docker tag handsonazurehello {ACR_LOGIN_SERVER}/handsonazurehello:v2</strong></span></pre><p> </p><p> </p><p> </p><p> </p><p>Now what you need is to push this version to make it available in the cloud:</p><pre class="programlisting"><span class="strong"><strong>docker push
{ACR_LOGIN_SERVER}/handsonazurehello:v2</strong></span></pre><p>The final step to tell Kubernetes to update an image:</p><pre class="programlisting"><span class="strong"><strong>kubectl <span>set</span><span>image</span><span>deployment</span> handsonazurehello handsonazurehello=
{ACR_LOGIN_SERVER}/handsonazurehello:v2</strong></span></pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip46"></a>Note</h3><p>To ensure that your application is fully functional while updating, you have to scale it out to multiple pods. You can do it with the following command:<code class="literal"><span class="strong"><strong>kubectl scale --replicas=3 deployment/{YOUR_APPLICATION}</strong></span></code></p></div></div></div></div>