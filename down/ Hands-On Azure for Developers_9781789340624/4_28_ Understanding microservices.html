<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec33"></a>Understanding microservices</h2></div></div><hr /></div><p>Probably you have heard about an architecture called <span class="strong"><strong>microservices</strong></span>. There is no single <span>definition</span><a id="id325676393" class="indexterm"></a> that we could quote here, so the main purpose of this chapter will be to acquire a better insight into what we can call a microservice and how to develop an application in such a manner. This directly connects to SF, which is one of the biggest and most advanced services in Azure. If you aim at building a modular, loosely-coupled, and modern application, this particular cloud component is designed for you.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec29"></a>Monolith versus microservices</h3></div></div></div><p>We will start our journey with microservices by comparing them with a traditional application, which is <span>composed</span><a id="id325676388" class="indexterm"></a> of multiple layers serving different purposes:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/c9c477d6-13e8-4e08-9b3d-bce3a157602c.png" /></div><p>As you can see, we define such services as monolithic, where the whole code base is deployed as one application. This one application has multiple responsibilities:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Serving the UI</li><li style="list-style-type: disc">Running business logic</li><li style="list-style-type: disc">Running additional processes (such as jobs)</li></ul></div><p>We can also look at it differently—as a single module that handles features from different domains. Let's consider an e-shop, where we have the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Payment logic</li><li style="list-style-type: disc">Basket logic</li><li style="list-style-type: disc">Order processing logic</li><li style="list-style-type: disc">Discounts logic</li><li style="list-style-type: disc">Many, many more different domains</li></ul></div><p>Now the question arises—should our application run such logic in one instance or should we divide it into multiple independent modules, which have different lifetimes, run differently, and can be developed individually? Maybe we would also like to scale them separately depending on current workload or business requirements. The choice always depends on the requirements your application will have to face. However, if you would like to give try microservices, SF is the way to go, especially if you aim at using cloud-native components.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec30"></a>Microservice approach</h3></div></div></div><p>You may wonder whether the microservice architecture is one you <span>would</span><a id="id325122112" class="indexterm"></a> like to choose and work with. In this section, I would like to focus on specific features this approach provides and how you can address them when writing an application and, in the end, using SF.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec19"></a>Using different languages and frameworks</h4></div></div></div><p>Sometimes, we would like to address different problems <span>resolved</span><a id="id325124993" class="indexterm"></a> by our application by using different programming languages or tools. Maybe it is a good idea to write mainly in C# or Java and deliver more advanced features such as domain-specific calculations using a dedicated language. Maybe we have multiple teams working on different features and each one would like to use a different framework.</p><p>Maybe the whole work is so globally distributed that dividing it into multiple smaller packages (and finally services) is the way to go. All of these problems are possible to solve using a single application but, on a bigger scale, such an approach could become cumbersome and insufficient. By leveraging the capabilities of SF in Azure, we can organize multiple applications (containing multiple services each) as a single platform, which can be managed from one place and deployed individually, saving time and money.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec20"></a>Scaling and updating services individually</h4></div></div></div><p>We have just talked about <span>deploying</span><a id="id325125010" class="indexterm"></a> each service individually. Thanks to <span>such</span><a id="id325128262" class="indexterm"></a> an approach, you do not have to push the whole code base at once. I am sure you have had at least one project that was so big that the whole process of delivering it to the production environment was difficult to automate and took really long to finish. In such a scenario, dividing the project into smaller modules can also be beneficial let's say that, in the last month, only one team delivered a new feature; you do not have to go through all your platform tests. What is more, if something is not right after deployment in a part of the system you have not modified, you do not have to bring in another team to investigate the problem. This confers the following advantages:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">The process of delivering a business value is shorter and simpler, and hence less vulnerable to mistakes</li><li style="list-style-type: disc">You can focus on a particular module and changes in it often do not affect other modules</li></ul></div><p>There is one more interesting feature of the microservices architecture—you can scale each component separately. This means that if, for example, there is a module responsible for processing payments and you have just had a big discount in your online shop, resulting in a rapid growth of incoming orders, you do not have to worry that they overwhelm it. What you can do in such a situation is simply scale it out, so you can process each order in parallel using as many instances of your module as you currently need. Later in this chapter, you will learn how you can achieve such scalability in SF using different approaches depending on the actual structure of your application. The following diagram describes the difference between scaling microservices and monolith application—while the former gives you the possibility to scale up each service individually, the latter has to be scaled as a single entity:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/f949f99b-bb10-4da3-b64f-9fe296c72de7.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec21"></a>Using well-designed interfaces and protocols</h4></div></div></div><p>You may ask, If we divide our application into, for instance, several smaller modules, how can we now ensure that communication between them will be smooth, seamless, and with the smallest latency possible? To satisfy <span>such</span><a id="id325128296" class="indexterm"></a> requirements, one has to refer to multiple communication <span>patterns described by patterns</span> for service-oriented architectures, which in fact are the very foundation of microservices. In general, you have to leverage well-known protocols such as HTTP or TCP, which are widely used in the IT industry and are understood by thousands of APIs, devices, and frameworks. Of course, you could think about designing a custom protocol or standard—while initially, it might be a good idea, sooner or later it may become an obstacle to expanding your application because it's not compatible with newer services. What is more, it is important to use popular serialization methods such as XML, JSON, or any binary format that is easily available and well documented. By following such guides, you can be sure that your microservice architecture will be easy to extend and integrate with.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec22"></a>Dealing with state</h4></div></div></div><p>Nearly every application has some kind of state (of course, one can develop a stateless service, which does not have to store a state anywhere and just performs an action/returns a result; we will cover <span>such</span><a id="id325128349" class="indexterm"></a> services later in this chapter).</p><p>This state has to be managed and shared; in monolithic application handling, it is pretty straightforward and obvious—we have, for instance, a database, which holds all information from multiple parts of our system. In general, it is stored in one place (of course it can be scaled and shared, but we do not manage such features on our own), so we do not have to worry that we update it only partially (and if we do, there are always transactions). Of course, the state does not have to be stored in a database—we can use any kind of storage that holds data.</p><p>When using microservices, it turns out that each individual service has its own state and manages it independently. Problems arise where we have to query data from different modules or store data in more than one form of storage. To overcome such problems, one can use patterns such as eventual consistency. In SF, you can choose whether a state should be externalized or co-located. Additionally, SF takes care of making it highly available and durable.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec23"></a>Diagnosing and monitoring microservices</h4></div></div></div><p>While the process of monitoring traditional <span>applications</span><a id="id325128369" class="indexterm"></a> is pretty straightforward and simple, when you have tens or hundreds of smaller services, making it right is not that obvious. This has also other implications <span>such</span><a id="id325128377" class="indexterm"></a> as: What is the actual impact if one module goes down? When you have a monolith, you are immediately aware of any issues as your application simply stops working properly. With microservices, you may find it difficult to react in time if your monitoring does not cover all areas of your system. In SF, you have <span>multiple</span><a id="id325128386" class="indexterm"></a> levels of monitoring, which you can define as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Application monitoring</strong></span>: This tracks how your application is used.</li><li style="list-style-type: disc"><span class="strong"><strong>Cluster monitoring</strong></span>: This allows you to <span>monitor</span><a id="id325143092" class="indexterm"></a> the whole SF cluster, so you can verify whether the whole service performs as expected.</li><li style="list-style-type: disc"><span class="strong"><strong>Performance monitoring</strong></span>: Sometimes, it is <span>hard</span><a id="id325143106" class="indexterm"></a> to understand how your application behaves if you do not monitor its performance. In SF, it is easier to track resource utilization and predict possible issues.</li><li style="list-style-type: disc"><span class="strong"><strong>Health monitoring</strong></span>: When working with microservices, it is crucial to know whether particular modules are healthy or not. In SF, you can leverage the Health API or health <span>reports</span><a id="id325143120" class="indexterm"></a> available in SF Explorer to gain a better insight into the current status of your application.</li></ul></div></div></div></div>