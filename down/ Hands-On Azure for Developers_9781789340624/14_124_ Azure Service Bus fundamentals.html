<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch14lvl1sec119"></a>Azure Service Bus fundamentals</h2></div></div><hr /></div><p>You have already learned about <span>other</span><a id="id326395966" class="indexterm"></a> messaging solutions, which allow you to ease communication between your services, and all are characterized by different features. In Azure Event Hub,<span class="emphasis"><em> </em></span>you were able to process thousands of messages per second, while with Azure Storage Queues<span class="emphasis"><em> </em></span>you were given a reliable and durable solution, which you could use to work asynchronously on ingested data. In this chapter, we will discuss Azure Service Bus, a multitenant cloud messaging service that introduces advanced concepts like first-in,first-out(FIFO) messaging, dead lettering, or transactions. It is an enterprise-class cloud component able to integrate many different services and applications.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch14lvl2sec137"></a>Azure Service Bus versus other messaging services</h3></div></div></div><p>In the previous chapters, we <span>discussed</span><a id="id325317176" class="indexterm"></a> the following services, which allowed us to process messages:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Azure Event Hub</li><li style="list-style-type: disc">Azure Storage Queue</li><li style="list-style-type: disc">Azure Event Grid</li></ul></div><p>They all have similarities, yet they are designed to serve different features and offer different capabilities. We often use the concepts of events<span class="strong"><strong> </strong></span>and messages<span class="strong"><strong> </strong></span>alternately. In fact, there is a slight difference between them and understanding this is crucial to be able to use different messaging services successfully:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Event</strong></span>: It carries the information that <span>something</span><a id="id325468823" class="indexterm"></a> happened—the fact that someone or something produced an event does not imply any expectations regarding how an event should be handled. Events, in general, are lightweight information carriers and do not bring the full data to the receiver.
</li><li style="list-style-type: disc"><span class="strong"><strong>Message</strong></span>: As opposed to an event, when a producer sends a message, it has some expectation about how it will be handled (so there is some kind of a contract between a producer and a consumer). What is more, a message carries the raw data while an event implies that <span>something</span><a id="id325468835" class="indexterm"></a> happened; a message indicates that a component has initialized a communication, which should be handled in the usual way.</li></ul></div><p>Now you can recall what you have learned about, for example, Azure Event Grid<span class="emphasis"><em> </em></span>or Azure Event Hub—they both have an event<span class="emphasis"><em> </em></span>in the name, but work in quite different ways:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Azure Event Grid</strong></span>: It is designed to <span>distribute</span><a id="id325469065" class="indexterm"></a> events and react to changes. It delivers only the metadata, and the actual message has to be fetched individually; thus, it can be said, that it distributes events.</li><li style="list-style-type: disc"><span class="strong"><strong>Azure Event Hub</strong></span>: It works as a big <span>data</span><a id="id325469079" class="indexterm"></a> pipeline and streams events to other services. Depending on your implementation, it can stream both events<span class="strong"><strong> </strong></span>and messages.</li></ul></div><p>Now, let's compare Service Bus:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Azure Service Bus</strong></span>: It was created to support critical processes, which have high requirements regarding the order of processing and reliability of the messaging service. You can use it when a message<span class="strong"><strong> </strong></span>cannot be lost or duplicated. It does not <span>work</span><a id="id326395004" class="indexterm"></a> with the concept of events—instead, it allows you to push the whole data, which can be read by a consumer.</li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch14lvl2sec138"></a>Azure Service Bus and Azure Storage Queues</h3></div></div></div><p>You may wonder what the difference <span>between</span><a id="id326395017" class="indexterm"></a> Azure Service Bus<span class="emphasis"><em> </em></span>and Azure Storage Queues is. In fact, they are both messaging solutions, which are reliable, durable, and can handle multiple messages at once. However, looking more closely, you can see they are quite different services, built using different concepts and for a different purpose:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Azure Storage Queue<span class="emphasis"><em> </em></span>solutions are forced to poll the queue to receive a message—with Azure Service Bus<span class="emphasis"><em> </em></span>you can establish a long-polling receive operation via TCP.</li><li style="list-style-type: disc">In Azure Storage Queue,<span class="emphasis"><em> </em></span>you can store messages of up to 64 KB—Azure Service Bus changes that limit to 256 KB.
</li><li style="list-style-type: disc">Azure Service Bus<span class="emphasis"><em> </em></span>queues can store less data than Azure Storage Queues—up to 80 GB.</li><li style="list-style-type: disc">Azure Service Bus supports consuming batches of messages.</li><li style="list-style-type: disc">In Azure Storage Queues,<span class="emphasis"><em> </em></span>the security model is quite basic—Azure Service Bus<span class="emphasis"><em> </em></span>supports an RBAC model when it comes to securing queues.</li><li style="list-style-type: disc">Azure Storage Queues<span class="emphasis"><em> </em></span>do not support transactional behaviour.</li></ul></div><p>As you can see, in Azure Service Bus<span class="emphasis"><em> </em></span>there are many advanced features available, which can be very helpful in applications integrating different systems and applications, and also in third-party ones. Of course, those additional features cost extra as they require a more expensive tier. In Azure Service Bus,<span class="emphasis"><em> </em></span>you have three tiers:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Basic</strong></span>: Supports queues and scheduled messages only.</li><li style="list-style-type: disc"><span class="strong"><strong>Standard</strong></span>: All features are available.</li><li style="list-style-type: disc"><span class="strong"><strong>Premium</strong></span>: The maximum message size is extended to 1 MB, and brokered connections are included in the price. This tier also guarantees higher throughput and better performance.</li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip165"></a>Note</h3><p>If you require only the basic functionality (without topics, transactions, or sessions), an Azure Service Bus<span class="emphasis"><em> </em></span>instance can be even cheaper than using Azure Storage Queues. It all depends on your requirements regarding your system.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch14lvl2sec139"></a>Azure Service Bus in Azure portal</h3></div></div></div><p>To create an instance of the Azure <span>Service</span><a id="id326395721" class="indexterm"></a> Bus, you have to search for the <code class="literal">Service Bus</code><span class="strong"><strong> </strong></span>service in the marketplace. You will see a short form where you fill in the most crucial information, like the name of the service, the pricing tier, and its location:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/13d0fca7-9ccf-4a87-8914-415dac71c735.png" /></div><p>For now, it is all you have to enter—just click on the <strong class="userinput"><code>Create</code></strong><span class="strong"><strong> </strong></span>button and wait a second until a service is created. The <strong class="userinput"><code>Overview</code></strong><span class="strong"><strong> </strong></span>blade shows a bit more information, but as you can see, it is very similar to the one you saw when working with Azure Event Hub:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/ddd52698-5128-47a9-a0c2-5379a1326e7b.png" /></div><p>In the preceding screenshot, you see that the<span class="strong"><strong> </strong></span><strong class="userinput"><code>+ Topic</code></strong><span class="strong"><strong> </strong></span>button is grayed out—this is because I selected the basic<span class="strong"><strong> </strong></span>tier for this exercise. By clicking on the <strong class="userinput"><code>+ Queue</code></strong><span class="strong"><strong> </strong></span>button, you will be able to create a new queue:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/22d40809-2e7d-419f-a712-4a674cfba194.png" /></div><p>Here things are getting a little bit more complicated:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><strong class="userinput"><code>Name</code></strong>: This is the unique name of a queue.</li><li style="list-style-type: disc"><strong class="userinput"><code>Max queue size</code></strong>: You can decide the maximum size of a queue (as opposed to a fixed size of 80 GB in Azure Storage Queue).
</li><li style="list-style-type: disc"><strong class="userinput"><code>Message time to live</code></strong>: In Azure Storage Queues,<span class="emphasis"><em> </em></span>the maximum lifetime of a message was 7 days. Here you can specify the custom lifetime of a message before it is deleted (or moved to a dead letter queue).</li><li style="list-style-type: disc"><strong class="userinput"><code>Lock duration</code></strong>: When a message is picked up by a consumer, it is locked for a fixed time period to avoid duplicated reads. Here you can customize it (up to a maximum of 5 minutes).</li><li style="list-style-type: disc"><strong class="userinput"><code>Enable duplicate detection</code></strong>: If you want to ensure the "exactly once" delivery model during a fixed time period, you can enable this option. It enables you to configure a duplicate detection window in which a history of processed messages will be kept.</li><li style="list-style-type: disc"><strong class="userinput"><code>Enable dead lettering on message expiration</code></strong>: If a message expires, it is automatically deleted. To push it to a dead letter queue instead, enable this option.</li><li style="list-style-type: disc"><strong class="userinput"><code>Enable sessions</code></strong>: Sessions in Azure <span>Service</span><a id="id326396386" class="indexterm"></a> Bus<span class="emphasis"><em> </em></span>ensure FIFO message processing. To make sure that the first message pushed to a service is the one to be processed, turn this feature on.</li><li style="list-style-type: disc"><strong class="userinput"><code>Enable partitioning</code></strong>: This option detaches a queue from a single messaging store, so in fact you are ending with multiple queues. This option ensures that even if a store has an outage, the whole queue or a topic will not go down. There are some limitations, however, regarding this feature—one is that with partitioning you cannot send messages belonging to different sessions in a single transaction. What is more, there is a limit of 100 partitioned queues or topics per namespace.</li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note166"></a>Note</h3><p>Partitioned queues and topics are not supported in the premium<span class="strong"><strong> </strong></span>tier of Azure Service Bus.</p></div><p>This is how a queue looks when partitioning is enabled:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/1260a54d-aaea-4999-97b5-63b892cc92a7.png" /></div><p>As you can see, the maximum size of a queue is displayed as 16 GB—this is because with partitioning enabled, we are ending with  16 partitions—each hosting a queue of the maximum size of 1 GB.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip167"></a>Note</h3><p>Because the maximum size of a single queue is set as 5 GB, you can achieve the maximum size of 80 GB by using partitioning. With that feature enabled, the maximum size will be 5 GB * 16 partitions = 80 GB.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch14lvl2sec140"></a>Queues, topics, and relays</h3></div></div></div><p>Azure <span>Service</span><a id="id325183408" class="indexterm"></a> Bus<span class="emphasis"><em> </em></span><span>supports</span><a id="id325183418" class="indexterm"></a> three <span>different</span><a id="id325183427" class="indexterm"></a> kinds of entities:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Queues</li><li style="list-style-type: disc">Topics</li><li style="list-style-type: disc">Relays</li></ul></div><p>All three give you different options when handling communication.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch14lvl3sec64"></a>Queues</h4></div></div></div><p>A queue is the <span>simplest</span><a id="id325194138" class="indexterm"></a> entity available in the service. You can define it as follows:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/e2324430-a141-4d6c-95c5-96e7e5402227.png" /></div><p>In the preceding sample, you can see that we have the following concepts:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Producer</strong></span>: An application or a service, which pushes a <span>message</span><a id="id325194166" class="indexterm"></a> to a queue</li><li style="list-style-type: disc"><span class="strong"><strong>Queue</strong></span>: A container for <span>messages</span><a id="id325194178" class="indexterm"></a></li><li style="list-style-type: disc"><span class="strong"><strong>Consumer</strong></span>: An application or a service, which reads messages from a <span>queue</span><a id="id325194188" class="indexterm"></a> using a pull<span class="emphasis"><em> </em></span>model</li></ul></div><p>A pull<span class="emphasis"><em> </em></span>model means that a producer<span class="strong"><strong> </strong></span>has actually to ask a queue to receive messages. Of course, there can be multiple producers and multiple consumers—this is where the lock duration<span class="strong"><strong> </strong></span>feature is especially helpful as it ensures that only a single consumer reads a message at any one time.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch14lvl3sec65"></a>Topics</h4></div></div></div><p>Topics are a slightly different model <span>than</span><a id="id325218078" class="indexterm"></a> queues as they allow you to implement a pub/sub communication model. When a queue is a point-to-point communication, topics give you an option to distribute different messages to a different queue:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/0033bf40-a5e6-4ad9-8dca-705124ca8512.png" /></div><p>This model makes it possible to filter messages and isolate them, so a consumer reads only those, which they are interested in.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip168"></a>Note</h3><p>Remember, topics are not available in the basic<span class="strong"><strong> </strong></span>tier—you have to use at least the standard tier.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch14lvl3sec66"></a>Relays</h4></div></div></div><p>Both queues and <span>topics</span><a id="id325218115" class="indexterm"></a> are models, which are designed to deliver one-way communication only—a producer sends a message and a receiver reads it. If you want to implement bidirectional communication, you have to use a relay:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/e9caba3c-4c41-46fb-af27-95b17efc3c1c.png" /></div><p>Azure Relay<span class="emphasis"><em> </em></span>is, in fact, a separate service, and we will not cover it in this chapter. There are, however, many great features, which you may find helpful in your applications: </p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">It is designed to expose services securely, which are hosted within a corporate network.</li><li style="list-style-type: disc">It allows different communication models like one-directional, pub/sub, andtwo-way communication.</li><li style="list-style-type: disc">It does not alter the network as a VPN does, making it more stable and scoped to a single application endpoint.</li></ul></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch14lvl2sec141"></a>Azure Service Bus design patterns</h3></div></div></div><p>Azure Service Bus is often a central point of integration for many different cloud services—it can be used in a variety of scenarios, including data integration, broadcasting information, or even bidirectional communication. As the <span>service</span><a id="id325320042" class="indexterm"></a> is rich in different features, you can use it to implement various responsibilities. You can find many examples of design patterns for Azure Service Bus in the <span class="emphasis"><em>Further reading</em></span> section in this chapter.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch14lvl2sec142"></a>Developing solutions with Azure Service Bus SDK</h3></div></div></div><p>There is a rich database of many different examples for working with Azure <span>Service</span><a id="id325320060" class="indexterm"></a> Bus<span class="emphasis"><em>, </em></span>available on GitHub (you can find a link in the <span class="emphasis"><em>Further reading</em></span><span class="strong"><strong> </strong></span>section), so we will cover only the basic ones in this chapter. Here you can find the most simple way to send a message to a queue:</p><pre class="programlisting">using System.Text;
using System.Threading.Tasks;
using Microsoft.Azure.ServiceBus;

namespace HandsOnAzure.ServiceBus
{
    internal class Program
    {
        private static void Main()
        {
            MainAsync().GetAwaiter().GetResult();
        }

        private static async Task MainAsync()
        {
            var client = new QueueClient("&lt;connection-string&gt;", "&lt;queue-name&gt;");
            var message = "This is my message!";

            await client.SendAsync(new Message(Encoding.UTF8.GetBytes(message)));
        }
    }
}</pre><p>As you can see, all it requires (at least to get the basic functionality) is to use a <code class="literal">QueueClient</code><span class="strong"><strong> </strong></span>instance. If you want to work with a topic, you could use <code class="literal">TopicClient</code><span class="strong"><strong> </strong></span>instead:</p><pre class="programlisting">var client = new TopicClient("&lt;connection-string&gt;", "&lt;topic-name&gt;");</pre><p>In fact, all you need is to install the <code class="literal">Microsoft.Azure.ServiceBus</code><span class="strong"><strong> </strong></span>NuGet package. After I ran the preceding code three times and checked my queue, this is what I saw in the portal:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/f0bf677d-cd3c-4530-a53b-97c27451edb1.png" /></div><p>As you can see, there are three active messages. That means that I have successfully published them and they are ready to be pulled. There are many different options for pulling a message—here you can find an example using <code class="literal">PeekAsync</code>:</p><pre class="programlisting">using System;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Azure.ServiceBus.Core;

namespace HandsOnAzure.ServiceBus.Reader
{
    internal class Program
    {
        private static void Main()
        {
            MainAsync().GetAwaiter().GetResult();

            Console.ReadLine();
        }

        private static async Task MainAsync()
        {
            var receiver =
                new MessageReceiver(
                    "&lt;connection-string&gt;",
                    "&lt;queue-name&gt;");

            while (true)
            {
                var message = await receiver.PeekAsync();
                if(message == null) continue;

                Console.WriteLine($"New message: [{message.ScheduledEnqueueTimeUtc}] {Encoding.UTF8.GetString(message.Body)}");
                await Task.Delay(100);
            }
        }
    }
}</pre><p>However, if you only peek messages, you will not create a message store. To <span>actually</span><a id="id325323819" class="indexterm"></a> do that, you have to use <code class="literal">ReceiveAsync</code>:</p><pre class="programlisting">var message = await receiver.ReceiveAsync();</pre><p> </p><p> </p><p>The difference will be visible when you read messages using both methods. <code class="literal">PeekAsync</code><span class="strong"><strong> </strong></span>will not change the state of messages (so they will be still visible as active, even if you set the <code class="literal">ReceiveMode</code><span class="strong"><strong> </strong></span>option to <code class="literal">ReceiveAndDelete</code>). <code class="literal">ReceiveAsync</code><span class="strong"><strong> </strong></span>will use the value of a <code class="literal">ReceiveMode</code><span class="strong"><strong> </strong></span>option and possibly act as an atomic <code class="literal">CompleteAsync</code><span class="strong"><strong> </strong></span>operation.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip169"></a>Note</h3><p>To mark messages as read after using <code class="literal">PeekAsync</code><span class="strong"><strong> , </strong></span>you can use <code class="literal">CompleteAsync</code>.</p></div><p>We will cover more advanced scenarios later in this chapter.</p></div></div>