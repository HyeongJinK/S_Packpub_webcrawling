<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch14lvl1sec121"></a>Advanced features of Azure Service Bus</h2></div></div><hr /></div><p>We have already covered some of the basics of the Azure Service Bus,<span class="emphasis"><em> </em></span>like SDK, the most crucial concepts, and security considerations. Now we will focus a little bit on more advanced use cases, like dead lettering, performance, sessions, and transactions. All those topics are crucial when developing a reliable and important <span>service</span><a id="id325469114" class="indexterm"></a> integrating many different applications and systems. Also remember to take a look at the Azure Service Bus<span class="emphasis"><em> </em></span>examples in the <span class="emphasis"><em>Further reading</em></span><span class="strong"><strong> </strong></span>section, as it points to a GitHub repository where you can find many different use cases and concepts when using this service.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch14lvl2sec145"></a>Dead lettering</h3></div></div></div><p>In general, dead lettering<span class="emphasis"><em> </em></span><span>means</span><a id="id325469061" class="indexterm"></a> that there are messages in a queue considered as dead (because there was no receiver interested in pulling them) and you have two options to proceed:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Either delete them permanently</li><li style="list-style-type: disc">Push them to an additional queue, named a dead letter queue</li></ul></div><p>In Azure Service Bus,<span class="emphasis"><em> </em></span>you have two options to push a message to a dead letter queue:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Set the maximum lifetime of a message—once it expires, it is automatically moved to a dead letter queue</li><li style="list-style-type: disc">Use the <code class="literal">DeadLetterAsync</code><span class="strong"><strong> </strong></span>method on <code class="literal">MessageReceiver</code><span class="strong"><strong> </strong></span>as follows:</li></ul></div><pre class="programlisting">await receiver.DeadLetterAsync("&lt;lock-token&gt;", "&lt;reason&gt;");</pre><p>Here you can find the complete example, and you can find a lock token:</p><pre class="programlisting">while (true)
{
  var message = await receiver.ReceiveAsync();
  if(message == null) continue;

  Console.WriteLine($"New message: [{message.ScheduledEnqueueTimeUtc}] {Encoding.UTF8.GetString(message.Body)}");

  await receiver.DeadLetterAsync(message.SystemProperties.LockToken, "HandsOnAzure - test");
  await Task.Delay(100);
}</pre><p> </p><p> </p><p> </p><p> </p><p>Once you push messages to a dead letter queue, their status will be visible in the portal:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/32c7d9e5-a6cf-4b7f-bdd9-289049fd3779.png" /></div><p>Of course, it is possible to fetch messages from a dead <span>letter</span><a id="id325317160" class="indexterm"></a> queue. To get the name, you can use the following method:</p><pre class="programlisting">var deadLetterQueueName = EntityNameHelper.FormatDeadLetterPath("&lt;entity-path&gt;");</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch14lvl2sec146"></a>Sessions</h3></div></div></div><p>In Azure Service Bus,<span class="emphasis"><em> </em></span>sessions are <span>used</span><a id="id325122057" class="indexterm"></a> to achieve a FIFO guarantee. In general, the service does not control the relationship between messages, so even if in most cases the order is preserved, it is not guaranteed. To put a message to a session, you have to leverage a <code class="literal">SessionId</code><span class="strong"><strong> </strong></span>property:</p><pre class="programlisting">await client.SendAsync(new Message(Encoding.UTF8.GetBytes(message)) { SessionId = Guid.Empty.ToString()});</pre><p> </p><p> </p><p>To handle a session on the receiver side, you have to use the <code class="literal">RegisterSessionHandler</code><span class="strong"><strong> </strong></span>method on a <code class="literal">QueueClient</code><span class="strong"><strong> </strong></span>instance:</p><pre class="programlisting">var client = new QueueClient("&lt;connection-string&gt;", "&lt;queue-name&gt;");
client.RegisterSessionHandler((session, message, ct) =&gt; Task.FromResult(new SessionHandler()), args =&gt; Task.CompletedTask);</pre><p>Additionally, you will have to implement <code class="literal">IMessageSession</code><span class="strong"><strong>.</strong></span></p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch14lvl2sec147"></a>Transactions</h3></div></div></div><p>Transactions in Azure Service <span>Bus</span><a id="id325128267" class="indexterm"></a><span class="emphasis"><em> </em></span>are a wide topic referring to many different entities, which you can work with in this service:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Clients (<code class="literal">QueueClient</code>, <code class="literal">TopicClient</code>)</li><li style="list-style-type: disc">Messages (by using operations like <code class="literal">Complete</code>, <code class="literal">Defer</code>, <code class="literal">Abandon</code> , and many more)</li><li style="list-style-type: disc">Sessions (<code class="literal">GetState</code>/<code class="literal">SetState</code>)</li></ul></div><p>As you can see, there are no receive operations listed; this is because there is an assumption that they are atomic by design.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note172"></a>Note</h3><p>In general, there is a requirement for using the <code class="literal">ReceiveMode.PeekLock</code><span class="strong"><strong> </strong></span>mode when pulling messages and opening a transaction scope inside a loop or an <code class="literal">OnMessage</code><span class="strong"><strong> </strong></span>callback.</p></div><p>You can refer to the following code snippet to get a better picture of what we are talking about in this section:</p><pre class="programlisting">var message = receiver.Receive();
using (scope = new TransactionScope())
{
   var newMessage = // transfer

   sender.Send(newMessage);
   message.Complete();

   scope.Complete();
}</pre><p> </p><p> </p><p> </p><p>In the above example, a processor (which at the same moment is responsible for producing a message) marks a message as complete, while transferring a new message to another queue. The whole model leverages the autoforwarding feature of Azure Service Bus. The following is an <span>example</span><a id="id325128384" class="indexterm"></a> of a topic:</p><pre class="programlisting">var subscription = new SubscriptionDescription(sourceTopic, subscriptionName);
subscription.ForwardTo = destinationTopic;
namespaceManager.CreateSubscription(subscription);</pre><p>When a transaction is implemented, you can be sure that committing to a queue log will only happen if the whole transaction succeeds; otherwise, there will be simply no trace of the messages that were handled inside it.</p></div></div>