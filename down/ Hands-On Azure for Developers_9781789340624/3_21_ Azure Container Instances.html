<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec27"></a>Azure Container Instances</h2></div></div><hr /></div><p>While AKS is a complete orchestration solution, you might sometimes like to use a lightweight service <span>instead</span><a id="id325695123" class="indexterm"></a> that provides the most crucial features related to running containers. These features include no need to provision and manage virtual machines, security, and integrated public IP connectivity. If you want to run a containerized simple application such as a WebJob or website, <span class="strong"><strong>Azure Container Instances</strong></span> (<span class="strong"><strong>ACI</strong></span>) can be used to satisfy your requirements.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec26"></a>Creating and deploying an application and container</h3></div></div></div><p>We will start our journey with ACI <span>by</span><a id="id325694961" class="indexterm"></a> creating an application that we will host in a container. In the previous section, we <span>used</span><a id="id325694955" class="indexterm"></a> a simple Python script—this time we will try to use Node.js. </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note47"></a>Note</h3><p>As always, you can find source files in the appropriate source file folder for this chapter.</p></div><p> </p><p> </p><p>The very first thing we need once more is <code class="literal">Dockerfile</code>. As you remember, it contains instructions on how an application should be run. The following is an example for this exercise:</p><pre class="programlisting"><span class="strong"><strong>FROM node:8.9.3-alpine</strong></span>
<span class="strong"><strong>RUN mkdir -p /bin/</strong></span>
<span class="strong"><strong>COPY ./app/ /bin/</strong></span>
<span class="strong"><strong>WORKDIR /bin</strong></span>
<span class="strong"><strong>RUN npm install</strong></span>
<span class="strong"><strong>CMD node index.js</strong></span></pre><p>If you read it carefully, you will find it pretty easy—what it does (step-by-step) is as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Installs the specific Node.js version (this time <span class="strong"><strong>alpine</strong></span>, which is a smaller distribution well designed for running in containers)</li><li>Creates a new working directory</li><li>Copies files to it</li><li>Installs all dependencies with the <code class="literal">npm install</code><span class="emphasis"><em> </em></span>command</li><li>Starts an application by providing its starting point</li></ol></div><p>Now we can create a container using the following command:</p><pre class="programlisting"><span class="strong"><strong>docker build ./ -t {CONTAINER_NAME}</strong></span></pre><p>After a moment, you should have a new image created and added. If you face any problems, make sure that you are in the correct directory and not doubling its name.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip48"></a>Note</h3><p>Remember that you can always check what images are currently available for you and their names. To do so, you can use the following Docker command: <code class="literal">docker images</code><span class="emphasis"><em>.</em></span></p></div><p>Now we can verify how our application works. To start it, use the following command:</p><pre class="programlisting"><span class="strong"><strong>docker run -d -p 8080:80 {CONTAINER_NAME}</strong></span></pre><p>You can go to <code class="literal">localhost:8080</code> and check whether your application is running. If everything is configured correctly, you should be able to see the <code class="literal">Welcome to Azure Container Instances!</code><span class="emphasis"><em> </em></span>message in the center of the screen.</p><p> </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip49"></a>Note</h3><p>Sometimes, you may face problems when working with some web applications and running them locally—for some reason, you cannot connect to them using the specified port. In such situations, it is always a good idea to reconfigure them and use different ports.</p></div><p>Now we will push an image to Azure so we can use it later in ACI.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec17"></a>Pushing an image to Azure Container Registry</h4></div></div></div><p>You can find full instructions on <span>how</span><a id="id325115415" class="indexterm"></a> you can work with ACI in <span class="emphasis"><em>Container Registry and Kubernetes clusters </em></span>section of this chapter. Now, the idea is the same as when working with AKS—we have to perform the following actions:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Log in to ACR</li><li>Tag an image</li><li>Push it to ACR</li></ol></div><p>You will need the following three commands:</p><pre class="programlisting"><span class="strong"><strong><span>az</span> acr <span>login</span><span> --name</span></strong></span><span class="strong"><strong> {ACR_NAME}</strong></span>
<span class="strong"><strong>docker tag {CONTAINER_NAME} {ACR_LOGIN_SERVER}/{CONTAINER_NAME}:v1</strong></span>
<span class="strong"><strong>docker push {ACR_LOGIN_SERVER}/{CONTAINER_NAME}:v1</strong></span>
</pre><p>After a successful push, we can deploy an application to ACI.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec18"></a>Deploying an application to ACI</h4></div></div></div><p>The first thing we <span>need</span><a id="id325117149" class="indexterm"></a> is an instance of ACI. As usual, in Azure Portal click on <strong class="userinput"><code>+ Create a resource</code></strong><span class="strong"><strong> </strong></span>and search for <code class="literal">Container Instances</code>.</p><p>You should see a similar wizard to the following:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/037837ad-2bfc-4f6b-b163-e362a7507f25.png" /></div><p>The important thing here is that you have to select <strong class="userinput"><code>Private</code></strong><span class="strong"><strong> </strong></span>when deciding on a <strong class="userinput"><code>Container image type</code></strong>. Choosing this option will display additional fields, which have to be filled in. When creating ACI, you will need to provide <strong class="userinput"><code>Container image</code></strong>. This is just the Docker tag you created when pushing an image to Container Registry. In my case it was <code class="literal">handsonazureregistry.azurecr.io/ handsonazure-aci</code>. The image registry login server<span class="strong"><strong> </strong></span>is simply a login server for the registry (you can find it in the <strong class="userinput"><code>Overview</code></strong><span class="strong"><strong> </strong></span>blade of ACR). We need two more things—the registry username and password. While the username is simply the registry name, a password can be obtained using the following command:</p><pre class="programlisting"><span class="strong"><strong>az acr credential show --name {REGISTRY_NAME}--query "passwords[0].value"</strong></span></pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note50"></a>Note</h3><p>To obtain a password, admin credentials have to be enabled. To enable them from CMD, use the following command:<code class="literal"><span class="strong"><strong>az acr update -n {REGISTRY_NAME} --admin-enabled true</strong></span></code></p></div><p> Now we can go to the <strong class="userinput"><code>Configuration</code></strong><span class="strong"><strong> </strong></span>section:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/7987c3c1-aca3-49f2-811e-7439c271e0be.png" /></div><p>This time, all of these fields <span>should</span><a id="id325122112" class="indexterm"></a> be self-explanatory and, in fact, I left the default values in force during this exercise. You can change them if you feel other values will meet your requirements (such as, for example, the OS or available memory). Once all is set, you can click <strong class="userinput"><code>OK</code></strong><span class="strong"><strong> </strong></span>and publish an instance of your container. </p><p> </p><p> </p><p> </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip51"></a>Note</h3><p>If you have problems deploying a container from the portal, you can always use the Azure CLI. Here is the full command to do the same as we did in Azure Portal:<code class="literal"><span class="strong"><strong>az container create --resource-group {RG_NAME}--name {ACI_NAME} --image {ACR_LOGIN_SERVER}/{CONTAINER_NAME}:v1 --cpu 1 --memory 1 --registry-login-server {ACR_LOGIN_SERVER} --registry-username {REGISTRY_NAME} --registry-password {REGISTRY_PASSWORD} --dns-name-label {DNS_LABEL} --ports 80</strong></span></code></p></div><p>When deployment is complete, go to your instance of ACI and check the <strong class="userinput"><code>Overview</code></strong><span class="strong"><strong> </strong></span>blade. Copy the value of the <code class="literal">FQDN</code> field and paste it into your browser. You should be able to see the very same screen you saw locally:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/75e938a1-b570-441c-9c09-e51971f1634b.png" /></div><p>That is all! As you can see, using Azure Container Services is a really quick way to deploy your application in a container using a minimal set of features. In the next section, we will focus on leveraging containers in App Services.</p></div></div></div>