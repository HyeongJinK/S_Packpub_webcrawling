<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec64"></a>Workflow in Azure Functions – Durable Functions</h2></div></div><hr /></div><p>In most cases, the best idea for working with functions<span class="emphasis"><em> </em></span>is to keep them stateless. This <span>makes</span><a id="id325310881" class="indexterm"></a> things much easier as you do not have to worry about sharing resources and storing state. However, there are cases where you will like to access it and distribute between different instances of your functions. In such scenarios (such as orchestrating a workflow or scheduling a task to be done), a better option to start with would be to leverage the capabilities of Durable Functions, an extension to the main runtime, which changes the way you work a little bit.</p><p> </p><p>It changes the way Azure Functions works as it lets you resume from where the execution was paused or stopped and introduces the possibility to take the output of one function and pass it as input. We will not cover this in detail, as this book is not only <span>about</span><a id="id325310861" class="indexterm"></a> Azure Functions, but you will get a glimpse of this feature, which will help you start it on your own.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip104"></a>Note</h3><p>To get started, you don't need any extra extensions—the only thing you will need is an additional NuGet package named <code class="literal">Microsoft.Azure.WebJobs.Extensions.DurableTask</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec64"></a>Orchestrations and activities</h3></div></div></div><p>The main elements of Durable Functions are <span>orchestrations</span><a id="id325310699" class="indexterm"></a> and activities. There are some significant differences between them:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">Orchestrations</code>: These are designed to orchestrate different activities. They should be single-threaded and idempotent, and they can use only a very limited set of asynchronous methods. They are scaled based on the number of internal queues. What's more, they control the flow of one or more activities.</li><li style="list-style-type: disc"><code class="literal">Activities</code>: These should contain most of the logic of your application. They work as typical functions (without the limits of orchestrations). They are scaled to multiple VMs.</li></ul></div><p>Here, you can find the code for both types of functions:</p><pre class="programlisting">[FunctionName("Orchestration")]
public static async Task Orchestration_Start([OrchestrationTrigger] DurableOrchestrationContext context)
{
  var payload = context.GetInput&lt;string&gt;();
  await context.CallActivityAsync(nameof(Activity), payload);
}

[FunctionName("Activity")]
public static string Activity([ActivityTrigger] DurableActivityContext context)
{
  var payload = context.GetInput&lt;string&gt;();
  return $"Current payload is {payload}!";
}</pre><p> </p><p> </p><p>As you can see, they are both decorated with the <code class="literal">[FunctionName]</code><span class="strong"><strong> </strong></span>attribute as a typical function—the difference comes from the trigger that's used.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec65"></a>Orchestration client</h3></div></div></div><p>To get started with an orchestration, you need a host for it. In <span>Durable</span><a id="id325122049" class="indexterm"></a> Functions, that host is the orchestration client, which enables you to perform the following actions on an orchestration:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Start it</li><li style="list-style-type: disc">Terminate it</li><li style="list-style-type: disc">Get its status</li><li style="list-style-type: disc">Raise an event and pass it to an orchestration</li></ul></div><p>The basic code for a client is pretty simple:</p><pre class="programlisting">[FunctionName("Orchestration_Client")]
public static async Task&lt;string&gt; Orchestration_Client(
  [HttpTrigger(AuthorizationLevel.Anonymous, "post", Route = "start")] HttpRequestMessage input,
  [OrchestrationClient] DurableOrchestrationClient starter)
{
  return await starter.StartNewAsync("Orchestration", await input.Content.ReadAsStringAsync());
}</pre><p>As you can see from the preceding code, we started an orchestration by providing its name and passing some payload, which will be deserialized and decoded. Here, you can find an example of a client that has been hosted to terminate an instance by passing its identifier:</p><pre class="programlisting">[FunctionName("Terminate")]
public static async Task Terminate(
  [HttpTrigger(AuthorizationLevel.Anonymous, "post", Route = "terminate/{id}")] HttpRequestMessage input,
  string id,
  [OrchestrationClient] DurableOrchestrationClient client)
{
  var reason = "Manual termination";
  await client.TerminateAsync(id, reason);
}</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec66"></a>Orchestration history</h3></div></div></div><p>The way <span>Durable</span><a id="id325124997" class="indexterm"></a> Functions work ensures that, if any activity is replayed, its result will not be evaluated again (this is why orchestrations have to be idempotent). Here, you can find a diagram that shows how the framework works in detail:</p><div class="mediaobject"><img src="/graphics/9781789340624/graphics/e39b14e9-a73e-4204-aa75-e0f5f05ddb49.png" /></div><p>To make a long story short, I divided the process into four parts:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Dispatcher</strong></span>: This is the internal part of the framework, which is responsible for calling orchestrations, performing replays, and saving the state</li><li style="list-style-type: disc"><span class="strong"><strong>Orchestrator function</strong></span>: This is an orchestration that calls activities
</li><li style="list-style-type: disc"><span class="strong"><strong>Storage</strong></span>:<span class="strong"><strong> </strong></span>This is a place where the orchestration history is stored</li><li style="list-style-type: disc"><span class="strong"><strong>Queue</strong></span>: This is an internal queue (implemented using Azure Storage Queues), which is used to control the flow of execution of an orchestration</li></ul></div><p>The way Durable Functions works is as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Dispatchers run an orchestration, which calls <code class="literal">Activity1</code> and awaits its result</li><li>The control is returned to a dispatcher, which commits the state in the orchestration history and pushes a message to a queue</li><li>In the meantime, orchestration is deallocated, saving memory and processor<span></span></li><li>After fetching a message from a queue and finishing a task, the dispatcher<span class="strong"><strong> </strong></span>recreates an orchestration and replays all activities</li><li>If it finds that this particular activity has been finished, it gets only its result and proceeds to another activity</li></ol></div><p>The preceding process lasts until all of the activities are processed. Information about execution history can be found in a table called <code class="literal">DurableFunctionsHubHistory</code>, which you can find inside the Azure Table Storage used by your function app.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec67"></a>Timers</h3></div></div></div><p>Sometimes, you might want to schedule work after a specific delay. While using traditional functions, you have to create a custom solution that will somehow trigger a workflow at a specific time. In <span>Durable</span><a id="id325128366" class="indexterm"></a> Functions, it is as easy as writing one line of code. Consider the following example:</p><pre class="programlisting">[FunctionName("Orchestration_Client")]
public static async Task&lt;string&gt; Orchestration_Client(
  [HttpTrigger(AuthorizationLevel.Anonymous, "post", Route = "start")] HttpRequestMessage input,
  [OrchestrationClient] DurableOrchestrationClient starter)
{
  return await starter.StartNewAsync("Orchestration", null);
}

[FunctionName("Orchestration")]
public static async Task Orchestration_Start([OrchestrationTrigger] DurableOrchestrationContext context, TraceWriter log)
{
  log.Info($"Scheduled at {context.CurrentUtcDateTime}");

  await context.CreateTimer(context.CurrentUtcDateTime.AddHours(1), CancellationToken.None);
  await context.CallActivityAsync(nameof(Activity), context.CurrentUtcDateTime);
}

[FunctionName("Activity")]
public static void Activity([ActivityTrigger] DurableActivityContext context, TraceWriter log)
{
  var date = context.GetInput&lt;DateTime&gt;();
  log.Info($"Executed at {date}");
}</pre><p>In the preceding example, I used the <code class="literal">context.CreateTimer()</code><span class="strong"><strong> </strong></span>method, which allows for creating a delay in function execution. If the previous orchestration is executed, it will return control to the dispatcher after awaiting a timer. Thanks to this, you will not be charged for this particular function execution as it will be deallocated and recreated later, after waiting for a specific interval.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec68"></a>External events</h3></div></div></div><p>In <span>Durable</span><a id="id325143078" class="indexterm"></a> Functions, it is possible to wait for an external event before proceeding with a workflow. This is especially helpful if you want to create an interactive flow, where you initiate a process in one place and have a requirement to wait for someone's decision. To raise an event, you can use the following function:</p><pre class="programlisting">[FunctionName("Orchestration_Raise")]
public static async Task Orchestration_Raise(
  [HttpTrigger(AuthorizationLevel.Anonymous, "post", Route = "start_raise/{id}/{event}")] HttpRequestMessage input,
  string id,
  string @event,
  [OrchestrationClient] DurableOrchestrationClient starter)
{
  await starter.RaiseEventAsync(id, @event, await input.Content.ReadAsStringAsync());
}</pre><p>Here, you can find an example of waiting for an event:</p><pre class="programlisting">[FunctionName("Orchestration")]
public static async Task&lt;string&gt; Orchestration_Start([OrchestrationTrigger] DurableOrchestrationContext context)
{
  var @event = await context.WaitForExternalEvent&lt;int&gt;("Approved");

  if (@event == 1)
  {
    var result = await context.CallActivityAsync&lt;string&gt;(nameof(Activity), @event);
    return result;
  }

  return "Not Approved";
}</pre><p>The way this works can be described as follows: the first functions allows you to raise a custom event by passing the appropriate parameters. The second function is paused while waiting for the <code class="literal">context.WaitForExternalEvent()</code> function. If you send an event with the <code class="literal">Approved</code> type, a function will be resumed and will continue. Additionally, you can pass a payload of an event, which will be passed as a result of <code class="literal">WaitForExternalEvent()</code>. This method works in the same way as timers and other Durable Functions functions, which are available in <code class="literal">DurableOrchestrationType</code>—while awaiting, control is returned to the dispatcher and the function itself is deallocated.</p></div></div>